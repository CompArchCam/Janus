<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Dr. Memory: Umbra: DynamoRIO Shadow Memory Extension</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dr. Memory
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__umbra.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Umbra: DynamoRIO Shadow Memory Extension</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__umbra__shadow__memory__info__t.html">_umbra_shadow_memory_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__umbra__map__options__t.html">_umbra_map_options_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ga85ff5a010e1e89f8ee8b109157b02281"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga85ff5a010e1e89f8ee8b109157b02281">DRMGR_PRIORITY_NAME_EXCPT_UMBRA</a>&#160;&#160;&#160;&quot;umbra_except&quot;</td></tr>
<tr class="separator:ga85ff5a010e1e89f8ee8b109157b02281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf4d14d74192a868f7861c1e87a5cd06"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gabf4d14d74192a868f7861c1e87a5cd06">UMBRA_MAP_SCALE_IS_UP</a>(scale)  &#160;&#160;&#160;((scale) &gt;= <a class="el" href="group__umbra.html#gga670274c9cd812c91317125c7179cb15aa257a8fc2cc1cd3516a317510a47148ca">UMBRA_MAP_SCALE_UP_2X</a>)</td></tr>
<tr class="separator:gabf4d14d74192a868f7861c1e87a5cd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga1b719e93a8011f4976720d37e6657d79"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__umbra__shadow__memory__info__t.html">_umbra_shadow_memory_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a></td></tr>
<tr class="separator:ga1b719e93a8011f4976720d37e6657d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad20b7206ae18024a3a7b1ae23b71f196"><td class="memItemLeft" align="right" valign="top">typedef struct _umbra_map_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a></td></tr>
<tr class="separator:gad20b7206ae18024a3a7b1ae23b71f196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d2b65225bc91de41cc4e715723fb1bc"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga2d2b65225bc91de41cc4e715723fb1bc">app_memory_create_cb_t</a>) (<a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, app_pc start, size_t size)</td></tr>
<tr class="separator:ga2d2b65225bc91de41cc4e715723fb1bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga751e3c1aba75904b324a3ad41665868f"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__umbra__map__options__t.html">_umbra_map_options_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga751e3c1aba75904b324a3ad41665868f">umbra_map_options_t</a></td></tr>
<tr class="separator:ga751e3c1aba75904b324a3ad41665868f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aa58774b9ee9f296b953695c9db57d5"><td class="memItemLeft" align="right" valign="top">typedef bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga2aa58774b9ee9f296b953695c9db57d5">shadow_iterate_func_t</a>) (<a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, <a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a> *info, void *user_data)</td></tr>
<tr class="separator:ga2aa58774b9ee9f296b953695c9db57d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gadf764cbdea00d65edcd07bb9953ad2b7"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <a class="el" href="group__umbra.html#ggadf764cbdea00d65edcd07bb9953ad2b7a28b395ded58393f41fcab8be32479122">DRMGR_PRIORITY_EXCPT_UMBRA</a> = -100
 }<tr class="separator:gadf764cbdea00d65edcd07bb9953ad2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga670274c9cd812c91317125c7179cb15a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga670274c9cd812c91317125c7179cb15a">umbra_map_scale_t</a> { , <br />
&#160;&#160;<a class="el" href="group__umbra.html#gga670274c9cd812c91317125c7179cb15aa70662a2ec93fd7702942d5f473ade106">UMBRA_MAP_SCALE_DOWN_4X</a>, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#gga670274c9cd812c91317125c7179cb15aa362e915faa295d0503c9815bac7d5a58">UMBRA_MAP_SCALE_DOWN_2X</a>, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#gga670274c9cd812c91317125c7179cb15aa30e49a70fa05e2ff43b7c4b436199e29">UMBRA_MAP_SCALE_SAME_1X</a>, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#gga670274c9cd812c91317125c7179cb15aa257a8fc2cc1cd3516a317510a47148ca">UMBRA_MAP_SCALE_UP_2X</a>
<br />
 }<tr class="separator:ga670274c9cd812c91317125c7179cb15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gaaa9d16970f73407af0af6b173afd62b6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gaaa9d16970f73407af0af6b173afd62b6">umbra_map_flags_t</a> { <br />
&#160;&#160;<a class="el" href="group__umbra.html#ggaaa9d16970f73407af0af6b173afd62b6a16bca8c68c5e970c4457b64606a9671b">UMBRA_MAP_CREATE_SHADOW_ON_TOUCH</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#ggaaa9d16970f73407af0af6b173afd62b6ae42e8acda254c7bf3a3b196d070a284d">UMBRA_MAP_SHADOW_SHARED_READONLY</a> = 0x2
<br />
 }<tr class="separator:gaaa9d16970f73407af0af6b173afd62b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:gaa49d0c1fffdb93fdfd0db1278b1eaad9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gaa49d0c1fffdb93fdfd0db1278b1eaad9">umbra_shadow_memory_flags_t</a> { <a class="el" href="group__umbra.html#ggaa49d0c1fffdb93fdfd0db1278b1eaad9a6fbe76f298c0201ce92a4427a7805687">UMBRA_CREATE_SHADOW_SHARED_READONLY</a> = 0x1
 }<tr class="separator:gaa49d0c1fffdb93fdfd0db1278b1eaad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga218086740fc30ca9ec82ad9e1a8f94d0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga218086740fc30ca9ec82ad9e1a8f94d0">umbra_shadow_memory_type_t</a> { <br />
&#160;&#160;<a class="el" href="group__umbra.html#gga218086740fc30ca9ec82ad9e1a8f94d0aef9152f543316d474bf454114e8d57fa">UMBRA_SHADOW_MEMORY_TYPE_UNKNOWN</a> = 0x1, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#gga218086740fc30ca9ec82ad9e1a8f94d0a9757d1da5b2a5c95fb57ee2883cdfec1">UMBRA_SHADOW_MEMORY_TYPE_NOT_SHADOW</a> = 0x2, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#gga218086740fc30ca9ec82ad9e1a8f94d0a0c8cdfdebf602f0c39c581c229dffe6f">UMBRA_SHADOW_MEMORY_TYPE_NORMAL</a> = 0x4, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#gga218086740fc30ca9ec82ad9e1a8f94d0a4401ff2d8bd1c4f5e5274b3a251bf413">UMBRA_SHADOW_MEMORY_TYPE_SHARED</a> = 0x8, 
<br />
&#160;&#160;<a class="el" href="group__umbra.html#gga218086740fc30ca9ec82ad9e1a8f94d0a254f60164a8f40da3f6598d5e6015833">UMBRA_SHADOW_MEMORY_TYPE_SHADOW_NOT_ALLOC</a> = 0x10
<br />
 }<tr class="separator:ga218086740fc30ca9ec82ad9e1a8f94d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf7bd0146652ec43ce742f1bbe040c459"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gaf7bd0146652ec43ce742f1bbe040c459">umbra_init</a> (client_id_t client_id)</td></tr>
<tr class="separator:gaf7bd0146652ec43ce742f1bbe040c459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a53bbe9aac961d63d73f5e8942d9826"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga8a53bbe9aac961d63d73f5e8942d9826">umbra_exit</a> (void)</td></tr>
<tr class="separator:ga8a53bbe9aac961d63d73f5e8942d9826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f0ff18a03e1655eae02473a2e5d496b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga4f0ff18a03e1655eae02473a2e5d496b">umbra_create_mapping</a> (IN <a class="el" href="group__umbra.html#ga751e3c1aba75904b324a3ad41665868f">umbra_map_options_t</a> *ops, OUT <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> **map_out)</td></tr>
<tr class="separator:ga4f0ff18a03e1655eae02473a2e5d496b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ea226aa863c9e9d5feca0d7cc5e719d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga9ea226aa863c9e9d5feca0d7cc5e719d">umbra_destroy_mapping</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map)</td></tr>
<tr class="separator:ga9ea226aa863c9e9d5feca0d7cc5e719d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a333fbe844ebf9f9b8a12316b1c0b0d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga8a333fbe844ebf9f9b8a12316b1c0b0d">umbra_create_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN <a class="el" href="group__umbra.html#gaa49d0c1fffdb93fdfd0db1278b1eaad9">umbra_shadow_memory_flags_t</a> flags, IN app_pc app_addr, IN size_t app_size, IN ptr_uint_t value, IN size_t value_size)</td></tr>
<tr class="separator:ga8a333fbe844ebf9f9b8a12316b1c0b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d62f09ccc7bdf92822428a951efb33a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga7d62f09ccc7bdf92822428a951efb33a">umbra_delete_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN app_pc app_addr, IN size_t app_size)</td></tr>
<tr class="separator:ga7d62f09ccc7bdf92822428a951efb33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c80f899839083562bd14355c4b2810d"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga7c80f899839083562bd14355c4b2810d">umbra_num_scratch_regs_for_translation</a> (OUT int *num_regs)</td></tr>
<tr class="separator:ga7c80f899839083562bd14355c4b2810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4371a006da20f17c0621ee4dd2f0cc4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gaa4371a006da20f17c0621ee4dd2f0cc4">umbra_insert_app_to_shadow</a> (IN void *drcontext, IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN instrlist_t *ilist, IN instr_t *where, IN reg_id_t addr_reg, IN reg_id_t *scratch_regs, IN int num_scratch_regs)</td></tr>
<tr class="separator:gaa4371a006da20f17c0621ee4dd2f0cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c27309e421f1d151fe8e29373c41b71"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga4c27309e421f1d151fe8e29373c41b71">umbra_read_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN app_pc app_addr, IN size_t app_size, INOUT size_t *shadow_size, OUT byte *buffer)</td></tr>
<tr class="separator:ga4c27309e421f1d151fe8e29373c41b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf368cd2ef69d498900fecbeae39781f4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gaf368cd2ef69d498900fecbeae39781f4">umbra_write_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN app_pc app_addr, IN size_t app_size, INOUT size_t *shadow_size, IN byte *buffer)</td></tr>
<tr class="separator:gaf368cd2ef69d498900fecbeae39781f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafb51fb89b014b9bbf0dbe44c2d47b2a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gaafb51fb89b014b9bbf0dbe44c2d47b2a">umbra_shadow_set_range</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN app_pc app_addr, IN size_t app_size, OUT size_t *shadow_size, IN ptr_uint_t value, IN size_t value_size)</td></tr>
<tr class="separator:gaafb51fb89b014b9bbf0dbe44c2d47b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4622bfe2480822fd1212f3a3c61a94c0"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga4622bfe2480822fd1212f3a3c61a94c0">umbra_shadow_copy_range</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN app_pc app_src, IN app_pc app_dst, IN size_t app_size, OUT size_t *shadow_size)</td></tr>
<tr class="separator:ga4622bfe2480822fd1212f3a3c61a94c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a58ed96cd19b0aaa6415670aad9acc1"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga7a58ed96cd19b0aaa6415670aad9acc1">umbra_value_in_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, INOUT app_pc *app_addr, IN size_t app_size, IN ptr_uint_t value, IN size_t value_size, OUT bool *found)</td></tr>
<tr class="separator:ga7a58ed96cd19b0aaa6415670aad9acc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c122a4fbf999b360fad30369848e279"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga6c122a4fbf999b360fad30369848e279">umbra_get_shadow_block_size</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, OUT size_t *size)</td></tr>
<tr class="separator:ga6c122a4fbf999b360fad30369848e279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1163803823fd29ba89a5d0272670b89"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gaa1163803823fd29ba89a5d0272670b89">umbra_iterate_app_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN void *user_data, IN bool(*iter_func)(<a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map,                                                                                                                                                                                   const dr_mem_info_t *info,                                                                                                                                                                                   void *user_data))</td></tr>
<tr class="separator:gaa1163803823fd29ba89a5d0272670b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada2c4b1e3f332078ae5c3c58c6ce7e94"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gada2c4b1e3f332078ae5c3c58c6ce7e94">umbra_iterate_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN void *user_data, IN <a class="el" href="group__umbra.html#ga2aa58774b9ee9f296b953695c9db57d5">shadow_iterate_func_t</a> iter_func)</td></tr>
<tr class="separator:gada2c4b1e3f332078ae5c3c58c6ce7e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga720d39f0f8f8c8fa23a8d100acf2b414"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga720d39f0f8f8c8fa23a8d100acf2b414">umbra_get_shadow_memory_type</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN byte *shadow_addr, OUT <a class="el" href="group__umbra.html#ga218086740fc30ca9ec82ad9e1a8f94d0">umbra_shadow_memory_type_t</a> *shadow_type)</td></tr>
<tr class="separator:ga720d39f0f8f8c8fa23a8d100acf2b414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga372042a059dbdc71a4b045da3ff48cbb"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga372042a059dbdc71a4b045da3ff48cbb">umbra_shadow_memory_is_shared</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN byte *shadow_addr, OUT <a class="el" href="group__umbra.html#ga218086740fc30ca9ec82ad9e1a8f94d0">umbra_shadow_memory_type_t</a> *shadow_type)</td></tr>
<tr class="separator:ga372042a059dbdc71a4b045da3ff48cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ac818f59d2b343c99d6002301dff2b9"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga0ac818f59d2b343c99d6002301dff2b9">umbra_get_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN app_pc app_addr, OUT byte **shadow_addr, INOUT <a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a> *shadow_info)</td></tr>
<tr class="separator:ga0ac818f59d2b343c99d6002301dff2b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad03e483ea5b7d2047efc879f5c2b68d1"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#gad03e483ea5b7d2047efc879f5c2b68d1">umbra_replace_shared_shadow_memory</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN app_pc app_addr, OUT byte **shadow_addr)</td></tr>
<tr class="separator:gad03e483ea5b7d2047efc879f5c2b68d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64e7e565d3761fbcbd17d3677b607e6b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga64e7e565d3761fbcbd17d3677b607e6b">umbra_create_shared_shadow_block</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN ptr_uint_t value, IN size_t value_size, OUT byte **block)</td></tr>
<tr class="separator:ga64e7e565d3761fbcbd17d3677b607e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f47b3624ff3705ae9622335f8ecbf7f"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga3f47b3624ff3705ae9622335f8ecbf7f">umbra_get_shared_shadow_block</a> (IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, IN ptr_uint_t value, IN size_t value_size, OUT byte **block)</td></tr>
<tr class="separator:ga3f47b3624ff3705ae9622335f8ecbf7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16080e1e17da8b608c5736f45644e713"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__umbra.html#ga16080e1e17da8b608c5736f45644e713">umbra_shadow_memory_info_init</a> (<a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a> *info)</td></tr>
<tr class="separator:ga16080e1e17da8b608c5736f45644e713"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ga85ff5a010e1e89f8ee8b109157b02281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DRMGR_PRIORITY_NAME_EXCPT_UMBRA&#160;&#160;&#160;&quot;umbra_except&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Name of Umbra signal/exception events. </p>

</div>
</div>
<a class="anchor" id="gabf4d14d74192a868f7861c1e87a5cd06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define UMBRA_MAP_SCALE_IS_UP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">scale</td><td>)</td>
          <td>&#160;&#160;&#160;((scale) &gt;= <a class="el" href="group__umbra.html#gga670274c9cd812c91317125c7179cb15aa257a8fc2cc1cd3516a317510a47148ca">UMBRA_MAP_SCALE_UP_2X</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if a shadow memory mapping scale is scale up or down. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga2d2b65225bc91de41cc4e715723fb1bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* app_memory_create_cb_t) (<a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, app_pc start, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Application memory creation/deletion callback function type. These callbacks are called when the application performs system calls to allocate or delete memory. </p>

</div>
</div>
<a class="anchor" id="ga2aa58774b9ee9f296b953695c9db57d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef bool(* shadow_iterate_func_t) (<a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map, <a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a> *info, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate callback function type for umbra_iterate_shadow_memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">info</td><td>Information about the shadow memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>User data passed during iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga751e3c1aba75904b324a3ad41665868f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__umbra__map__options__t.html">_umbra_map_options_t</a>  <a class="el" href="group__umbra.html#ga751e3c1aba75904b324a3ad41665868f">umbra_map_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies parameters controlling the behavior of umbra_create_map(). </p>

</div>
</div>
<a class="anchor" id="gad20b7206ae18024a3a7b1ae23b71f196"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct _umbra_map_t <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opaque "Umbra map handle" type used to refer to a particular Umbra mapping scheme object created by <a class="el" href="group__umbra.html#ga4f0ff18a03e1655eae02473a2e5d496b">umbra_create_mapping()</a>, </p>

</div>
</div>
<a class="anchor" id="ga1b719e93a8011f4976720d37e6657d79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__umbra__shadow__memory__info__t.html">_umbra_shadow_memory_info_t</a>  <a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Information about a shadow memory region. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gadf764cbdea00d65edcd07bb9953ad2b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Priority of Umbra events. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggadf764cbdea00d65edcd07bb9953ad2b7a28b395ded58393f41fcab8be32479122"></a>DRMGR_PRIORITY_EXCPT_UMBRA&#160;</td><td class="fielddoc">
<p>Priority of the Umbra signal/exception handling event. This event must take place before any user of drsyscall in order to allocate shadow memory if necessary. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaaa9d16970f73407af0af6b173afd62b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__umbra.html#gaaa9d16970f73407af0af6b173afd62b6">umbra_map_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Umbra mapping creation flags for fine-grained control </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaaa9d16970f73407af0af6b173afd62b6a16bca8c68c5e970c4457b64606a9671b"></a>UMBRA_MAP_CREATE_SHADOW_ON_TOUCH&#160;</td><td class="fielddoc">
<p>If set, Umbra will try to create the shadow memory on the access to shadow memory that is not yet. When using this option, the user should handle exceptions caused by referencing shadow memory that Umbra fails to handle. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ggaaa9d16970f73407af0af6b173afd62b6ae42e8acda254c7bf3a3b196d070a284d"></a>UMBRA_MAP_SHADOW_SHARED_READONLY&#160;</td><td class="fielddoc">
<p>This is an optimization hint for reducing memory usage by allowing Umbra to map different application memory regions with identical shadow value to the same shared shadow memory block. Attempts to directly write shared shadow memory will cause exceptions that should be handled by the user. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga670274c9cd812c91317125c7179cb15a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__umbra.html#ga670274c9cd812c91317125c7179cb15a">umbra_map_scale_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shadow memory mapping (scaling) schemes supported by Umbra.</p>
<dl class="section note"><dt>Note</dt><dd>: Umbra does not support bit operations, so parameters passed to any Umbra routine will be automatically aligned for proper translation. For example, application memory address <code>app_addr</code> will be aligned to 8 if using UMBRA_MAP_SCALE_DOWN_8X mapping scheme. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga670274c9cd812c91317125c7179cb15aa70662a2ec93fd7702942d5f473ade106"></a>UMBRA_MAP_SCALE_DOWN_4X&#160;</td><td class="fielddoc">
<p>8 app byte to 1 shadow byte </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga670274c9cd812c91317125c7179cb15aa362e915faa295d0503c9815bac7d5a58"></a>UMBRA_MAP_SCALE_DOWN_2X&#160;</td><td class="fielddoc">
<p>4 app byte to 1 shadow byte </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga670274c9cd812c91317125c7179cb15aa30e49a70fa05e2ff43b7c4b436199e29"></a>UMBRA_MAP_SCALE_SAME_1X&#160;</td><td class="fielddoc">
<p>2 app byte to 1 shadow byte </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga670274c9cd812c91317125c7179cb15aa257a8fc2cc1cd3516a317510a47148ca"></a>UMBRA_MAP_SCALE_UP_2X&#160;</td><td class="fielddoc">
<p>1 app byte to 1 shadow byte </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="gaa49d0c1fffdb93fdfd0db1278b1eaad9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__umbra.html#gaa49d0c1fffdb93fdfd0db1278b1eaad9">umbra_shadow_memory_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shadow memory creation flags used in umbra_create_shadow_memory. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ggaa49d0c1fffdb93fdfd0db1278b1eaad9a6fbe76f298c0201ce92a4427a7805687"></a>UMBRA_CREATE_SHADOW_SHARED_READONLY&#160;</td><td class="fielddoc">
<p>This is an optimization hint for reducing memory usage by allowing Umbra to map different application memory regions with identical shadow value to the same shared shadow memory block. Attempts to directly write shared shadow memory will cause exceptions that should be handled by the user. This allows user to control each individual shadow memory creation whether using special shared block or not. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ga218086740fc30ca9ec82ad9e1a8f94d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__umbra.html#ga218086740fc30ca9ec82ad9e1a8f94d0">umbra_shadow_memory_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shadow memory type.</p>
<dl class="section note"><dt>Note</dt><dd>: A shadow memory may have more than one type, e.g., an address in redzone of shared special shadow memory block will return value with both UMBRA_SHADOW_MEMORY_TYPE_SHARED and UMBRA_SHADOW_MEMORY_TYPE_REDZONE being set. </dd></dl>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga218086740fc30ca9ec82ad9e1a8f94d0aef9152f543316d474bf454114e8d57fa"></a>UMBRA_SHADOW_MEMORY_TYPE_UNKNOWN&#160;</td><td class="fielddoc">
<p>Unknown memory type </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga218086740fc30ca9ec82ad9e1a8f94d0a9757d1da5b2a5c95fb57ee2883cdfec1"></a>UMBRA_SHADOW_MEMORY_TYPE_NOT_SHADOW&#160;</td><td class="fielddoc">
<p>Not a shadow memory: i.e., the address being translated is not from a valid application memory region. Umbra does not support storing metadata in shadow memory for such addresses. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga218086740fc30ca9ec82ad9e1a8f94d0a0c8cdfdebf602f0c39c581c229dffe6f"></a>UMBRA_SHADOW_MEMORY_TYPE_NORMAL&#160;</td><td class="fielddoc">
<p>Normal writable shadow memory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga218086740fc30ca9ec82ad9e1a8f94d0a4401ff2d8bd1c4f5e5274b3a251bf413"></a>UMBRA_SHADOW_MEMORY_TYPE_SHARED&#160;</td><td class="fielddoc">
<p>Special read-only shadow memory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga218086740fc30ca9ec82ad9e1a8f94d0a254f60164a8f40da3f6598d5e6015833"></a>UMBRA_SHADOW_MEMORY_TYPE_SHADOW_NOT_ALLOC&#160;</td><td class="fielddoc">
<p>Should be shadow memory, but not allocated yet </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga4f0ff18a03e1655eae02473a2e5d496b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_create_mapping </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#ga751e3c1aba75904b324a3ad41665868f">umbra_map_options_t</a> *&#160;</td>
          <td class="paramname"><em>ops</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> **&#160;</td>
          <td class="paramname"><em>map_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a shadow memory mapping according to the mapping options <code>ops</code>, and return the opaque pointer in <code>map_out</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ops</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">map_out</td><td>The mapping options. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga8a333fbe844ebf9f9b8a12316b1c0b0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_create_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gaa49d0c1fffdb93fdfd0db1278b1eaad9">umbra_shadow_memory_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>app_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ptr_uint_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>value_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create shadow memory for application memory using mapping scheme <code>map</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Shadow memory creation options. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_addr</td><td>Application memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_size</td><td>Application memory size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The initial value in shadow memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_size</td><td>The initial value size, could be 1, 2, 4, or 8 (x64). Only 1 is supported now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. If <code>app_addr</code> is not a valid application address and the shadow mapping implementation does not support shadow memory for invalid addresses, returns DRMF_ERROR_INVALID_ADDRESS.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: If the newly created shadow memory overlaps with the existing shadow memory, the value of overlapped part will be clobbered with new value.</dd>
<dd>
: The actual size of created shadow memory might be larger than the required size, the extended part will be set as default value specified on <code>map</code> creation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64e7e565d3761fbcbd17d3677b607e6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_create_shared_shadow_block </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ptr_uint_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>value_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT byte **&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create special shared shadow memory that Umbra can map different application regions with the same shadow value as <code>value</code> to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value used by the shadow block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_size</td><td>The value size used by the shadow block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>The pointer pointing to the base of the shadow block. Returns NULL if Umbra fails to create one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: Umbra only creates special shared shadow memory if necessary. This routine forces Umbra create one even Umbra may not use it.</dd>
<dd>
: Umbra does not use special shared shadow block in current x64 implementation and always returns DRMF_ERROR_FEATURE_NOT_AVAILABLE. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d62f09ccc7bdf92822428a951efb33a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_delete_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>app_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete shadow memory from mapping scheme <code>map</code> for application memory at <code>app_addr</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_addr</td><td>Application memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_size</td><td>Application memory size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. If <code>app_addr</code> is not a valid application address and the shadow mapping implementation does not support shadow memory for invalid addresses, returns DRMF_ERROR_INVALID_ADDRESS.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: part of the shadow memory might not be actually deleted, which will be set to the value specified on <code>map</code> creation instead. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9ea226aa863c9e9d5feca0d7cc5e719d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_destroy_mapping </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy a shadow memory mapping <code>map</code> created by umbra_create_mapping. </p>

</div>
</div>
<a class="anchor" id="ga8a53bbe9aac961d63d73f5e8942d9826"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up the Umbra extension. </p>

</div>
</div>
<a class="anchor" id="ga6c122a4fbf999b360fad30369848e279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_get_shadow_block_size </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the shadow block size, which is the unit size Umbra allocates/frees the shadow memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>The shadow memory block size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ac818f59d2b343c99d6002301dff2b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_get_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT byte **&#160;</td>
          <td class="paramname"><em>shadow_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT <a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a> *&#160;</td>
          <td class="paramname"><em>shadow_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get shadow memory address for application memory address <code>app_addr</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_addr</td><td>The application memory address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_addr</td><td>The shadow memory address for <code>app_addr</code>. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">shadow_info</td><td>The information about the shadow memory for <code>app_addr</code>.</td></tr>
  </table>
  </dd>
</dl>
<p>For lazily allocated shadow memory, this routine will not allocate shadow memory that is not yet allocated. The caller must explicitly call <a class="el" href="group__umbra.html#ga8a333fbe844ebf9f9b8a12316b1c0b0d">umbra_create_shadow_memory()</a> prior to de-referencing the returned shadow address if the type is UMBRA_SHADOW_MEMORY_TYPE_SHADOW_NOT_ALLOC. Use <a class="el" href="group__umbra.html#ga4c27309e421f1d151fe8e29373c41b71">umbra_read_shadow_memory()</a> or <a class="el" href="group__umbra.html#gaf368cd2ef69d498900fecbeae39781f4">umbra_write_shadow_memory()</a> if automatic allocation is desired.</p>
<dl class="section note"><dt>Note</dt><dd>: <code>shadow_info-&gt;struct_size</code> must be set to <code>sizeof(umbra_shadow_memory_info_t)</code> for compatiblity.</dd>
<dd>
: <code>shadow_info</code> contains the information about the shadow memory block and its application memory, so the caller can cache the information and access the shadow memory later without querying Umbra again. However, if the shadow memory is a special shared memory block, it may be replaced with normal shadow memory and the caller will not see it, and the caller will see the old special value if using cached information. It is up to the caller to decide whether this is acceptable.</dd>
<dd>
: No redzone will be included in the <code>shadow_info</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga720d39f0f8f8c8fa23a8d100acf2b414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_get_shadow_memory_type </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN byte *&#160;</td>
          <td class="paramname"><em>shadow_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group__umbra.html#ga218086740fc30ca9ec82ad9e1a8f94d0">umbra_shadow_memory_type_t</a> *&#160;</td>
          <td class="paramname"><em>shadow_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get shadow memory type for address <code>shadow_addr</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shadow_addr</td><td>The shadow memory address for <code>app_addr</code>. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_type</td><td>The type of the shadow memory at <code>shadow_addr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: this routine has high runtime overhead since it may need iterate all shadow memory to determine the shadow memory type for <code>shadow_addr</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="ga3f47b3624ff3705ae9622335f8ecbf7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_get_shared_shadow_block </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ptr_uint_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>value_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT byte **&#160;</td>
          <td class="paramname"><em>block</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get special shared shadow memory created by umbra_create_shared_shadow_block or Umbra with identical <code>value</code> and <code>value_size</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value used by the shadow block. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_size</td><td>The value size used by the shadow block. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">block</td><td>The pointer pointing to the base of the shadow block. Returns NULL if Umbra fails to find one.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: Umbra does not use special shared shadow block in current x64 implementation and always returns DRMF_ERROR_FEATURE_NOT_AVAILABLE. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf7bd0146652ec43ce742f1bbe040c459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_init </td>
          <td>(</td>
          <td class="paramtype">client_id_t&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the Umbra extension. Must be called prior to any of the other routines. Can be called multiple times (by separate components, normally) but each call must be paired with a corresponding call to <a class="el" href="group__umbra.html#ga8a53bbe9aac961d63d73f5e8942d9826">umbra_exit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">client_id</td><td>The client id for version check.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa4371a006da20f17c0621ee4dd2f0cc4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_insert_app_to_shadow </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN instr_t *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN reg_id_t&#160;</td>
          <td class="paramname"><em>addr_reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN reg_id_t *&#160;</td>
          <td class="paramname"><em>scratch_regs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN int&#160;</td>
          <td class="paramname"><em>num_scratch_regs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert instructions into <code>ilist</code> before <code>where</code> to translate application address stored in <code>reg_addr</code> to shadow address and store it into <code>reg_addr</code>.</p>
<p>Umbra may use page faults to implement lazy shadow memory allocation. When generating meta instructions to read shadow values, be sure to assign translation values to the instructions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">drcontext</td><td>The DynamoRIO context for current thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ilist</td><td>The instruction list to be inserted into. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">where</td><td>The instruction to be inserted before </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr_reg</td><td>The Register holding the application address for translation, and holding the shadow memory address after translation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">scratch_regs</td><td>The array of scratch registers for use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_scratch_regs</td><td>Number of scratch register</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: <code>num_scratch_regs</code> must not be smaller than the value returned from umbra_num_scratch_regs_for_translation, otherwise error code DRMF_ERROR_NOT_ENOUGH_REGS is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="gaa1163803823fd29ba89a5d0272670b89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_iterate_app_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN bool(*)(<a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *map,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   const dr_mem_info_t *info,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   void *user_data)&#160;</td>
          <td class="paramname"><em>iter_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate the application memory (i.e., any memory that are not part of shadow memory, DynamoRIO internal memory, or DynamoRIO's client memory).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>The user data passed to <code>iter_func</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_func</td><td>The iterate callback function. It can return false to stop the iteration.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: the memory allocated by dr_raw_mem_alloc by client might be iterated since they are not considered as part of DynamoRIO internal or client memory. </dd></dl>

</div>
</div>
<a class="anchor" id="gada2c4b1e3f332078ae5c3c58c6ce7e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_iterate_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#ga2aa58774b9ee9f296b953695c9db57d5">shadow_iterate_func_t</a>&#160;</td>
          <td class="paramname"><em>iter_func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate shadow memory and call <code>iter_func</code> on each shadow memory block.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">user_data</td><td>The user data passed to <code>iter_func</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">iter_func</td><td>The iterate callback function. It can return false to stop the iteration. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga7c80f899839083562bd14355c4b2810d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_num_scratch_regs_for_translation </td>
          <td>(</td>
          <td class="paramtype">OUT int *&#160;</td>
          <td class="paramname"><em>num_regs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the number of scratch registers needed (excluding the register holding the application address) for address translation from application memory to shadow memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num_regs</td><td>Number of scratch register required for translation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4c27309e421f1d151fe8e29373c41b71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_read_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>app_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT size_t *&#160;</td>
          <td class="paramname"><em>shadow_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT byte *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read shadow memory for application memory at <code>app_addr</code> to <code>buffer</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_addr</td><td>Application memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_size</td><td>Application memory size. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">shadow_size</td><td>The max buffer size. Return the number of bytes actually read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The buffer holds the read value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. If <code>app_addr</code> is not a valid application address and the shadow mapping implementation does not support shadow memory for invalid addresses, returns DRMF_ERROR_INVALID_ADDRESS. </dd></dl>

</div>
</div>
<a class="anchor" id="gad03e483ea5b7d2047efc879f5c2b68d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_replace_shared_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT byte **&#160;</td>
          <td class="paramname"><em>shadow_addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replace the special shared shadow memory for application address <code>app_addr</code> with normal writable shadow memory. Do nothing if it is already uses normal writable shadow memory or not allocated yet.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_addr</td><td>The application memory address to be replaced. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_addr</td><td>Return the replaced shadow memory address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga4622bfe2480822fd1212f3a3c61a94c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_shadow_copy_range </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>app_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT size_t *&#160;</td>
          <td class="paramname"><em>shadow_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy value from shadow memory for application memory at <code>app_src</code> to shadow memory for application memory at <code>app_dst</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_src</td><td>Source application memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_dst</td><td>Destination application memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_size</td><td>Application memory size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_size</td><td>The number of bytes actually copied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. If <code>app_addr</code> is not a valid application address and the shadow mapping implementation does not support shadow memory for invalid addresses, returns DRMF_ERROR_INVALID_ADDRESS.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>: Overlap is allowed. </dd></dl>

</div>
</div>
<a class="anchor" id="ga16080e1e17da8b608c5736f45644e713"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void umbra_shadow_memory_info_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__umbra.html#ga1b719e93a8011f4976720d37e6657d79">umbra_shadow_memory_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience routine for initializing umbra_shadow_memory_info. </p>

</div>
</div>
<a class="anchor" id="ga372042a059dbdc71a4b045da3ff48cbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_shadow_memory_is_shared </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN byte *&#160;</td>
          <td class="paramname"><em>shadow_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="group__umbra.html#ga218086740fc30ca9ec82ad9e1a8f94d0">umbra_shadow_memory_type_t</a> *&#160;</td>
          <td class="paramname"><em>shadow_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to umbra_get_shadow_memory_type, but only check if <code>shadow_addr</code> is in a special shared shadow memory block. <code>shadow_type</code> is set to be UMBRA_SHADOW_MEMORY_TYPE_SHARED (optionally with UMBRA_SHADOW_MEMORY_TYPE_REDZONE also set) if <code>shadow_addr</code> is in any special shared shadow memory block and UMBRA_SHADOW_MEMORY_TYPE_UNKNOWN otherwise. If <code>shadow_addr</code> is in the redzone of a special shared shadow memory block, UMBRA_SHADOW_MEMORY_TYPE_REDZONE is also set along with UMBRA_SHADOW_MEMORY_TYPE_SHARED.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">shadow_addr</td><td>The shadow memory address. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_type</td><td>The type of the shadow memory at <code>shadow_addr</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: This is a routine for efficient check if <code>shadow_addr</code> is in a special shared shadow memory. UMBRA_SHADOW_MEMORY_TYPE_UNKNOWN is set even <code>shadow_addr</code> could be normal writable shadow memory. </dd></dl>

</div>
</div>
<a class="anchor" id="gaafb51fb89b014b9bbf0dbe44c2d47b2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_shadow_set_range </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>app_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT size_t *&#160;</td>
          <td class="paramname"><em>shadow_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ptr_uint_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>value_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a range of shadow memory for application memory at <code>app_addr</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_addr</td><td>Application memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_size</td><td>Application memory size. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">shadow_size</td><td>The number of bytes actually written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set in shadow memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_size</td><td>The value size for <code>value</code>, could be 1, 2, 4, or 8 (x64). Only 1 is supported now.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. If <code>app_addr</code> is not a valid application address and the shadow mapping implementation does not support shadow memory for invalid addresses, returns DRMF_ERROR_INVALID_ADDRESS. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7a58ed96cd19b0aaa6415670aad9acc1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_value_in_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT app_pc *&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>app_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN ptr_uint_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>value_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>found</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether <code>value</code> is in the shadow memory for application memory at <code>app_addr</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">app_addr</td><td>Starting application memory address. Return the application address at which if found. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_size</td><td>Application memory size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The value to be set in shadow memory. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value_size</td><td>The value size for <code>value</code>, could be 1, 2, 4, or 8 (x64). Only 1 is supported now. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">found</td><td>Return true if <code>value</code> found in the range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. If <code>app_addr</code> is not a valid application address and the shadow mapping implementation does not support shadow memory for invalid addresses, returns DRMF_ERROR_INVALID_ADDRESS. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf368cd2ef69d498900fecbeae39781f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> umbra_write_shadow_memory </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="group__umbra.html#gad20b7206ae18024a3a7b1ae23b71f196">umbra_map_t</a> *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN app_pc&#160;</td>
          <td class="paramname"><em>app_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>app_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT size_t *&#160;</td>
          <td class="paramname"><em>shadow_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN byte *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write shadow memory for application memory at <code>app_addr</code> from <code>buffer</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_addr</td><td>Application memory address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">app_size</td><td>Application memory size. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">shadow_size</td><td>The max buffer size. Return the number of bytes actually written. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>The buffer holds the value to write.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>success code. If <code>app_addr</code> is not a valid application address and the shadow mapping implementation does not support shadow memory for invalid addresses, returns DRMF_ERROR_INVALID_ADDRESS. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  Dr. Memory version 1.11.1 --- Fri Feb 3 2017 00:38:44 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>

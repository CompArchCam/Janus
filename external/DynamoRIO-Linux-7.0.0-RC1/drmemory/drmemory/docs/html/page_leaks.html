<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Dr. Memory: Memory Leaks</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dr. Memory
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_leaks.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Memory Leaks </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Dr. Memory divides all memory that is still allocated at the time it does its leak scan into 3 categories:</p>
<ol type="1">
<li>Memory that is still reachable by the application. This is NOT considered a leak. It is reported as "still-reachable allocation(s)" in Dr. Memory's summary. Many applications do not explicitly free memory whose lifetime matches the process lifetime and this is not considered an error by Dr. Memory.</li>
<li>Memory that is definitely not reachable by the application (at least, not by an aligned pointer to the start or middle of the allocated block). This is called a "leak" by Dr. Memory, as there is no way for the application to free this memory: it has lost any handle it had to the memory.</li>
<li>Memory that is reachable only via pointers to the middle of the allocation, rather than the head. This is called a "possible leak" by Dr. Memory. These may or may not be legimitate pointers to that allocation. There are several cases of known legitimate pointers that Dr. Memory recognizes using heuristics. None of these are listed as possible leaks unless the corresponding option is turned off:<ul>
<li>One class of legitimate mid-allocation pointers includes C++ arrays allocated via new[] whose elements have destructors. The new[] operators adds a header but returns to the caller the address past the header. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_new_ok</code> runtime option.</li>
<li>Another class, for some C++ compilers, includes instances of a pointer to a class with multiple inheritance that is cast to one of the parents: it can end up pointing to the subobject representation in the middle of the allocation. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_inheritance_ok</code> runtime option.</li>
<li>The std::string class places a <code>char</code>[] array in the middle of an allocation and points directly at it. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_string_ok</code> runtime option.</li>
<li>A final example is a custom malloc wrapper that uses a header and passes a pointer offset into the result from malloc. The free wrapper subtracts from the passed-in pointer in order to compute the pointer to the head of the allocated block. You can suppress Dr. Memory's identification of such mid-allocation pointers, causing them to show up as possible leaks, with the <code>-no_midchunk_size_ok</code> runtime option.</li>
</ul>
</li>
</ol>
<p>The two categories of leaks ("leaks" and "possible leaks") are further broken down into direct and indirect leaks. An indirect leak is a heap object that is reachable by a pointer to its start address, but with all such pointers originating in leaked objects. Leaks can be thought of as trees, with the top-level object the direct leaks and all child objects indirect leaks. Dr. Memory reports the size of all the child indirect leaks for each direct leak, but does not report a detailed callstack for indirect leaks. If the direct leak is addressed, the indirect leaks should no longer be leaked, making their details unnecessary.</p>
<p>By default, Dr. Memory performs leak checking at application exit, or when a mid-run check is requested via <code>-nudge</code> (see <a class="el" href="page_running.html#sec_daemon">Applications That Do Not Exit</a>). Nudges can be used to help determine when the last pointer to an allocation was lost, if the callstack of the allocation is not sufficient to pinpoint the error in the source code. Each nudge will perform a full leak scan and by nudging periodically the first instance of a particular leak can be used to identify when the leak occurred.</p>
<p>On Windows, when HeapDestroy is called, any live allocations inside are reported as possible leaks. This can be disabled, since some applications may consider it correct behavior, with the <code>-no_check_leaks_on_destroy</code> option.</p>
<p>Dr. Memory reports the number of leaks, possible leaks, and still-reachable allocations. The callstack for the allocation of each leak and possible leak is gathered by default and listed with other errors in the results file. To also see all of the reachable allocations, use the <code>-show_reachable</code> runtime option. Reachable allocations are labeled as <code>REACHABLE LEAK</code>. By default, without the <code>-show_reachable</code> option, reachable leak callstacks are not compared to suppressions, in order to reduce overhead.</p>
<p>Here are example lines from Dr. Memory's output summary:</p>
<div class="fragment"><div class="line">~~Dr.M~~ ERRORS FOUND:</div>
<div class="line">~~Dr.M~~       5 unique,     5 total,    574 byte(s) of leak(s)</div>
<div class="line">~~Dr.M~~       0 unique,     0 total,      0 byte(s) of possible leak(s)</div>
<div class="line">~~Dr.M~~ ERRORS IGNORED:</div>
<div class="line">~~Dr.M~~       5 unique,     8 total,    205 byte(s) of still-reachable allocation(s)</div>
<div class="line">~~Dr.M~~          (re-run with &quot;-show_reachable&quot; for details)</div>
</div><!-- fragment --><p>And with <code>-show_reachable</code>, where the callstack for each still-reachable allocation will be in <code>results.txt:</code> </p>
<div class="fragment"><div class="line">~~Dr.M~~ ERRORS FOUND:</div>
<div class="line">~~Dr.M~~       5 unique,     5 total,    574 byte(s) of leak(s)</div>
<div class="line">~~Dr.M~~       0 unique,     0 total,      0 byte(s) of possible leak(s)</div>
<div class="line">~~Dr.M~~       5 unique,     8 total,    205 byte(s) of still-reachable allocation(s)</div>
<div class="line">~~Dr.M~~ NO ERRORS IGNORED</div>
</div><!-- fragment --><p>There are known sources of false positives where a memory allocation may actually be reachable by the application, but Dr. Memory's algorithm will determine that it is unreachable. These cases include:</p>
<ul>
<li>The only stored pointers to an allocation are not aligned to 4 bytes.</li>
<li>The only stored pointers to an allocation are encrypted.</li>
<li>There is some custom mechanism to reach these allocations that does not involve a direct stored pointer into any part of the allocated block.</li>
</ul>
<p>One known problem comes from using glib's memory allocator. To avoid false positives when using glib, set the following environment variables when running your application:</p>
<ul>
<li>G_SLICE=always-malloc</li>
<li>G_DEBUG=gc-friendly </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  Dr. Memory version 1.11.1 --- Fri Feb 3 2017 00:38:43 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>

<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Dr. Memory: Dr. Fuzz: DynamoRIO Fuzz Testing Extension</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dr. Memory
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__drfuzz.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Dr. Fuzz: DynamoRIO Fuzz Testing Extension</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drfuzz__target__frame__t.html">_drfuzz_target_frame_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drfuzz__fault__t.html">_drfuzz_fault_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drfuzz__fault__thread__state__t.html">_drfuzz_fault_thread_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__drfuzz__crash__state__t.html">_drfuzz_crash_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaf1047c11f80f39b514e825d073b0afe7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drfuzz__target__frame__t.html">_drfuzz_target_frame_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaf1047c11f80f39b514e825d073b0afe7">drfuzz_target_frame_t</a></td></tr>
<tr class="separator:gaf1047c11f80f39b514e825d073b0afe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fe388574a6077167066734b7290badc"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a></td></tr>
<tr class="separator:ga9fe388574a6077167066734b7290badc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0476bfbac4fec4ed186313cafc466f1"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drfuzz__fault__t.html">_drfuzz_fault_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a></td></tr>
<tr class="separator:gaa0476bfbac4fec4ed186313cafc466f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f95b432c34811d65b6b2a805d4e20e6"><td class="memItemLeft" align="right" valign="top">typedef dr_siginfo_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga0f95b432c34811d65b6b2a805d4e20e6">drfuzz_fault_ex_t</a></td></tr>
<tr class="separator:ga0f95b432c34811d65b6b2a805d4e20e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2113ea5ffef0aeaa27193d142fc48cbd"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drfuzz__fault__thread__state__t.html">_drfuzz_fault_thread_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a></td></tr>
<tr class="separator:ga2113ea5ffef0aeaa27193d142fc48cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0274f6e9338e5aea625cf2857721704a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__drfuzz__crash__state__t.html">_drfuzz_crash_state_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga0274f6e9338e5aea625cf2857721704a">drfuzz_crash_state_t</a></td></tr>
<tr class="separator:ga0274f6e9338e5aea625cf2857721704a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga41cc49b856c46e33e6853e126b0710ea"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga41cc49b856c46e33e6853e126b0710ea">drfuzz_init</a> (client_id_t client_id)</td></tr>
<tr class="separator:ga41cc49b856c46e33e6853e126b0710ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae057afb25c1a5242068d6271d80da4a6"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gae057afb25c1a5242068d6271d80da4a6">drfuzz_exit</a> (void)</td></tr>
<tr class="separator:gae057afb25c1a5242068d6271d80da4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaba9d8646ace276597b988631b51b66f9"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaba9d8646ace276597b988631b51b66f9">drfuzz_fuzz_target</a> (generic_func_t func_pc, uint arg_count, uint flags, uint wrap_flags, void(*pre_fuzz_cb)(void *fuzzcxt, generic_func_t target_pc,                                                                                                                                                   dr_mcontext_t *mc), bool(*post_fuzz_cb)(void *fuzzcxt, generic_func_t target_pc))</td></tr>
<tr class="separator:gaba9d8646ace276597b988631b51b66f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga632a9201983d14b905f600218fdb6a09"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga632a9201983d14b905f600218fdb6a09">drfuzz_unfuzz_target</a> (generic_func_t func_pc)</td></tr>
<tr class="separator:ga632a9201983d14b905f600218fdb6a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee2b26046cb760d4c82ceaca1d873e37"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaee2b26046cb760d4c82ceaca1d873e37">drfuzz_register_fault_event</a> (void(*event)(void *fuzzcxt,                                                                                                                                                               <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault,                                                                                                                                                               <a class="el" href="group__drfuzz.html#ga0f95b432c34811d65b6b2a805d4e20e6">drfuzz_fault_ex_t</a> *fault_ex))</td></tr>
<tr class="separator:gaee2b26046cb760d4c82ceaca1d873e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0eb1fad63357f3689015628bf42c1f07"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga0eb1fad63357f3689015628bf42c1f07">drfuzz_unregister_fault_event</a> (void(*event)(void *fuzzcxt,                                                                                                                                                               <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault,                                                                                                                                                               <a class="el" href="group__drfuzz.html#ga0f95b432c34811d65b6b2a805d4e20e6">drfuzz_fault_ex_t</a> *fault_ex))</td></tr>
<tr class="separator:ga0eb1fad63357f3689015628bf42c1f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacafe5cd4d2be5918aa611785f5baf81b"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gacafe5cd4d2be5918aa611785f5baf81b">drfuzz_register_fault_delete_callback</a> (void(*callback)(void *fuzzcxt,                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault))</td></tr>
<tr class="separator:gacafe5cd4d2be5918aa611785f5baf81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa23c9360545c9d70df4c7f80d41dae19"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaa23c9360545c9d70df4c7f80d41dae19">drfuzz_unregister_fault_delete_callback</a> (void(*callback)(void *fuzzcxt,                                                                                                                                                                                                                           <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault))</td></tr>
<tr class="separator:gaa23c9360545c9d70df4c7f80d41dae19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga997dd1482c6afa7d61182fc364f3e1f6"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga997dd1482c6afa7d61182fc364f3e1f6">drfuzz_register_crash_thread_event</a> (void(*event)(void *fuzzcxt,                                                                                                                                                                                           <a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a> *state))</td></tr>
<tr class="separator:ga997dd1482c6afa7d61182fc364f3e1f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac524feabc609f5813c0b3a410942bf4"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaac524feabc609f5813c0b3a410942bf4">drfuzz_unregister_crash_thread_event</a> (void(*event)(void *fuzzcxt,                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a> *state))</td></tr>
<tr class="separator:gaac524feabc609f5813c0b3a410942bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae82beadee259f775b35eb71673d73bb"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaae82beadee259f775b35eb71673d73bb">drfuzz_get_fuzzcxt</a> (void)</td></tr>
<tr class="separator:gaae82beadee259f775b35eb71673d73bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329bb6e29a5ad93a31189b36ee3098a8"><td class="memItemLeft" align="right" valign="top">DR_EXPORT void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga329bb6e29a5ad93a31189b36ee3098a8">drfuzz_get_drcontext</a> (void *fuzzcxt)</td></tr>
<tr class="separator:ga329bb6e29a5ad93a31189b36ee3098a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga965dae4098be367ce241ea3754449026"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga965dae4098be367ce241ea3754449026">drfuzz_get_target_num_bbs</a> (IN generic_func_t target_pc, OUT uint64 *num_bbs)</td></tr>
<tr class="separator:ga965dae4098be367ce241ea3754449026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24633b4ec72389b8bbacc7562e7987f9"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga24633b4ec72389b8bbacc7562e7987f9">drfuzz_get_arg</a> (void *fuzzcxt, generic_func_t target_pc, int arg, bool original, OUT void **arg_value)</td></tr>
<tr class="separator:ga24633b4ec72389b8bbacc7562e7987f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45dbb490eacc9260aa05610aaa844c2a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga45dbb490eacc9260aa05610aaa844c2a">drfuzz_set_arg</a> (void *fuzzcxt, int arg, void *val)</td></tr>
<tr class="separator:ga45dbb490eacc9260aa05610aaa844c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0444d2aad4b9beb1ca2431f8560ce458"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga0444d2aad4b9beb1ca2431f8560ce458">drfuzz_get_target_user_data</a> (IN generic_func_t target_pc, OUT void **user_data)</td></tr>
<tr class="separator:ga0444d2aad4b9beb1ca2431f8560ce458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4ef680b6434e7abdd9dd12c12b17a7a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gad4ef680b6434e7abdd9dd12c12b17a7a">drfuzz_set_target_user_data</a> (IN generic_func_t target_pc, IN void *user_data, IN void(*delete_callback)(void *user_data))</td></tr>
<tr class="separator:gad4ef680b6434e7abdd9dd12c12b17a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92400c0162d6ad94cb02fa20b6726fcd"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga92400c0162d6ad94cb02fa20b6726fcd">drfuzz_get_target_per_thread_user_data</a> (IN void *fuzzcxt, IN generic_func_t target_pc, OUT void **user_data)</td></tr>
<tr class="separator:ga92400c0162d6ad94cb02fa20b6726fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f85a60ca57bee3d28d89f2bb4560905"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga6f85a60ca57bee3d28d89f2bb4560905">drfuzz_set_target_per_thread_user_data</a> (IN void *fuzzcxt, IN generic_func_t target_pc, IN void *user_data, IN void(*delete_callback)(void *fuzzcxt,                                                                                                                                                                                                                                                               void *user_data))</td></tr>
<tr class="separator:ga6f85a60ca57bee3d28d89f2bb4560905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf85da43dc564ec140513954cbb42529c"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaf85da43dc564ec140513954cbb42529c">drfuzz_target_iterator_start</a> (void *fuzzcxt)</td></tr>
<tr class="separator:gaf85da43dc564ec140513954cbb42529c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9340c1870e4611e8baa8f24530f5556"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drfuzz.html#gaf1047c11f80f39b514e825d073b0afe7">drfuzz_target_frame_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gae9340c1870e4611e8baa8f24530f5556">drfuzz_target_iterator_next</a> (<a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a> *iter)</td></tr>
<tr class="separator:gae9340c1870e4611e8baa8f24530f5556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga274c7ea3009a8837a522f54acefc2814"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga274c7ea3009a8837a522f54acefc2814">drfuzz_target_iterator_stop</a> (<a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a> *iter)</td></tr>
<tr class="separator:ga274c7ea3009a8837a522f54acefc2814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa94feabf22c32d68a16b566e29bc38eb"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaa94feabf22c32d68a16b566e29bc38eb">_drfuzz_mutator_api_t::drfuzz_mutator_start</a> (OUT drfuzz_mutator_t **mutator, IN void *input_seed, IN size_t size, IN int argc, IN const char *argv[])</td></tr>
<tr class="separator:gaa94feabf22c32d68a16b566e29bc38eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cae8b5268f1a98b70626092e45b1bce"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT bool LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga8cae8b5268f1a98b70626092e45b1bce">_drfuzz_mutator_api_t::drfuzz_mutator_has_next_value</a> (drfuzz_mutator_t *mutator)</td></tr>
<tr class="separator:ga8cae8b5268f1a98b70626092e45b1bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5ce617a36f6f934a5331b43144476b3"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaf5ce617a36f6f934a5331b43144476b3">_drfuzz_mutator_api_t::drfuzz_mutator_get_current_value</a> (IN drfuzz_mutator_t *mutator, OUT void *buffer)</td></tr>
<tr class="separator:gaf5ce617a36f6f934a5331b43144476b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga624abd256ce1dc6f2337ab026d477074"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga624abd256ce1dc6f2337ab026d477074">_drfuzz_mutator_api_t::drfuzz_mutator_get_next_value</a> (drfuzz_mutator_t *mutator, OUT void *buffer)</td></tr>
<tr class="separator:ga624abd256ce1dc6f2337ab026d477074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc43246d9a2b419ed77c0df492b25904"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gacc43246d9a2b419ed77c0df492b25904">_drfuzz_mutator_api_t::drfuzz_mutator_stop</a> (drfuzz_mutator_t *mutator)</td></tr>
<tr class="separator:gacc43246d9a2b419ed77c0df492b25904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d20f7d357db70a1376d269da41b91dc"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga6d20f7d357db70a1376d269da41b91dc">_drfuzz_mutator_api_t::drfuzz_mutator_feedback</a> (drfuzz_mutator_t *mutator, int feedback)</td></tr>
<tr class="separator:ga6d20f7d357db70a1376d269da41b91dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c44fcf24303095bba3b823d0554bf5e"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga5c44fcf24303095bba3b823d0554bf5e">drfuzz_mutator_load</a> (IN const char *lib_path, INOUT drfuzz_mutator_api_t *api)</td></tr>
<tr class="separator:ga5c44fcf24303095bba3b823d0554bf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga582b63b243ed739b7f8a7a2fb3234b6a"><td class="memItemLeft" align="right" valign="top">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga582b63b243ed739b7f8a7a2fb3234b6a">drfuzz_mutator_unload</a> (IN drfuzz_mutator_api_t *lib)</td></tr>
<tr class="separator:ga582b63b243ed739b7f8a7a2fb3234b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf41be888e69ea42ba4571e7693d3ac0e"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaf41be888e69ea42ba4571e7693d3ac0e">drfuzz_mutator_start</a> (OUT drfuzz_mutator_t **mutator, IN void *input_seed, IN size_t size, IN int argc, IN const char *argv[])</td></tr>
<tr class="separator:gaf41be888e69ea42ba4571e7693d3ac0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf9f6297b2fdac546526b134f267c5bb8"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT bool LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gaf9f6297b2fdac546526b134f267c5bb8">drfuzz_mutator_has_next_value</a> (drfuzz_mutator_t *mutator)</td></tr>
<tr class="separator:gaf9f6297b2fdac546526b134f267c5bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07598ca7995c00e8ad161e13c6dfeb0c"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga07598ca7995c00e8ad161e13c6dfeb0c">drfuzz_mutator_get_current_value</a> (IN drfuzz_mutator_t *mutator, OUT void *buffer)</td></tr>
<tr class="separator:ga07598ca7995c00e8ad161e13c6dfeb0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd7fea3c737dfe947a1bdc36f2020f64"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#gabd7fea3c737dfe947a1bdc36f2020f64">drfuzz_mutator_get_next_value</a> (drfuzz_mutator_t *mutator, OUT void *buffer)</td></tr>
<tr class="separator:gabd7fea3c737dfe947a1bdc36f2020f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ba1cec3e7b1a1f7873933b93a5adb8d"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga0ba1cec3e7b1a1f7873933b93a5adb8d">drfuzz_mutator_stop</a> (drfuzz_mutator_t *mutator)</td></tr>
<tr class="separator:ga0ba1cec3e7b1a1f7873933b93a5adb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ea9c74f3478668cd07d8b1c044bf0ef"><td class="memItemLeft" align="right" valign="top">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC()&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__drfuzz.html#ga0ea9c74f3478668cd07d8b1c044bf0ef">drfuzz_mutator_feedback</a> (drfuzz_mutator_t *mutator, int feedback)</td></tr>
<tr class="separator:ga0ea9c74f3478668cd07d8b1c044bf0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga0274f6e9338e5aea625cf2857721704a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drfuzz__crash__state__t.html">_drfuzz_crash_state_t</a>  <a class="el" href="group__drfuzz.html#ga0274f6e9338e5aea625cf2857721704a">drfuzz_crash_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the state of all application threads at the time of a crash. </p>

</div>
</div>
<a class="anchor" id="ga0f95b432c34811d65b6b2a805d4e20e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef dr_siginfo_t <a class="el" href="group__drfuzz.html#ga0f95b432c34811d65b6b2a805d4e20e6">drfuzz_fault_ex_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides extended information about a critical fault. On Unix cast to dr_siginfo_t, or on Windows cast to dr_exception_t. See documentation on those structs for details.</p>
<p>Where provided by callbacks from this API, instances of this struct are temporary and may not be accessed after the callback function returns. Copy the struct as necessary. </p>

</div>
</div>
<a class="anchor" id="gaa0476bfbac4fec4ed186313cafc466f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drfuzz__fault__t.html">_drfuzz_fault_t</a>  <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides basic information about an occurrence of a "critical fault", which in drfuzz refers to a subset of signals (Unix) or exceptions (Windows) that (a) are likely to be caused by fuzz testing, (b) imply errors and/or vulnerabilities in the code of the target application, and (c) terminate execution if they are not caught and handled. By default, the set of "critical faults" is SIGSEGV and SIGBUS on Unix, and Access Violation on Windows. (In a future release, the "critical faults" will be configurable by the drfuzz client.) Also see comments on <a class="el" href="group__drfuzz.html#gaee2b26046cb760d4c82ceaca1d873e37">drfuzz_register_fault_event()</a>.</p>
<p>Where provided by callbacks from this API, this struct may be retained indefinitely. Additional information about a critical fault is provided by <a class="el" href="group__drfuzz.html#ga0f95b432c34811d65b6b2a805d4e20e6">drfuzz_fault_ex_t</a>, which duplicates some data from this struct, but may not be retained after a callback. </p>

</div>
</div>
<a class="anchor" id="ga2113ea5ffef0aeaa27193d142fc48cbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drfuzz__fault__thread__state__t.html">_drfuzz_fault_thread_state_t</a>  <a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the state of a thread at the time a fault occurred on that thread, or at the time the thread is aborted due to application crash. Faults recorded in the state at the time of a crash are not necessarily responsible for the crash.</p>
<dl class="section note"><dt>Note</dt><dd>Currently only the first and last faults will be provided in the <code>faults</code> array. </dd></dl>

</div>
</div>
<a class="anchor" id="gaf1047c11f80f39b514e825d073b0afe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__drfuzz__target__frame__t.html">_drfuzz_target_frame_t</a>  <a class="el" href="group__drfuzz.html#gaf1047c11f80f39b514e825d073b0afe7">drfuzz_target_frame_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents the stack frame of a fuzz target during one fuzz iteration, including the argument values from that iteration. To access the target frames for any thread, call <a class="el" href="group__drfuzz.html#gaf85da43dc564ec140513954cbb42529c">drfuzz_target_iterator_start()</a> from that thread. When a crash occurs, the set of target frames that were live at the time of the critical fault are copied into a <a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a>, which is provided in the crash events.</p>
<dl class="section note"><dt>Note</dt><dd>For pointer arguments, the pointed value may change, or may no longer be accessible, after the stack frame returns (or aborts on crash). Clients requiring post-mortem access to such pointed values will need to store them at the beginning of each fuzz iteration. </dd></dl>

</div>
</div>
<a class="anchor" id="ga9fe388574a6077167066734b7290badc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An opaque iterator of fuzz targets, representing the set of targets that were live on the call stack of one thread at a specific point in time. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gae057afb25c1a5242068d6271d80da4a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up all resources used by the Dr. Fuzz extension. </p>

</div>
</div>
<a class="anchor" id="gaba9d8646ace276597b988631b51b66f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_fuzz_target </td>
          <td>(</td>
          <td class="paramtype">generic_func_t&#160;</td>
          <td class="paramname"><em>func_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>arg_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>wrap_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *fuzzcxt, generic_func_t target_pc,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   dr_mcontext_t *mc)&#160;</td>
          <td class="paramname"><em>pre_fuzz_cb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *fuzzcxt, generic_func_t target_pc)&#160;</td>
          <td class="paramname"><em>post_fuzz_cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register the function that starts at address <code>func_pc</code> for repeated fuzz testing. The <code>pre_func</code> and <code>post_func</code> callbacks will control the fuzz testing cycle. The client may arbitrarily change arguments to the target function during the <code>pre_func</code> callback, and fuzz testing of the target will continue for as long as the <code>post_func</code> callback returns true.</p>
<p>Fuzzing requests should normally be made up front during process initialization or module load (see dr_register_module_load_event()). If a fuzzing request is made after the target code may have already been executed by the application, the caller should flush the target code from the cache using the desired flush method after issuing the fuzzing request. Multiple fuzzing requests for the same <code>func_pc</code> are not allowed.</p>
<p>The <code>pre_func</code> will be called at the beginning of the target function on each iteration, before any of its code executes. The <code>pre_func</code> may examine the arguments using <a class="el" href="group__drfuzz.html#ga24633b4ec72389b8bbacc7562e7987f9">drfuzz_get_arg()</a> and modify them using <a class="el" href="group__drfuzz.html#ga45dbb490eacc9260aa05610aaa844c2a">drfuzz_set_arg()</a>. Before each invocation of the <code>pre_func</code>, drfuzz will reset the arguments to the original values that were passed by the application (by shallow copy). Argument values may only be changed during a <code>pre_func</code> callback.</p>
<p>The <code>post_func</code> will be called after the target function returns on each iteration, but before any subsequent instructions following the call site have been executed. Returning true will cause drfuzz to redirect execution back to the start of the target function, adjusting the call stack and resetting the argument values accordingly (see drwrap_redirect_execution() for details). Argument accessors <a class="el" href="group__drfuzz.html#ga24633b4ec72389b8bbacc7562e7987f9">drfuzz_get_arg()</a> and <a class="el" href="group__drfuzz.html#ga45dbb490eacc9260aa05610aaa844c2a">drfuzz_set_arg()</a> are not available in this phase of the fuzzing cycle, though drfuzz_get_target_arg() can be used at any time during fuzzing.</p>
<p>The fuzzer implements repeated execution of the target function using the drwrap extension, which accepts a flags argument for each wrapped target function. Use the <code>wrap_flags</code> parameter to pass flags through to the internal drwrap_wrap_ex() call. The calling convention specified in the <code>wrap_flags</code> must be correct or the target function will have incorrect arguments and/or a corrupt stack during fuzz testing.</p>
<dl class="section note"><dt>Note</dt><dd>Recursive invocation of the fuzz target is currently not supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_pc</td><td>The start pc of the new fuzz target function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg_count</td><td>The actual number of arguments passed to the fuzz target function during fuzz testing (i.e., for vararg targets, the client must know how many args are actually used). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Reserved for future use; must be set to 0. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wrap_flags</td><td>Flags for the delegated call to wrap the fuzz target function for repeated execution; see drwrap_wrap_ex(). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pre_fuzz_cb</td><td>Called prior to each fuzz iteration of the target function (must not be NULL). Any changes made by the callee to the application registers must be applied to the mcontext provided (or they will not take effect). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">post_fuzz_cb</td><td>Called following each fuzz iteration of the target function (must not be NULL). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga24633b4ec72389b8bbacc7562e7987f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_get_arg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fuzzcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">generic_func_t&#160;</td>
          <td class="paramname"><em>target_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>original</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>arg_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the value of an argument to the fuzz target function at <code>target_pc</code>. May only be called while fuzzing of this target is in progress. Will retrieve the arg value for the current fuzz iteration on the current thread. Returns DRMF_SUCCESS on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fuzzcxt</td><td>The drfuzz thread context. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">target_pc</td><td>The target function. May be NULL, which implies that the target is the most recently called target on the app call stack. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>Identifies the argument by its index. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">original</td><td>Specifies whether to get the original value of the argument passed by the app, or the currently applied fuzz value. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">arg_value</td><td>Returns the value of the argument (when successful). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga329bb6e29a5ad93a31189b36ee3098a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drfuzz_get_drcontext </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fuzzcxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the dcontext associated with this fuzzcxt. </p>

</div>
</div>
<a class="anchor" id="gaae82beadee259f775b35eb71673d73bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT void* drfuzz_get_fuzzcxt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the drfuzz thread context for the current thread. This function has significant overhead, and should not be used repetitively in performance-sensitive applications. </p>

</div>
</div>
<a class="anchor" id="ga965dae4098be367ce241ea3754449026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_get_target_num_bbs </td>
          <td>(</td>
          <td class="paramtype">IN generic_func_t&#160;</td>
          <td class="paramname"><em>target_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint64 *&#160;</td>
          <td class="paramname"><em>num_bbs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total number of basic blocks seen during <code>target_pc</code> fuzzing, i.e., from the first execution of the target function at <code>target_pc</code> to the last exit from that function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">target_pc</td><td>The target function. If <code>target_pc</code> is NULL, the total number of basic blocks seen during execution is returned. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">num_bbs</td><td>Returns the number of basic blocks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>: The number of basic blocks returned might not be the precise number of new blocks that are a direct result of the target function's execution. For example, a basic block might be counted multiple times due to code cache management; basic blocks executed by other threads are not be counted; basic blocks executed in the inner fuzzing function are not counted for the outer fuzzing function in the case of nested fuzzing. </dd></dl>

</div>
</div>
<a class="anchor" id="ga92400c0162d6ad94cb02fa20b6726fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_get_target_per_thread_user_data </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>fuzzcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN generic_func_t&#160;</td>
          <td class="paramname"><em>target_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the user data associated with the specified <code>target_pc</code> and <code>fuzzcxt</code>. If the <code>fuzzcxt</code> is NULL, the fuzzcxt for the current thread will be used (if any). </p>

</div>
</div>
<a class="anchor" id="ga0444d2aad4b9beb1ca2431f8560ce458"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_get_target_user_data </td>
          <td>(</td>
          <td class="paramtype">IN generic_func_t&#160;</td>
          <td class="paramname"><em>target_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void **&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the user data associated with the <code>target_pc</code>. </p>

</div>
</div>
<a class="anchor" id="ga41cc49b856c46e33e6853e126b0710ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_init </td>
          <td>(</td>
          <td class="paramtype">client_id_t&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the Dr. Fuzz extension. This function must be called before any other Dr. Fuzz API functions. Can be called any number of times, but each call must be paired with a corresponding call to <a class="el" href="group__drfuzz.html#gae057afb25c1a5242068d6271d80da4a6">drfuzz_exit()</a>. </p>

</div>
</div>
<a class="anchor" id="ga0ea9c74f3478668cd07d8b1c044bf0ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() drfuzz_mutator_feedback </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>feedback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides feedback to the mutator about the effect of the last mutation. The meaning of <code>feedback</code> can be specified by custom mutators. If the meaning of <code>feedback</code> is not specified, 0 means neutral, and the greater the value of <code>feedback</code> is, the more effective the last mutation is.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called to enable feedback guided mutation. For example, in Dr. Memory fuzz testing mode, the option -fuzz_coverage must be specified for any custom mutator that supports feedback guided mutation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga6d20f7d357db70a1376d269da41b91dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() _drfuzz_mutator_api_t::drfuzz_mutator_feedback </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>feedback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides feedback to the mutator about the effect of the last mutation. The meaning of <code>feedback</code> can be specified by custom mutators. If the meaning of <code>feedback</code> is not specified, 0 means neutral, and the greater the value of <code>feedback</code> is, the more effective the last mutation is.</p>
<dl class="section note"><dt>Note</dt><dd>This function must be called to enable feedback guided mutation. For example, in Dr. Memory fuzz testing mode, the option -fuzz_coverage must be specified for any custom mutator that supports feedback guided mutation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga07598ca7995c00e8ad161e13c6dfeb0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() drfuzz_mutator_get_current_value </td>
          <td>(</td>
          <td class="paramtype">IN drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a copy of the current mutator value. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="gaf5ce617a36f6f934a5331b43144476b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() _drfuzz_mutator_api_t::drfuzz_mutator_get_current_value </td>
          <td>(</td>
          <td class="paramtype">IN drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a copy of the current mutator value. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="gabd7fea3c737dfe947a1bdc36f2020f64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() drfuzz_mutator_get_next_value </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the next fuzz value to the provided buffer. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="ga624abd256ce1dc6f2337ab026d477074"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() _drfuzz_mutator_api_t::drfuzz_mutator_get_next_value </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT void *&#160;</td>
          <td class="paramname"><em>buffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes the next fuzz value to the provided buffer. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="gaf9f6297b2fdac546526b134f267c5bb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT bool LIBFUNC() drfuzz_mutator_has_next_value </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the mutator can generate the next value. Generally this is only relevant for mutators using a sequential algorithm. </p>

</div>
</div>
<a class="anchor" id="ga8cae8b5268f1a98b70626092e45b1bce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT bool LIBFUNC() _drfuzz_mutator_api_t::drfuzz_mutator_has_next_value </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the mutator can generate the next value. Generally this is only relevant for mutators using a sequential algorithm. </p>

</div>
</div>
<a class="anchor" id="ga5c44fcf24303095bba3b823d0554bf5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_mutator_load </td>
          <td>(</td>
          <td class="paramtype">IN const char *&#160;</td>
          <td class="paramname"><em>lib_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT drfuzz_mutator_api_t *&#160;</td>
          <td class="paramname"><em>api</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads a mutator. If <code>lib_path</code> is NULL, the default mutator built in to <code>Dr</code>. Fuzz is loaded. Otherwise, the custom, third-party mutator library located at the file path <code>lib_path</code> is loaded. The mutator interface for the loaded mutator is returned in <code>api</code>. The caller must set <code>api-&gt;struct_size</code> before calling. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="gaf41be888e69ea42ba4571e7693d3ac0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() drfuzz_mutator_start </td>
          <td>(</td>
          <td class="paramtype">OUT drfuzz_mutator_t **&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>input_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN const char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiate mutation on a buffer. Returns DRMF_SUCCESS on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mutator</td><td>Return argument for the newly initiated mutator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_seed</td><td>Pointer to the seed instance of the buffer to mutate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of arguments to customize the mutator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of <code>argc</code> arguments to customize the mutator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaa94feabf22c32d68a16b566e29bc38eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() _drfuzz_mutator_api_t::drfuzz_mutator_start </td>
          <td>(</td>
          <td class="paramtype">OUT drfuzz_mutator_t **&#160;</td>
          <td class="paramname"><em>mutator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>input_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN const char *&#160;</td>
          <td class="paramname"><em>argv</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiate mutation on a buffer. Returns DRMF_SUCCESS on success.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">mutator</td><td>Return argument for the newly initiated mutator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">input_seed</td><td>Pointer to the seed instance of the buffer to mutate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The number of bytes in the buffer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argc</td><td>The number of arguments to customize the mutator. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argv</td><td>An array of <code>argc</code> arguments to customize the mutator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga0ba1cec3e7b1a1f7873933b93a5adb8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() drfuzz_mutator_stop </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up resources allocated for the mutator. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="gacc43246d9a2b419ed77c0df492b25904"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LIB_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> LIBFUNC() _drfuzz_mutator_api_t::drfuzz_mutator_stop </td>
          <td>(</td>
          <td class="paramtype">drfuzz_mutator_t *&#160;</td>
          <td class="paramname"><em>mutator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up resources allocated for the mutator. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="ga582b63b243ed739b7f8a7a2fb3234b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_mutator_unload </td>
          <td>(</td>
          <td class="paramtype">IN drfuzz_mutator_api_t *&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unloads a custom mutator library. Returns DRMF_SUCCESS on success. </p>

</div>
</div>
<a class="anchor" id="ga997dd1482c6afa7d61182fc364f3e1f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_register_crash_thread_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *fuzzcxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a> *state)&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register to be notified of an application crash on each thread that is running at the time of the crash. The event contains the state of the current thread at the time of the fault. If the crash was not caused by this thread, the state may contain faults that would have been handled by the app (had it continued to run).</p>
<p>The state also contains a list of fuzz targets. If the state contains faults, these targets represent the state of fuzzing at the time the first fault occurred. Otherwise these targets were live at the time the thread was aborted by the crash.</p>
<p>Access the targets using the provided iterator, but do not stop the iterator (<a class="el" href="group__drfuzz.html#ga274c7ea3009a8837a522f54acefc2814">drfuzz_target_iterator_stop()</a> will be called internally).</p>
<dl class="section note"><dt>Note</dt><dd>Does not allow multiple registration. </dd></dl>

</div>
</div>
<a class="anchor" id="gacafe5cd4d2be5918aa611785f5baf81b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_register_fault_delete_callback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *fuzzcxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register to be notified when drfuzz deletes a fault object, indicating it is no longer safe to retain it. If user_data has been attached, it should be disposed at this time.</p>
<dl class="section note"><dt>Note</dt><dd>Does not allow multiple registration. </dd></dl>

</div>
</div>
<a class="anchor" id="gaee2b26046cb760d4c82ceaca1d873e37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_register_fault_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *fuzzcxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#ga0f95b432c34811d65b6b2a805d4e20e6">drfuzz_fault_ex_t</a> *fault_ex)&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register for notification of a fault event, which occurs when the execution of any fuzz target encounters a critical fault (as defined at <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a>). Since the app may handle the fault, drfuzz does not report it to the user at the time this event occurs. Instead, it maintains a chain of faults that occur during a single fuzz iteration, and only reports them if the application crashes before starting the next fuzz iteration. Use <a class="el" href="group__drfuzz.html#ga997dd1482c6afa7d61182fc364f3e1f6">drfuzz_register_crash_thread_event()</a> to receive crash notification.</p>
<p><b>Event parameters</b> </p><table  border="0">
<tr>
<td valign="top"><code>&#160;&#160;&#160;&#160;[in]</code> </td><td valign="top"><b>fuzzcxt&#160;</b> </td><td valign="top">The drfuzz thread-local context of the fault.  </td></tr>
<tr>
<td valign="top"><code>&#160;&#160;&#160;&#160;[in]</code> </td><td valign="top"><b>fault&#160;</b> </td><td valign="top">Provides basic information about the kind and location of the fault, and may be retained by the callee until delete (to be notified, use <a class="el" href="group__drfuzz.html#gacafe5cd4d2be5918aa611785f5baf81b">drfuzz_register_fault_delete_callback()</a>). The field user_data is available for attaching custom data to the fault for later use during the crash events (if any) via <a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a> and <a class="el" href="group__drfuzz.html#ga0274f6e9338e5aea625cf2857721704a">drfuzz_crash_state_t</a>.   </td></tr>
<tr>
<td valign="top"><code>&#160;&#160;&#160;&#160;[in]</code> </td><td valign="top"><b>fault_ex&#160;</b> </td><td valign="top">Provides extended information about the memory state at the fault. This struct is transitory and must be copied if any of its data needs to be retained.   </td></tr>
</table>
<dl class="section note"><dt>Note</dt><dd>Does not allow multiple registration. </dd></dl>

</div>
</div>
<a class="anchor" id="ga45dbb490eacc9260aa05610aaa844c2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_set_arg </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fuzzcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the value of an argument to the target function. May only be called from a pre-fuzz callback. Returns DRMF_SUCCESS on success.</p>
<p>This routine may de-reference application memory directly, so the caller should wrap it in DR_TRY_EXCEPT if crashes must be avoided. </p>

</div>
</div>
<a class="anchor" id="ga6f85a60ca57bee3d28d89f2bb4560905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_set_target_per_thread_user_data </td>
          <td>(</td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>fuzzcxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN generic_func_t&#160;</td>
          <td class="paramname"><em>target_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void(*)(void *fuzzcxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   void *user_data)&#160;</td>
          <td class="paramname"><em>delete_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user data associated with the specified <code>target_pc</code> and <code>fuzzcxt</code>. If the <code>fuzzcxt</code> is NULL, the fuzzcxt for the current thread will be used (if any). If the <code>delete_callback</code> is not NULL, it will be called when drfuzz deletes the internal target data structure (after completing a fuzz pass), or when the thread exits.</p>
<dl class="section note"><dt>Note</dt><dd>: Only one slot is provided for the data, so multiple writes will overwrite. </dd></dl>

</div>
</div>
<a class="anchor" id="gad4ef680b6434e7abdd9dd12c12b17a7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_set_target_user_data </td>
          <td>(</td>
          <td class="paramtype">IN generic_func_t&#160;</td>
          <td class="paramname"><em>target_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void *&#160;</td>
          <td class="paramname"><em>user_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN void(*)(void *user_data)&#160;</td>
          <td class="paramname"><em>delete_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the user data associated with the specified <code>target_pc</code>. If the <code>delete_callback</code> is not NULL, it will be called when drfuzz deletes the internal target data structure.</p>
<dl class="section note"><dt>Note</dt><dd>: Only one slot is provided for the data, so multiple writes will overwrite. </dd></dl>

</div>
</div>
<a class="anchor" id="gae9340c1870e4611e8baa8f24530f5556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drfuzz.html#gaf1047c11f80f39b514e825d073b0afe7">drfuzz_target_frame_t</a>* drfuzz_target_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next fuzz target frame in the iteration set, or NULL after the last frame. </p>

</div>
</div>
<a class="anchor" id="gaf85da43dc564ec140513954cbb42529c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a>* drfuzz_target_iterator_start </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fuzzcxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates an iterator over the set of fuzz targets that are live on the current thread's call stack. Use <a class="el" href="group__drfuzz.html#gae9340c1870e4611e8baa8f24530f5556">drfuzz_target_iterator_next()</a> to traverse the fuzz target frames, and use <a class="el" href="group__drfuzz.html#ga274c7ea3009a8837a522f54acefc2814">drfuzz_target_iterator_stop()</a> to free the iterator and all frames. </p>

</div>
</div>
<a class="anchor" id="ga274c7ea3009a8837a522f54acefc2814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_target_iterator_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__drfuzz.html#ga9fe388574a6077167066734b7290badc">drfuzz_target_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a fuzz target iterator and free its allocated resources (including target frames). </p>

</div>
</div>
<a class="anchor" id="ga632a9201983d14b905f600218fdb6a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_unfuzz_target </td>
          <td>(</td>
          <td class="paramtype">generic_func_t&#160;</td>
          <td class="paramname"><em>func_pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister the fuzz target at func_pc from drfuzz. Future executions of the target function will not be repeated in the fuzz testing loop. Should not be called while the target function is executing (application may behave incorrectly or crash). </p>

</div>
</div>
<a class="anchor" id="gaac524feabc609f5813c0b3a410942bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_unregister_crash_thread_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *fuzzcxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#ga2113ea5ffef0aeaa27193d142fc48cbd">drfuzz_fault_thread_state_t</a> *state)&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister the crash notification callback. </p>

</div>
</div>
<a class="anchor" id="gaa23c9360545c9d70df4c7f80d41dae19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_unregister_fault_delete_callback </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *fuzzcxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault)&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister the fault delete notification callback. </p>

</div>
</div>
<a class="anchor" id="ga0eb1fad63357f3689015628bf42c1f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DR_EXPORT <a class="el" href="group__drmf.html#gafcc3ee43c88eeb409c25459be608619b">drmf_status_t</a> drfuzz_unregister_fault_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *fuzzcxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#gaa0476bfbac4fec4ed186313cafc466f1">drfuzz_fault_t</a> *fault,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="group__drfuzz.html#ga0f95b432c34811d65b6b2a805d4e20e6">drfuzz_fault_ex_t</a> *fault_ex)&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister the fault notification event. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  Dr. Memory version 1.11.1 --- Fri Feb 3 2017 00:38:44 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>

<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>Dr. Memory: Dr. Fuzz: Dynamic Fuzz Testing Extension</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Dr. Memory
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('page_drfuzz.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Dr. Fuzz: Dynamic Fuzz Testing Extension </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The Dr. Fuzz DynamoRIO Extension provides fuzz testing features. Dr. Fuzz is part of the Dr. Memory Framework. Dr. Fuzz is used to implement the Dr. Memory <a class="el" href="page_fuzzer.html">Fuzz Testing Mode</a>.</p>
<ul>
<li><a class="el" href="page_drfuzz.html#sec_drfuzz_setup">Setup</a></li>
<li><a class="el" href="page_drfuzz.html#sec_drfuzz_API">Dr. Fuzz API</a></li>
<li><a class="el" href="page_drfuzz.html#sec_drfuzz_mutators">Dr. Fuzz Mutators</a> Mutators</li>
</ul>
<h1><a class="anchor" id="sec_drfuzz_setup"></a>
Setup</h1>
<p>To use <code>Dr</code>. Fuzz with your client, first locate the Dr. Memory Framework. Then use the standard method of using an Extension with the name <code>drfuzz</code>. The two steps will look like this in your client's <code>CMakeLists.txt</code> file:</p>
<div class="fragment"><div class="line">find_package(DrMemoryFramework)</div>
<div class="line">use_DynamoRIO_extension(clientname drfuzz)</div>
</div><!-- fragment --><p>To point CMake at the framework, set the DrMemoryFramework_DIR variable to point at the <code>drmf</code> subdirectory of the Dr. Memory package that you are using. For example:</p>
<div class="fragment"><div class="line">cmake -G<span class="stringliteral">&quot;Ninja&quot;</span> -DDynamoRIO_DIR=c:/path/to/DynamoRIO-Windows-4.1.0-8/cmake -DDrMemoryFramework_DIR=c:/path/to/DrMemory-Windows-1.6.0-2/drmf ../mysrcs/</div>
</div><!-- fragment --><p>That will automatically set up the include path and library dependence.</p>
<p>Your client must call <code><a class="el" href="group__drfuzz.html#ga41cc49b856c46e33e6853e126b0710ea">drfuzz_init()</a></code> prior to accessing any API routines in <code>drfuzz</code>, and should call <code><a class="el" href="group__drfuzz.html#gae057afb25c1a5242068d6271d80da4a6">drfuzz_exit()</a></code> at process exit time.</p>
<h1><a class="anchor" id="sec_drfuzz_API"></a>
Dr. Fuzz API</h1>
<p><code>Dr</code>. Fuzz provides the following key features:</p><ol type="1">
<li>Repeat execution of the test target function with fuzzed arguments.</li>
<li>Mutate argument values using bit flipping, random number algorithms, or custom user-provided mutators.</li>
<li>Schedule fuzz iterations for a target function and set of arguments.</li>
<li>Report state information on a crash caused by fuzz inputs.</li>
</ol>
<p>The client can use the provided Dr. Fuzz APIs to fuzz test the target application. The most flexible approach is to use Dr. Fuzz directly to control the fuzzing cycle using registered callbacks. This approach also requires the most effort, so users who wish to get going quickly may prefer to use Dr. Memory's fuzzing features, which leverage Dr. Fuzz.</p>
<h1><a class="anchor" id="sec_drfuzz_mutators"></a>
Dr. Fuzz Mutators</h1>
<p>To support custom mutators, mutation is performed by a libary separate from the main <code>Dr</code>. Fuzz control library. <code>Dr</code>. Fuzz provides a default mutator library which contains several different mutator implementations.</p>
<h2><a class="anchor" id="sec_drfuzz_mut_ops"></a>
Default Mutator Options</h2>
<p>The default mutator built-in to <code>Dr</code>. Fuzz supports several mutation variations, controlled by the following options (which are passed to <a class="el" href="group__drfuzz.html#gaf41be888e69ea42ba4571e7693d3ac0e">drfuzz_mutator_start()</a>):</p>
<ul>
<li>-alg &lt;algorithm_name&gt;<br />
 Specifies the algorithm for generating a new value. The choices are:<ul>
<li>"random": Randomly search the domain of possible permutations. This is the default for -unit token.</li>
<li>"ordered": Exhaustively search all possible permutations in an ordered manner. This is the default for -unit bits and -unit num.</li>
</ul>
</li>
<li>-unit &lt;unit_name&gt;<br />
 Specifies the unit of transformation for applying the mutation algorithm. The choices are:<ul>
<li>"bits": Bitwise application of the mutation algorithm. This is the default.</li>
<li>"num": Numeric application of the mutation algorithm.</li>
<li>"token": Insertion of tokens from a dictionary. The dictionary must be specified via -dictionary.</li>
</ul>
</li>
<li>-flags &lt;int&gt;<br />
 Flags for the mutator. Some flags are specific to a particular algorithm and/or mutation unit. The choices are:<ul>
<li>0x1: Reset the buffer contents to the input_seed after every bit-flip mutation. Not valid for -unit num. On by default.</li>
<li>0x2: Seed the mutator's random number generator with the current clock time.</li>
</ul>
</li>
<li>-sparsity &lt;int&gt;<br />
 The degree of sparseness in the random coverage of the "random" algorithm with unit "bits" (invalid for other configurations). Sparsity of n will yield on average 1/n total values relative to the "ordered" algorithm in the same configuration. If the sparsity is set to 0, the default value of 1 will be used instead.</li>
<li>-max_value &lt;uint64&gt;<br />
 For buffers of size 8 bytes or smaller, specifies the maximum mutation value. Use value 0 to disable the maximum value (i.e., limit only by the buffer capacity).</li>
<li>-random_seed &lt;uint64&gt;<br />
 Set the randomization seed for algorithm "random". The default random seed is 0x5a8390e9a31dc65fULL, which was selected to have an equal number of 0 and 1 bits.</li>
<li>-dictionary &lt;path&gt;<br />
 Specifies a dictionary file containing tokens for -unit token. The file format is compatible with AFL (<a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>). It is a text file with one token, in double quotes, per line, with an optional preceding name followed by an equals sign. Non-printable characters must use \x hex escapes, and double quotes and backslashes must be escaped by a preceding backslash. Comment lines starting with '#' can be included. An example: <div class="fragment"><div class="line"><span class="stringliteral">&quot;token42&quot;</span></div>
<div class="line"><span class="stringliteral">&quot;different_token&quot;</span></div>
<div class="line">unprint=<span class="stringliteral">&quot;\xCD\xEF&quot;</span></div>
<div class="line">mytokA=<span class="stringliteral">&quot;internal\&quot;quotes\&quot;&quot;</span></div>
</div><!-- fragment --></li>
</ul>
<p>The default options are for ordered, seed-centric bit-flipping.</p>
<p>The algorithms are further described below.</p>
<h2><a class="anchor" id="sec_mutator_alg_and_unit"></a>
Mutator Algorithms and Units</h2>
<p>The default mutator provides two algorithms for mutating the fuzzed argument, ordered and random, and each algorithm can operate in terms of bit-flips or integers. The latter option is referred to as the "unit" of mutation. The behavior of these two mutator options can be easily seen in the following example, where the app's original argument value is all zero (at left), and each successive value reflects one mutation: </p><pre class="fragment">Ordered bit-flip: 0x00000000 =&gt; 0x00000001 =&gt; 0x00000100 =&gt; 0x00010000 =&gt; 0x01000000
Random bit-flip:  0x00000000 =&gt; 0x00200000 =&gt; 0x00008000 =&gt; 0x00000004 =&gt; 0x00002000
Ordered numeric:  0x00000000 =&gt; 0x00000001 =&gt; 0x00000002 =&gt; 0x00000003 =&gt; 0x00000004
Random numeric:   0x00000000 =&gt; 0x7abcbb5e =&gt; 0xc6f15f41 =&gt; 0xaebd59a2 =&gt; 0xc375f0ae
</pre><p>Notice that the bit-flip unit does not flip bits in a lexical sequence, even when the ordered algorithm is selected. Instead, it distributes the flips across the bytes first, and secondarily across the bits of each byte. The goal is to improve mutator coverage for very large input buffers, especially when the sparsity option is used (see below). The following sequence illustrates how ordered bit-flip distributes all permutations of a single flip across a 2-byte buffer: </p><pre class="fragment">0x0000 =&gt; 0x0001 =&gt; 0x0100 =&gt; 0x0002 =&gt; 0x0200 =&gt; 0x0004 =&gt; 0x0400 =&gt; 0x0008 =&gt; 0x0800
       =&gt; 0x0010 =&gt; 0x1000 =&gt; 0x0020 =&gt; 0x0200 =&gt; 0x0040 =&gt; 0x4000 =&gt; 0x0080 =&gt; 0x8000
</pre><p>After completing all flips of a single bit, the mutator will proceed to flip two bits: </p><pre class="fragment">0x0000 =&gt; 0x0101 =&gt; 0x0003 =&gt; 0x0201 =&gt; 0x0005 =&gt; 0x0401 =&gt; 0x0009 =&gt; 0x0801 =&gt; 0x0011
       =&gt; 0x1001 =&gt; 0x0021 =&gt; 0x2001 =&gt; 0x0041 =&gt; 0x4001 =&gt; 0x0081 =&gt; 0x8001 =&gt; 0x0006
</pre><h2><a class="anchor" id="sec_mutator_rand_gen"></a>
Mutator Random Number Generator</h2>
<p>The mutator uses a stateless xorshift algorithm for all of its randomized decisions (see xorshift64star on <a href="https://en.wikipedia.org/wiki/Xorshift">https://en.wikipedia.org/wiki/Xorshift</a>). For randomized bit-flip, the mutator selects which bits to flip using the Fisher-Yates shuffle (<a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle</a>).</p>
<p>To repeat a fuzz test using the exact same sequence of values for the fuzz target function, specify the same random seed as the original fuzz test using the mutator descriptor's optional last field; for example: </p><pre class="fragment">-fuzz_mutator "r|b|r|1|0x17a3cd8648a6ab1f"
</pre><p>To avoid repeating the exact same fuzz test when using the random algorithm, and pass flag <code>'t'</code> in the mutator descriptor (field 3 in option <code>-fuzz_mutator</code>) to seed the random algorithm with the system clock time. The seed will be reported in the log and in the console output (when enabled) for future reference, e.g., to repeat that fuzz test.</p>
<h2><a class="anchor" id="sec_mutator_proximity"></a>
Mutator "Proximity" via Reset Option</h2>
<p>Although the fuzzer executes the target function as rapidly as possible on the given hardware (by redirecting execution directly from the function return back into the function entry point), the number of possible values for the fuzzed argument usually makes it impossible to try all permutations. In many scenarios, the most interesting app functionality can be reached using argument values that are very similar to a "correct" or "typical" input value. For this reason, the fuzzer takes the original argument value passed by the application as a starting point for mutation. To explore input values that are most similar to the app's original input value, use flag <code>'r'</code> in the mutator descriptor (field 3 in option <code>-fuzz_mutator</code>) to reset the argument to the app's original value before each mutation. Omitting this flag will cause the successive mutations to accumulate. For example, a bit-flipping mutator using the reset option might generate the following sequence on a 4-byte buffer, where the first value is the app's original argument value, and each successive value reflects one mutation (marked with overstrike): </p><pre class="fragment">                      __          __          __          __
0x01020304 =&gt; 0x01020305 =&gt; 0x01020204 =&gt; 0x01030304 =&gt; 0x00020304
</pre><p>But the same mutator without the reset option would generate this sequence: </p><pre class="fragment">                      __          ____        ______      ________
0x01020304 =&gt; 0x01020305 =&gt; 0x01020205 =&gt; 0x01030205 =&gt; 0x00030205
</pre><p>As you can see, the mutated value remains very similar to the original input when using the reset option, but quickly diverges without it.</p>
<h2><a class="anchor" id="sec_mutator_sparsity"></a>
Mutator Sparsity</h2>
<p>For many target functions, the reset option generates inputs that are too similar, causing the majority of inputs to be redundant&ndash;yet completely random input may also be ineffective. To generate a moderately diverse range of input values, the sparsity can be specified in the mutator descriptor (field 4 in option <code>-fuzz_mutator</code>). The term "sparsity" refers to the coverage of the space of possible input values, where a sparsity of 1 indicates to first cover all values reachable by a single bit-flip of the app's original argument value, then cover all values reachable by 2 bit-flips, and so on. By increasing the sparsity, the mutator will reduce the number of permutations it generates at each degree of bit flipping. The following table provides an example of sparsity one, given a 4-byte input buffer: </p><pre class="fragment">Bit-Flip Degree   Total Mutator Values
              1                     32
              2                    992
              3                  29760
</pre><p>By increasing the sparsity to just 4, the number of mutator values at each degree of bit flipping is greatly reduced: </p><pre class="fragment">Bit-Flip Degree   Total Mutator Values
              1                      8
              2                    248
              3                   7440
</pre><p>This second approach balances the diversity of input values with the proximity of each generated input to the app's original argument value. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  Dr. Memory version 1.11.1 --- Fri Feb 3 2017 00:38:44 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>

<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: dr_ir_instr.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dr__ir__instr_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_ir_instr.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions to create and manipulate instructions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:add002513aebf166b7fdae13d22828d8d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add002513aebf166b7fdae13d22828d8d">EFLAGS_READ_CF</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:add002513aebf166b7fdae13d22828d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa533378650b8a86c903410a8abe5789"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afa533378650b8a86c903410a8abe5789">EFLAGS_READ_PF</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:afa533378650b8a86c903410a8abe5789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c54ddcc858950e361725de7bc870d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a43c54ddcc858950e361725de7bc870d6">EFLAGS_READ_AF</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:a43c54ddcc858950e361725de7bc870d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8385b4d8340260aad30cf5b8455a4efd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8385b4d8340260aad30cf5b8455a4efd">EFLAGS_READ_ZF</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="separator:a8385b4d8340260aad30cf5b8455a4efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e0eb52c091f04e29148ca5e7ae2199"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae9e0eb52c091f04e29148ca5e7ae2199">EFLAGS_READ_SF</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:ae9e0eb52c091f04e29148ca5e7ae2199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf7d3cf0c4e6b2f39c3a07533419837"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aebf7d3cf0c4e6b2f39c3a07533419837">EFLAGS_READ_TF</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:aebf7d3cf0c4e6b2f39c3a07533419837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a57b4b5098e1ff53bb8a990eec54a14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5a57b4b5098e1ff53bb8a990eec54a14">EFLAGS_READ_IF</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="separator:a5a57b4b5098e1ff53bb8a990eec54a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241f4fe5f01af11fe8e9489fcf84ab4a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a241f4fe5f01af11fe8e9489fcf84ab4a">EFLAGS_READ_DF</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="separator:a241f4fe5f01af11fe8e9489fcf84ab4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b5f953da018e1530879109cb78095b0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5b5f953da018e1530879109cb78095b0">EFLAGS_READ_OF</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="separator:a5b5f953da018e1530879109cb78095b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70baddbcff9ed31c328376956f7b0ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab70baddbcff9ed31c328376956f7b0ea">EFLAGS_READ_NT</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="separator:ab70baddbcff9ed31c328376956f7b0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e4b47d88d4014fedaed25482d39b34"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a14e4b47d88d4014fedaed25482d39b34">EFLAGS_READ_RF</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="separator:a14e4b47d88d4014fedaed25482d39b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafb04c014284b3c4b51b0c6d17be085"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afafb04c014284b3c4b51b0c6d17be085">EFLAGS_WRITE_CF</a>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="separator:afafb04c014284b3c4b51b0c6d17be085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302bd46f54cf696a1039c5d25f68bd02"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a302bd46f54cf696a1039c5d25f68bd02">EFLAGS_WRITE_PF</a>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="separator:a302bd46f54cf696a1039c5d25f68bd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e0d29af655c408ddc915cc07c8ac95e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9e0d29af655c408ddc915cc07c8ac95e">EFLAGS_WRITE_AF</a>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="separator:a9e0d29af655c408ddc915cc07c8ac95e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5329db528d9d749deae463b9b8edd736"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5329db528d9d749deae463b9b8edd736">EFLAGS_WRITE_ZF</a>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="separator:a5329db528d9d749deae463b9b8edd736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5ddab727f9e2c9d49f20bcfd07807b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6b5ddab727f9e2c9d49f20bcfd07807b">EFLAGS_WRITE_SF</a>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="separator:a6b5ddab727f9e2c9d49f20bcfd07807b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1ee8f92225d554aba043211c34e18b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aac1ee8f92225d554aba043211c34e18b">EFLAGS_WRITE_TF</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="separator:aac1ee8f92225d554aba043211c34e18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61834da87126c5c1b3b5b89a1bb254e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab61834da87126c5c1b3b5b89a1bb254e">EFLAGS_WRITE_IF</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="separator:ab61834da87126c5c1b3b5b89a1bb254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb180e5ea86b98e6bbd65708e202e6f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#abb180e5ea86b98e6bbd65708e202e6f1">EFLAGS_WRITE_DF</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="separator:abb180e5ea86b98e6bbd65708e202e6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8edc641bb696aceadb34b6d5179761"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3d8edc641bb696aceadb34b6d5179761">EFLAGS_WRITE_OF</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="separator:a3d8edc641bb696aceadb34b6d5179761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a533d9a5cd836be7bd8f831256b9d407e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a533d9a5cd836be7bd8f831256b9d407e">EFLAGS_WRITE_NT</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="separator:a533d9a5cd836be7bd8f831256b9d407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad8fd64cd98ac35c20265b54de97cf2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1ad8fd64cd98ac35c20265b54de97cf2">EFLAGS_WRITE_RF</a>&#160;&#160;&#160;0x00200000</td></tr>
<tr class="separator:a1ad8fd64cd98ac35c20265b54de97cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d4ed7d7b9c544c09c395872a86c0ea"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a88d4ed7d7b9c544c09c395872a86c0ea">EFLAGS_READ_ALL</a>&#160;&#160;&#160;0x000007ff</td></tr>
<tr class="separator:a88d4ed7d7b9c544c09c395872a86c0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b847fef029d2aef4ae9f7c79dae0d3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a38b847fef029d2aef4ae9f7c79dae0d3">EFLAGS_READ_NON_PRED</a>&#160;&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a88d4ed7d7b9c544c09c395872a86c0ea">EFLAGS_READ_ALL</a></td></tr>
<tr class="separator:a38b847fef029d2aef4ae9f7c79dae0d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5727b7a5773bace9d656e4b969d7fce"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab5727b7a5773bace9d656e4b969d7fce">EFLAGS_WRITE_ALL</a>&#160;&#160;&#160;0x003ff800</td></tr>
<tr class="separator:ab5727b7a5773bace9d656e4b969d7fce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad61b67b227ebe0012829621c25ca65f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad61b67b227ebe0012829621c25ca65f5">EFLAGS_READ_6</a>&#160;&#160;&#160;0x0000011f</td></tr>
<tr class="separator:ad61b67b227ebe0012829621c25ca65f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8287fcf9cd6cd2338a57c54e45b08a7f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8287fcf9cd6cd2338a57c54e45b08a7f">EFLAGS_WRITE_6</a>&#160;&#160;&#160;0x0008f800</td></tr>
<tr class="separator:a8287fcf9cd6cd2338a57c54e45b08a7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa28e6c817ab3ae8128d862a46b2f037b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa28e6c817ab3ae8128d862a46b2f037b">EFLAGS_READ_ARITH</a>&#160;&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ad61b67b227ebe0012829621c25ca65f5">EFLAGS_READ_6</a></td></tr>
<tr class="separator:aa28e6c817ab3ae8128d862a46b2f037b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d3e15ebbf2667f9a2df713b6cbe5ca"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a15d3e15ebbf2667f9a2df713b6cbe5ca">EFLAGS_WRITE_ARITH</a>&#160;&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a8287fcf9cd6cd2338a57c54e45b08a7f">EFLAGS_WRITE_6</a></td></tr>
<tr class="separator:a15d3e15ebbf2667f9a2df713b6cbe5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1cca9ca8d0514a42f66c081f478231"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2f1cca9ca8d0514a42f66c081f478231">EFLAGS_WRITE_TO_READ</a>(x)&#160;&#160;&#160;((x) &gt;&gt; 11)</td></tr>
<tr class="separator:a2f1cca9ca8d0514a42f66c081f478231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe5d20458bd272fdeac681706c4bd14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afbe5d20458bd272fdeac681706c4bd14">EFLAGS_READ_TO_WRITE</a>(x)&#160;&#160;&#160;((x) &lt;&lt; 11)</td></tr>
<tr class="separator:afbe5d20458bd272fdeac681706c4bd14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a697ecea613b828838ff6f08b88adf1d2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a697ecea613b828838ff6f08b88adf1d2">PREFIX_LOCK</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:a697ecea613b828838ff6f08b88adf1d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e6a144b4030140faa950fe65fe9002d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a0e6a144b4030140faa950fe65fe9002d">PREFIX_JCC_NOT_TAKEN</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a0e6a144b4030140faa950fe65fe9002d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327356db32ce7a884e9a516b2d91b738"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a327356db32ce7a884e9a516b2d91b738">PREFIX_JCC_TAKEN</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:a327356db32ce7a884e9a516b2d91b738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c11ed8105a5cecf5345ab5262a784f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac3c11ed8105a5cecf5345ab5262a784f">PREFIX_XACQUIRE</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:ac3c11ed8105a5cecf5345ab5262a784f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba06eaa86f6bbe22f58a1e2ddffb33da"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aba06eaa86f6bbe22f58a1e2ddffb33da">PREFIX_XRELEASE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:aba06eaa86f6bbe22f58a1e2ddffb33da"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a27cda70ebaed7e6872a63c7316917d70"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71">_dr_pred_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a></td></tr>
<tr class="separator:a27cda70ebaed7e6872a63c7316917d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29c184442681322a7a77ab2a48ba889"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a></td></tr>
<tr class="separator:af29c184442681322a7a77ab2a48ba889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02e5d9677a934f4c981d58d435d4b65"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cd">_dr_opnd_query_flags_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a></td></tr>
<tr class="separator:ab02e5d9677a934f4c981d58d435d4b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7ea3616bfa61f7269cdd33086a70f4"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772">_dr_pred_trigger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4f7ea3616bfa61f7269cdd33086a70f4">dr_pred_trigger_t</a></td></tr>
<tr class="separator:a4f7ea3616bfa61f7269cdd33086a70f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac55eea34836068d8d66196c3f1556d71"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71">_dr_pred_type_t</a> { <br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ad94a882e075b12c0e4e6e5f852e4e4b2">DR_PRED_NONE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a73fe4e68d99f10cbef5cd9e22fd23577">DR_PRED_O</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a55f11d7f40baaa33ff1224d9b3d94210">DR_PRED_NO</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ad15eddf8665676a15deedc5878f2c3bf">DR_PRED_B</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a9e7e5cd4c46dfcd0524c89f97c5e5381">DR_PRED_NB</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a2bcac2d1e198e4708a2a08f4e429f748">DR_PRED_Z</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71add0fb2af7372312d49ec62cd1705f046">DR_PRED_NZ</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a3afd847eebcbed1bb9695858727b5e57">DR_PRED_BE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a1286e03cd056a94201c46f3ed416074d">DR_PRED_NBE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a0f3659e2b77ec4c3bf765394e14cea18">DR_PRED_S</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a1d73b15fb50af162b86ecfdca21cb067">DR_PRED_NS</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a6f0cd6c3f9706dd5b6abe4baeaf385b5">DR_PRED_P</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71aba0e448a0a4bcf4de31e28a61c46e96b">DR_PRED_NP</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a75f5f1a12d5b7707b7c3279bb71f7384">DR_PRED_L</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71a6c14dd778a1f20408247ab7948d9e3e6">DR_PRED_NL</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71accf763617376a3a85588d6a79e601dfe">DR_PRED_LE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71aecaeb5a9b0412fcd97706330b3d03758">DR_PRED_NLE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ade60058c0eb6909b05024f9728c6b9bc">DR_PRED_COMPLEX</a>
<br />
 }<tr class="separator:ac55eea34836068d8d66196c3f1556d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:add920ca9228d3e1daff67e0975a2e8cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cd">_dr_opnd_query_flags_t</a> { <br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cda97f20c43f26eb78a236c8e7ae031c8c6">DR_QUERY_INCLUDE_COND_DSTS</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cda9c231d02d0dbfbfe89d01f69ed25f34d">DR_QUERY_INCLUDE_COND_SRCS</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cda5d5d0aac79cc4d1dbac875ae0a9f5a4e">DR_QUERY_DEFAULT</a> = DR_QUERY_INCLUDE_COND_SRCS, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cdaf795696f4e8d1b5a5aa446c717e6739b">DR_QUERY_INCLUDE_ALL</a> = (DR_QUERY_INCLUDE_COND_DSTS|DR_QUERY_INCLUDE_COND_SRCS)
<br />
 }<tr class="separator:add920ca9228d3e1daff67e0975a2e8cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a8c0ff6068a163a5cd113771ef5ee7772"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772">_dr_pred_trigger_t</a> { <br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772ae46430e5d5de989c13928bdda20229b3">DR_PRED_TRIGGER_NOPRED</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772a04609c78333a6147ebb6bb8814183922">DR_PRED_TRIGGER_MATCH</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772a0bf091d9f7128fdc9591f566b177b0c1">DR_PRED_TRIGGER_MISMATCH</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772ab472d01df9fead8c13beaf75da010400">DR_PRED_TRIGGER_UNKNOWN</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772a36d7eb98d337bb458d3afd3f2c902787">DR_PRED_TRIGGER_INVALID</a>
<br />
 }<tr class="separator:a8c0ff6068a163a5cd113771ef5ee7772"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a192e9ddf90889e6de003d95ebdaa7beb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a> { <br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba47d09b15b2ec78db7ce84ae6ddf333b0">DR_FP_STATE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba973de5b2ea84fb3da6db3e2b5f8ec5e3">DR_FP_MOVE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba24a7a4e2a7b4558a1e2a26b690c5b6c7">DR_FP_CONVERT</a>, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beba20c0efa9e59f5424338edcbae638c6d3">DR_FP_MATH</a>
<br />
 }<tr class="separator:a192e9ddf90889e6de003d95ebdaa7beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:aae05225933a42f81e7c4a9fb286596f9"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9aef9a85103f89f1abdcbc577177fe59dc">EFLAGS_CF</a> = 0x00000001, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9abd82d6f3c93948e598947c3e60c5ffbe">EFLAGS_PF</a> = 0x00000004, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9ae02f888626e1c77d3dadb0c69c4ccebe">EFLAGS_AF</a> = 0x00000010, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9aeb567fc9958d98e114e2aed3f73e6cf1">EFLAGS_ZF</a> = 0x00000040, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9a607506a5fd2d021972d2f7ecb397960f">EFLAGS_SF</a> = 0x00000080, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9ad3cf0d7affac2713bfcb915f809200da">EFLAGS_DF</a> = 0x00000400, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9ad4d56500271d500e241e46fdd7fdddb4">EFLAGS_OF</a> = 0x00000800, 
<br />
&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#aae05225933a42f81e7c4a9fb286596f9a8e0641c833e66b6787c36170b3484a01">EFLAGS_ARITH</a> = EFLAGS_CF|EFLAGS_PF|EFLAGS_AF|EFLAGS_ZF|EFLAGS_SF|EFLAGS_OF
<br />
 }<tr class="separator:aae05225933a42f81e7c4a9fb286596f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a56419903595cc4bd2bb39f887a5275d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a56419903595cc4bd2bb39f887a5275d5">instr_is_encoding_possible</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a56419903595cc4bd2bb39f887a5275d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cd4d0740eb0a0bcd2d387685719263c"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1cd4d0740eb0a0bcd2d387685719263c">instr_encode</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr class="separator:a1cd4d0740eb0a0bcd2d387685719263c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5356c2dd3388496158fa0a918f8c2a53"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5356c2dd3388496158fa0a918f8c2a53">instr_encode_to_copy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *copy_pc, byte *final_pc)</td></tr>
<tr class="separator:a5356c2dd3388496158fa0a918f8c2a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f53f3c43c91833faf11b5e6cd9e905"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a65f53f3c43c91833faf11b5e6cd9e905">instr_create</a> (void *drcontext)</td></tr>
<tr class="separator:a65f53f3c43c91833faf11b5e6cd9e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b55daa2b3780d2c07e33b8330b2f62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a77b55daa2b3780d2c07e33b8330b2f62">instr_init</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a77b55daa2b3780d2c07e33b8330b2f62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f3cc7fb91265cb6c8eb15a84184c1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae0f3cc7fb91265cb6c8eb15a84184c1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd2bdee07d2e6ca0be3b252bc7b913f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#accd2bdee07d2e6ca0be3b252bc7b913f">instr_reset</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:accd2bdee07d2e6ca0be3b252bc7b913f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9b44a1db49dc5cd8da8b6b27fa47d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab9b44a1db49dc5cd8da8b6b27fa47d50">instr_reuse</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ab9b44a1db49dc5cd8da8b6b27fa47d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb082bbf9ac73968667b79b4cd14d73f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acb082bbf9ac73968667b79b4cd14d73f">instr_destroy</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acb082bbf9ac73968667b79b4cd14d73f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a11b5b0700f7601087e2fda87175040"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9a11b5b0700f7601087e2fda87175040">instr_get_next</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9a11b5b0700f7601087e2fda87175040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1114903afc8f9a3539aed43330117627"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1114903afc8f9a3539aed43330117627">instr_get_next_app</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1114903afc8f9a3539aed43330117627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1432bded4f063c3c9d41f1a798f703b0"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1432bded4f063c3c9d41f1a798f703b0">instr_get_prev</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1432bded4f063c3c9d41f1a798f703b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a520a1d1ef99a993196fb1bd54aebd7df"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a520a1d1ef99a993196fb1bd54aebd7df">instr_get_prev_app</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a520a1d1ef99a993196fb1bd54aebd7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c3ae1eb25b05c337889022f35e6187"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa8c3ae1eb25b05c337889022f35e6187">instr_set_next</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structinstr__t.html">instr_t</a> *next)</td></tr>
<tr class="separator:aa8c3ae1eb25b05c337889022f35e6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a208fe2bdba4a5ea47f1a0588fdc3278b"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a208fe2bdba4a5ea47f1a0588fdc3278b">instr_set_prev</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structinstr__t.html">instr_t</a> *prev)</td></tr>
<tr class="separator:a208fe2bdba4a5ea47f1a0588fdc3278b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776a1fd0cf8f783b2a969a24432fee6e"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a776a1fd0cf8f783b2a969a24432fee6e">instr_get_note</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a776a1fd0cf8f783b2a969a24432fee6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85a8f92faa0d368fec240e6fa819ca9c"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a85a8f92faa0d368fec240e6fa819ca9c">instr_set_note</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, void *value)</td></tr>
<tr class="separator:a85a8f92faa0d368fec240e6fa819ca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4c178ef16a57aa4c89976cb11419719"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab4c178ef16a57aa4c89976cb11419719">instr_get_branch_target_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr)</td></tr>
<tr class="separator:ab4c178ef16a57aa4c89976cb11419719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1429cf1d1da8156898fde712e59e86db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1429cf1d1da8156898fde712e59e86db">instr_set_branch_target_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr, app_pc pc)</td></tr>
<tr class="separator:a1429cf1d1da8156898fde712e59e86db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7abc869b82542e5ea0e564ec671b7cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad7abc869b82542e5ea0e564ec671b7cd">instr_is_exit_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad7abc869b82542e5ea0e564ec671b7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa21d0c15479e3a0ee88a7ec06fe9eb22"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa21d0c15479e3a0ee88a7ec06fe9eb22">instr_is_interrupt</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aa21d0c15479e3a0ee88a7ec06fe9eb22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e6d7eea24e55c4a4851ab4e3c0aa108"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e6d7eea24e55c4a4851ab4e3c0aa108">instr_is_app</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5e6d7eea24e55c4a4851ab4e3c0aa108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d47ceb0c0c0b5f50b78346c85a7f47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ab7d47ceb0c0c0b5f50b78346c85a7f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad03f60b3110fcbd793381245bed502be"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad03f60b3110fcbd793381245bed502be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0919782b67d3918ec6feb838e373f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad0919782b67d3918ec6feb838e373f15">instr_set_meta</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ad0919782b67d3918ec6feb838e373f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95454ba978870e70aa6b882155c4dabd"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a95454ba978870e70aa6b882155c4dabd">instr_ok_to_mangle</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a95454ba978870e70aa6b882155c4dabd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2335bd8d05936e8308506ef11f1be401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2335bd8d05936e8308506ef11f1be401">instr_set_ok_to_mangle</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr class="separator:a2335bd8d05936e8308506ef11f1be401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5206d055a5b06435bd5e919da40e8bd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5206d055a5b06435bd5e919da40e8bd4">instr_set_meta_no_translation</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5206d055a5b06435bd5e919da40e8bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a221092e79cb7fd9a701c2e260685a6dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a221092e79cb7fd9a701c2e260685a6dc">instr_ok_to_emit</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a221092e79cb7fd9a701c2e260685a6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34605a2cff286d358941be6aa91788d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae34605a2cff286d358941be6aa91788d">instr_set_ok_to_emit</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr class="separator:ae34605a2cff286d358941be6aa91788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0e57a48576a4aac25b1554f6ebcbf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ace0e57a48576a4aac25b1554f6ebcbf7">instr_length</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ace0e57a48576a4aac25b1554f6ebcbf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af679a00bb888cbb46ae266a8591997ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af679a00bb888cbb46ae266a8591997ea">instr_mem_usage</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:af679a00bb888cbb46ae266a8591997ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c874bf0f8b67dd6a85f2d54c1e87dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *orig)</td></tr>
<tr class="separator:af8c874bf0f8b67dd6a85f2d54c1e87dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ef462712287c564d125a71383a09c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a88ef462712287c564d125a71383a09c3">instr_build</a> (void *drcontext, int opcode, int num_dsts, int num_srcs)</td></tr>
<tr class="separator:a88ef462712287c564d125a71383a09c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947d5940c5e43001ee44577a05d433f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a947d5940c5e43001ee44577a05d433f5">instr_build_bits</a> (void *drcontext, int opcode, uint num_bytes)</td></tr>
<tr class="separator:a947d5940c5e43001ee44577a05d433f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9890dc9d4dbc40589c974a0ff221db72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9890dc9d4dbc40589c974a0ff221db72">instr_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9890dc9d4dbc40589c974a0ff221db72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57dbc129ab88dfdcf49f1105eba394a7"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a57dbc129ab88dfdcf49f1105eba394a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d36984352b073089da3c91b901c853"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a90d36984352b073089da3c91b901c853">instr_get_opcode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a90d36984352b073089da3c91b901c853"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1efc53088af35fa0ed6eefd80af5dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e1efc53088af35fa0ed6eefd80af5dd">instr_set_opcode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, int opcode)</td></tr>
<tr class="separator:a5e1efc53088af35fa0ed6eefd80af5dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f43bb8dee8ee7c8d07727247d3428b0"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2f43bb8dee8ee7c8d07727247d3428b0">instr_num_srcs</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a2f43bb8dee8ee7c8d07727247d3428b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c99383d4ffa44c28d6fed33b449b2f"><td class="memItemLeft" align="right" valign="top">INSTR_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a41c99383d4ffa44c28d6fed33b449b2f">instr_num_dsts</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a41c99383d4ffa44c28d6fed33b449b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee0d80a8e69e8f0abe867f1903a107ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aee0d80a8e69e8f0abe867f1903a107ea">instr_set_num_opnds</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, int num_dsts, int num_srcs)</td></tr>
<tr class="separator:aee0d80a8e69e8f0abe867f1903a107ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60219f08461b9bc143214c937893d98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa60219f08461b9bc143214c937893d98">instr_get_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:aa60219f08461b9bc143214c937893d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed999847d48a5a9eb1032239a660e398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aed999847d48a5a9eb1032239a660e398">instr_get_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:aed999847d48a5a9eb1032239a660e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bfa15e2f3a95174e36c80c585a24e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a96bfa15e2f3a95174e36c80c585a24e3">instr_set_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, <a class="el" href="structopnd__t.html">opnd_t</a> opnd)</td></tr>
<tr class="separator:a96bfa15e2f3a95174e36c80c585a24e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e843e39613655f6a5c49e081fe593c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8e843e39613655f6a5c49e081fe593c2">instr_set_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, <a class="el" href="structopnd__t.html">opnd_t</a> opnd)</td></tr>
<tr class="separator:a8e843e39613655f6a5c49e081fe593c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc087f8b47135d8f08520bf0fffa630"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afcc087f8b47135d8f08520bf0fffa630">instr_remove_srcs</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, uint start, uint end)</td></tr>
<tr class="separator:afcc087f8b47135d8f08520bf0fffa630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86db389d26757898fb8a614e43bf4b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae86db389d26757898fb8a614e43bf4b7">instr_remove_dsts</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, uint start, uint end)</td></tr>
<tr class="separator:ae86db389d26757898fb8a614e43bf4b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff26384b57a52838dbd9b854db44cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6ff26384b57a52838dbd9b854db44cb6">instr_get_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr)</td></tr>
<tr class="separator:a6ff26384b57a52838dbd9b854db44cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf4b84b7a6b07e22af66b0aec7cacf5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#adbf4b84b7a6b07e22af66b0aec7cacf5">instr_set_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *cti_instr, <a class="el" href="structopnd__t.html">opnd_t</a> target)</td></tr>
<tr class="separator:adbf4b84b7a6b07e22af66b0aec7cacf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c820f4c4b82638289cca3c40f1d15c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9c820f4c4b82638289cca3c40f1d15c0">instr_operands_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9c820f4c4b82638289cca3c40f1d15c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f4d5f068f69df848c0dd1cacebc90f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac8f4d5f068f69df848c0dd1cacebc90f">instr_set_operands_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool valid)</td></tr>
<tr class="separator:ac8f4d5f068f69df848c0dd1cacebc90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaf6ea858ca81c8b9968e4be43749f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afeaf6ea858ca81c8b9968e4be43749f6">instr_opcode_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:afeaf6ea858ca81c8b9968e4be43749f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad68b83f3990306d6af6b5a66447038"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2ad68b83f3990306d6af6b5a66447038">instr_get_eflags</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a> flags)</td></tr>
<tr class="separator:a2ad68b83f3990306d6af6b5a66447038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749df373b340acb6437fea2f02b2fe69"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a749df373b340acb6437fea2f02b2fe69">instr_get_opcode_eflags</a> (int opcode)</td></tr>
<tr class="separator:a749df373b340acb6437fea2f02b2fe69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362aa1ce2cc38c3e3754c44ad976dca8"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a362aa1ce2cc38c3e3754c44ad976dca8">instr_get_arith_flags</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a> flags)</td></tr>
<tr class="separator:a362aa1ce2cc38c3e3754c44ad976dca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9c3a55529a9e5467851821fe53fdb2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7b9c3a55529a9e5467851821fe53fdb2">instr_set_raw_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *addr, uint length)</td></tr>
<tr class="separator:a7b9c3a55529a9e5467851821fe53fdb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b3326d827b06a1d1d0bc3d20ba17a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a76b3326d827b06a1d1d0bc3d20ba17a2">instr_set_raw_bits_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool valid)</td></tr>
<tr class="separator:a76b3326d827b06a1d1d0bc3d20ba17a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af08de27201e4c64a655e309b47d096c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af08de27201e4c64a655e309b47d096c4">instr_raw_bits_valid</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:af08de27201e4c64a655e309b47d096c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add5ea7e7d0387d7d1461830c1e5253c3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add5ea7e7d0387d7d1461830c1e5253c3">instr_has_allocated_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:add5ea7e7d0387d7d1461830c1e5253c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8c87b75de66fe9fcdf3db864a08702"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#adb8c87b75de66fe9fcdf3db864a08702">instr_needs_encoding</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:adb8c87b75de66fe9fcdf3db864a08702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a954715b40fa2668d7cde0c4a1bf47e51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a954715b40fa2668d7cde0c4a1bf47e51">instr_is_meta_may_fault</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a954715b40fa2668d7cde0c4a1bf47e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94227a193446d370f0180e6a844be0c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool val)</td></tr>
<tr class="separator:a94227a193446d370f0180e6a844be0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b33f34d4dd11993224b4fb10e136dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, uint num_bytes)</td></tr>
<tr class="separator:af7b33f34d4dd11993224b4fb10e136dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1beda2d570ba04d74ca9cbd7c31bb1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, app_pc addr)</td></tr>
<tr class="separator:af1beda2d570ba04d74ca9cbd7c31bb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8620fe9a0391247fcd9183e7cac291c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8620fe9a0391247fcd9183e7cac291c3">instr_make_persistent</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a8620fe9a0391247fcd9183e7cac291c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a964928ee44090aba9aef343c5d34df5c"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a964928ee44090aba9aef343c5d34df5c">instr_get_raw_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a964928ee44090aba9aef343c5d34df5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7af19aa3aadf7b05900a39ef62b01b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa7af19aa3aadf7b05900a39ef62b01b9">instr_free_raw_bits</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aa7af19aa3aadf7b05900a39ef62b01b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d41e2a8da7c0ef207d269020053ecc"><td class="memItemLeft" align="right" valign="top">byte&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af8d41e2a8da7c0ef207d269020053ecc">instr_get_raw_byte</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:af8d41e2a8da7c0ef207d269020053ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11045a1b7b7cbd2053048f028e5e687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad11045a1b7b7cbd2053048f028e5e687">instr_set_raw_byte</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, byte byte)</td></tr>
<tr class="separator:ad11045a1b7b7cbd2053048f028e5e687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71fba42e58fa08ed1e0da9be2fbde4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a71fba42e58fa08ed1e0da9be2fbde4d4">instr_set_raw_bytes</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *start, uint num_bytes)</td></tr>
<tr class="separator:a71fba42e58fa08ed1e0da9be2fbde4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ea2d9c35a7b4fcf89e4d160314babb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a22ea2d9c35a7b4fcf89e4d160314babb">instr_set_raw_word</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos, uint word)</td></tr>
<tr class="separator:a22ea2d9c35a7b4fcf89e4d160314babb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d1b19bf4e736c6f361164a295160a6"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0d1b19bf4e736c6f361164a295160a6">instr_get_raw_word</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint pos)</td></tr>
<tr class="separator:ae0d1b19bf4e736c6f361164a295160a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3948b6ce886753002699286061faef26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3948b6ce886753002699286061faef26">instr_set_prefix_flag</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint prefix)</td></tr>
<tr class="separator:a3948b6ce886753002699286061faef26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3722cd7a5b3728b5edeefd4b07bd456c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3722cd7a5b3728b5edeefd4b07bd456c">instr_get_prefix_flag</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, uint prefix)</td></tr>
<tr class="separator:a3722cd7a5b3728b5edeefd4b07bd456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d25cfd2ef6384b820b244fbb45dfb27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8d25cfd2ef6384b820b244fbb45dfb27">instr_is_predicated</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a8d25cfd2ef6384b820b244fbb45dfb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1ba8cfdd319503cf12d0af2dd217c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7a1ba8cfdd319503cf12d0af2dd217c6">instr_get_predicate</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a7a1ba8cfdd319503cf12d0af2dd217c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c79cd1dd94bb1ba7e3740a80c42184f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2c79cd1dd94bb1ba7e3740a80c42184f">instr_predicate_name</a> (<a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred)</td></tr>
<tr class="separator:a2c79cd1dd94bb1ba7e3740a80c42184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a506a5fb59ed91706a99dd15d60f63234"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a506a5fb59ed91706a99dd15d60f63234">instr_invert_predicate</a> (<a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred)</td></tr>
<tr class="separator:a506a5fb59ed91706a99dd15d60f63234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3633ffd22f844dd7e525a17234c0a7c"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac3633ffd22f844dd7e525a17234c0a7c">instr_it_block_get_count</a> (<a class="el" href="structinstr__t.html">instr_t</a> *it_instr)</td></tr>
<tr class="separator:ac3633ffd22f844dd7e525a17234c0a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07d45123c213dd6bfce245d78b45b3a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a07d45123c213dd6bfce245d78b45b3a9">instr_it_block_get_pred</a> (<a class="el" href="structinstr__t.html">instr_t</a> *it_instr, uint index)</td></tr>
<tr class="separator:a07d45123c213dd6bfce245d78b45b3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3ce6c289fa92d4cffdaf84bbbf691a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6e3ce6c289fa92d4cffdaf84bbbf691a">instr_it_block_compute_immediates</a> (<a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred0, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred1, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred2, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred3, byte *firstcond_out, byte *mask_out)</td></tr>
<tr class="separator:a6e3ce6c289fa92d4cffdaf84bbbf691a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee83fd953b3c6ae6554b56d57e720c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aeee83fd953b3c6ae6554b56d57e720c3">instr_it_block_create</a> (void *drcontext, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred0, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred1, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred2, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred3)</td></tr>
<tr class="separator:aeee83fd953b3c6ae6554b56d57e720c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3156edfed281e089c234fc475df6c82a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3156edfed281e089c234fc475df6c82a">instr_is_exclusive_store</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a3156edfed281e089c234fc475df6c82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac668216d6d231b12cf2845c5dc982ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac668216d6d231b12cf2845c5dc982ded">instr_set_predicate</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> pred)</td></tr>
<tr class="separator:ac668216d6d231b12cf2845c5dc982ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284a0bdc5a1cc7a841a061edd4d37c7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__instr_8h.html#a4f7ea3616bfa61f7269cdd33086a70f4">dr_pred_trigger_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a284a0bdc5a1cc7a841a061edd4d37c7d">instr_predicate_triggered</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mc)</td></tr>
<tr class="separator:a284a0bdc5a1cc7a841a061edd4d37c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74814111812ff20b281f7350fb626746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a74814111812ff20b281f7350fb626746">instr_set_x86_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, bool x86)</td></tr>
<tr class="separator:a74814111812ff20b281f7350fb626746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3a5a5abd40c0c0694f037fcfac5705"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acf3a5a5abd40c0c0694f037fcfac5705">instr_get_x86_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acf3a5a5abd40c0c0694f037fcfac5705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3e9d1d3cfd1a9db59a9b518cf7b61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac5a3e9d1d3cfd1a9db59a9b518cf7b61">instr_set_isa_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__utils_8h.html#a83ebdc7f73d889146aaf9f6ea7865d94">dr_isa_mode_t</a> mode)</td></tr>
<tr class="separator:ac5a3e9d1d3cfd1a9db59a9b518cf7b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac086123f4336dac9783232c87ba7e52c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__utils_8h.html#a83ebdc7f73d889146aaf9f6ea7865d94">dr_isa_mode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac086123f4336dac9783232c87ba7e52c">instr_get_isa_mode</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ac086123f4336dac9783232c87ba7e52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dba2c8ede2bb35a708bd8dba95d5746"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2dba2c8ede2bb35a708bd8dba95d5746">instr_shrink_to_16_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a2dba2c8ede2bb35a708bd8dba95d5746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0db1cec99a6fff7dde7201a87ca8892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae0db1cec99a6fff7dde7201a87ca8892">instr_shrink_to_32_bits</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae0db1cec99a6fff7dde7201a87ca8892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a3336a497835085cc0a7be3b010cf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a15a3336a497835085cc0a7be3b010cf3">instr_uses_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a15a3336a497835085cc0a7be3b010cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b828bdfc3723d5b05d7147cfc237397"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9b828bdfc3723d5b05d7147cfc237397">instr_uses_fp_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9b828bdfc3723d5b05d7147cfc237397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1092dee2d8367ca2fec50cba5e632d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae1092dee2d8367ca2fec50cba5e632d0">instr_reg_in_src</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:ae1092dee2d8367ca2fec50cba5e632d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0752a69bd5b0331f8e98512ec15c2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7e0752a69bd5b0331f8e98512ec15c2b">instr_reg_in_dst</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a7e0752a69bd5b0331f8e98512ec15c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4eeb11aca6356b8f190cee7119c7ea9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa4eeb11aca6356b8f190cee7119c7ea9">instr_writes_to_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a> flags)</td></tr>
<tr class="separator:aa4eeb11aca6356b8f190cee7119c7ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eedc2c20258ebd1e50d0a99dcda89fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7eedc2c20258ebd1e50d0a99dcda89fa">instr_reads_from_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a> flags)</td></tr>
<tr class="separator:a7eedc2c20258ebd1e50d0a99dcda89fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4c5c2c93e36bc599d327d301ddb4f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aae4c5c2c93e36bc599d327d301ddb4f1">instr_writes_to_exact_reg</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg, <a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a> flags)</td></tr>
<tr class="separator:aae4c5c2c93e36bc599d327d301ddb4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ff0a9b43777e95bf6932260f4b5cc09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7ff0a9b43777e95bf6932260f4b5cc09">instr_replace_src_opnd</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="structopnd__t.html">opnd_t</a> old_opnd, <a class="el" href="structopnd__t.html">opnd_t</a> new_opnd)</td></tr>
<tr class="separator:a7ff0a9b43777e95bf6932260f4b5cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e75c7fe47cb20acfae6bca1cd4bd2e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9e75c7fe47cb20acfae6bca1cd4bd2e0">instr_same</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr1, <a class="el" href="structinstr__t.html">instr_t</a> *instr2)</td></tr>
<tr class="separator:a9e75c7fe47cb20acfae6bca1cd4bd2e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae408fe229bea0aa800cddb6b911c0e94"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae408fe229bea0aa800cddb6b911c0e94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1aac8cef8bb6ab075238e38ad6888a9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae1aac8cef8bb6ab075238e38ad6888a9">instr_writes_memory</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae1aac8cef8bb6ab075238e38ad6888a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785671aba1adec0f47add596f7e6a440"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a785671aba1adec0f47add596f7e6a440">instr_zeroes_ymmh</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a785671aba1adec0f47add596f7e6a440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2b7bfe6c9670ac127a24ea7aef33d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7c2b7bfe6c9670ac127a24ea7aef33d4">instr_has_rel_addr_reference</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a7c2b7bfe6c9670ac127a24ea7aef33d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b43ab8c3edd905329429075e91ea1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a19b43ab8c3edd905329429075e91ea1a">instr_get_rel_addr_target</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, app_pc *target)</td></tr>
<tr class="separator:a19b43ab8c3edd905329429075e91ea1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e4c9cbe4890f8e37af9e299affc86c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae9e4c9cbe4890f8e37af9e299affc86c">instr_get_rel_addr_dst_idx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae9e4c9cbe4890f8e37af9e299affc86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8942eef70af97b8018b31df431ef1822"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8942eef70af97b8018b31df431ef1822">instr_get_rel_addr_src_idx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a8942eef70af97b8018b31df431ef1822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13ec559a17ab70816f80de784e5632f"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mc)</td></tr>
<tr class="separator:aa13ec559a17ab70816f80de784e5632f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa04322a189dd7f17ab245594e02cc6a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mc, uint index, OUT app_pc *addr, OUT bool *write)</td></tr>
<tr class="separator:aa04322a189dd7f17ab245594e02cc6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25107e1fb5a49de3c627b70acc7b2eef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a25107e1fb5a49de3c627b70acc7b2eef">instr_compute_address_ex_pos</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mc, uint index, OUT app_pc *addr, OUT bool *is_write, OUT uint *pos)</td></tr>
<tr class="separator:a25107e1fb5a49de3c627b70acc7b2eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67563b7baa993aa824ba1803562fc029"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a67563b7baa993aa824ba1803562fc029">instr_memory_reference_size</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a67563b7baa993aa824ba1803562fc029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eab5eaa85e186349d200a87e8010fec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a7eab5eaa85e186349d200a87e8010fec">instr_get_label_data_area</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a7eab5eaa85e186349d200a87e8010fec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b39dade5681d6135379a5d53fe57512"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8b39dade5681d6135379a5d53fe57512">instr_is_mov</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a8b39dade5681d6135379a5d53fe57512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d347723617986e9424b042cb69495e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9d347723617986e9424b042cb69495e5">instr_is_call</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9d347723617986e9424b042cb69495e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb0fc26f65991c24002df14abb7e461"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5cb0fc26f65991c24002df14abb7e461">instr_is_call_direct</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5cb0fc26f65991c24002df14abb7e461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87d172e2621d4548fe2c414fb0ed333a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a87d172e2621d4548fe2c414fb0ed333a">instr_is_near_call_direct</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a87d172e2621d4548fe2c414fb0ed333a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fe1cc575e2870720ceee8ce134771f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1fe1cc575e2870720ceee8ce134771f3">instr_is_call_indirect</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1fe1cc575e2870720ceee8ce134771f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade184d50e1016f220a10f40a60a4f8ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ade184d50e1016f220a10f40a60a4f8ad">instr_is_return</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ade184d50e1016f220a10f40a60a4f8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a076d0445255d4902181cb272bacd80aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a076d0445255d4902181cb272bacd80aa">instr_is_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a076d0445255d4902181cb272bacd80aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2782471943558d57296b89a3f41a530d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2782471943558d57296b89a3f41a530d">instr_is_cti_short</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a2782471943558d57296b89a3f41a530d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af759611c486c5ac9e1a5336a809661"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4af759611c486c5ac9e1a5336a809661">instr_is_cti_loop</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a4af759611c486c5ac9e1a5336a809661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c61714f2632d46211d61ebb55d4bbde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a8c61714f2632d46211d61ebb55d4bbde">instr_is_cti_short_rewrite</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, byte *pc)</td></tr>
<tr class="separator:a8c61714f2632d46211d61ebb55d4bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006c261a813d4e91fc25c549e5ebbb8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a006c261a813d4e91fc25c549e5ebbb8d">instr_is_cbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a006c261a813d4e91fc25c549e5ebbb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a963ac2677038071fc295b3b6eb45ce1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a963ac2677038071fc295b3b6eb45ce1d">instr_is_mbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a963ac2677038071fc295b3b6eb45ce1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39c368adab3332628a34c1f48afc466"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac39c368adab3332628a34c1f48afc466">instr_is_ubr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ac39c368adab3332628a34c1f48afc466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5541d2b9311f842c43c0cfca020eb5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab5541d2b9311f842c43c0cfca020eb5d">instr_is_near_ubr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ab5541d2b9311f842c43c0cfca020eb5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ee0433816dfcfbe8ca41988d757aee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a45ee0433816dfcfbe8ca41988d757aee">instr_is_far_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a45ee0433816dfcfbe8ca41988d757aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83165c08bdab6b1bf0933bccba7d557"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac83165c08bdab6b1bf0933bccba7d557">instr_is_far_abs_cti</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ac83165c08bdab6b1bf0933bccba7d557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d982227aea8aa8647694b35cc592b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a86d982227aea8aa8647694b35cc592b3">instr_is_syscall</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a86d982227aea8aa8647694b35cc592b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a4d5454f266483029bd88e5a17e398c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4a4d5454f266483029bd88e5a17e398c">instr_is_wow64_syscall</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a4a4d5454f266483029bd88e5a17e398c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa653a23cf2029fc4eeaf05eb7523849d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa653a23cf2029fc4eeaf05eb7523849d">instr_is_prefetch</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aa653a23cf2029fc4eeaf05eb7523849d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8da7990fa33f321134102323546516b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac8da7990fa33f321134102323546516b">instr_is_mov_constant</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, ptr_int_t *value)</td></tr>
<tr class="separator:ac8da7990fa33f321134102323546516b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81cdb64c78235caf707130680d1f156d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a81cdb64c78235caf707130680d1f156d">instr_is_floating</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a81cdb64c78235caf707130680d1f156d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac609abca95ab7f30d7f289f5dd19fdad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac609abca95ab7f30d7f289f5dd19fdad">instr_is_floating_ex</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, <a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a> *type)</td></tr>
<tr class="separator:ac609abca95ab7f30d7f289f5dd19fdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e297cd513cbde904d0e09b721f1e9c1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a5e297cd513cbde904d0e09b721f1e9c1">instr_is_mmx</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a5e297cd513cbde904d0e09b721f1e9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ab772125d06465662c15bd3f94cda6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa7ab772125d06465662c15bd3f94cda6">instr_is_sse</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aa7ab772125d06465662c15bd3f94cda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a8d4187a66f98538b09738027941ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a68a8d4187a66f98538b09738027941ea">instr_is_sse2</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a68a8d4187a66f98538b09738027941ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33bb11334437a3076fbb81c0493f6e7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a33bb11334437a3076fbb81c0493f6e7a">instr_is_sse_or_sse2</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a33bb11334437a3076fbb81c0493f6e7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa10a8067ef7d4b13f6f5bcc7a0160b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#afa10a8067ef7d4b13f6f5bcc7a0160b7">instr_is_3DNow</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:afa10a8067ef7d4b13f6f5bcc7a0160b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeba8e0bc76cb3b58b32320963a67401"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aaeba8e0bc76cb3b58b32320963a67401">instr_is_sse3</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:aaeba8e0bc76cb3b58b32320963a67401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933b1ffd9da886403f647f2adbedc3fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a933b1ffd9da886403f647f2adbedc3fd">instr_is_ssse3</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a933b1ffd9da886403f647f2adbedc3fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c7803a383529af652ed1c990bf1e2ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a0c7803a383529af652ed1c990bf1e2ec">instr_is_sse41</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a0c7803a383529af652ed1c990bf1e2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac2f94297357cfa59af50bfe8c21ec6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4ac2f94297357cfa59af50bfe8c21ec6">instr_is_sse42</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a4ac2f94297357cfa59af50bfe8c21ec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2f45cf71161208586e3bd8666a2242"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a9c2f45cf71161208586e3bd8666a2242">instr_is_sse4A</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a9c2f45cf71161208586e3bd8666a2242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf18b53c422fdb11efe7bdcc596aea2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a1cf18b53c422fdb11efe7bdcc596aea2">instr_is_mov_imm_to_tos</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a1cf18b53c422fdb11efe7bdcc596aea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61355d1ac416d4f04ed286eebc7c251"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae61355d1ac416d4f04ed286eebc7c251">instr_is_label</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:ae61355d1ac416d4f04ed286eebc7c251"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465cc4935f184c4d224afbb9547a445c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a465cc4935f184c4d224afbb9547a445c">instr_is_undefined</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a465cc4935f184c4d224afbb9547a445c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784fcd66cdda36aaf218121f1b75ab2d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a784fcd66cdda36aaf218121f1b75ab2d">instr_get_interrupt_number</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a784fcd66cdda36aaf218121f1b75ab2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25aa34b90fcf0cdcfdbd8028464274"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acc25aa34b90fcf0cdcfdbd8028464274">instr_invert_cbr</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acc25aa34b90fcf0cdcfdbd8028464274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a349e086f96bb03bd6700129dc6135"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a33a349e086f96bb03bd6700129dc6135">instr_convert_short_meta_jmp_to_long</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:a33a349e086f96bb03bd6700129dc6135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a9b2a0b21a18dbfd0a7a534204b92b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a79a9b2a0b21a18dbfd0a7a534204b92b">instr_jcc_taken</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_t eflags)</td></tr>
<tr class="separator:a79a9b2a0b21a18dbfd0a7a534204b92b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a222195624605490e7844ed3737ad3668"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a222195624605490e7844ed3737ad3668">instr_cmovcc_to_jcc</a> (int cmovcc_opcode)</td></tr>
<tr class="separator:a222195624605490e7844ed3737ad3668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238dc0a1168701e30a95b57dd0c845a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a238dc0a1168701e30a95b57dd0c845a0">instr_cmovcc_triggered</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr, reg_t eflags)</td></tr>
<tr class="separator:a238dc0a1168701e30a95b57dd0c845a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2c91a7868ad6a8e5c47af985edde61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#acb2c91a7868ad6a8e5c47af985edde61">instr_is_nop</a> (<a class="el" href="structinstr__t.html">instr_t</a> *instr)</td></tr>
<tr class="separator:acb2c91a7868ad6a8e5c47af985edde61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00a75c880108dde16b137370be5cedb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac00a75c880108dde16b137370be5cedb">instr_create_0dst_0src</a> (void *drcontext, int opcode)</td></tr>
<tr class="separator:ac00a75c880108dde16b137370be5cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3835ac2d78ba9b90e1ced9c58cada5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ad3835ac2d78ba9b90e1ced9c58cada5e">instr_create_0dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:ad3835ac2d78ba9b90e1ced9c58cada5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d0c2cbad95bfe24daade84c6add8af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a54d0c2cbad95bfe24daade84c6add8af">instr_create_0dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:a54d0c2cbad95bfe24daade84c6add8af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21033066f65f8dfd23ca24215ea99b70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a21033066f65f8dfd23ca24215ea99b70">instr_create_0dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:a21033066f65f8dfd23ca24215ea99b70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11b0fd63ac17f6054ad2834f900b536"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae11b0fd63ac17f6054ad2834f900b536">instr_create_0dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:ae11b0fd63ac17f6054ad2834f900b536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4db9f5f8dfd216fab6e9153170fb479f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4db9f5f8dfd216fab6e9153170fb479f">instr_create_1dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst)</td></tr>
<tr class="separator:a4db9f5f8dfd216fab6e9153170fb479f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0202b3cf63b50d16947f6be6f2b00891"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a0202b3cf63b50d16947f6be6f2b00891">instr_create_1dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:a0202b3cf63b50d16947f6be6f2b00891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac469b18246e67b23f758c636f460d8ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ac469b18246e67b23f758c636f460d8ac">instr_create_1dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:ac469b18246e67b23f758c636f460d8ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a34019f73e797090b3ab9625cdbc5fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4a34019f73e797090b3ab9625cdbc5fc">instr_create_1dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:a4a34019f73e797090b3ab9625cdbc5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39dacd6683dce94ed6cddd249c0432f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a39dacd6683dce94ed6cddd249c0432f6">instr_create_1dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:a39dacd6683dce94ed6cddd249c0432f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e5a5241276ad8d2f392c7a1432efb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a4e5a5241276ad8d2f392c7a1432efb61">instr_create_1dst_5src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4, <a class="el" href="structopnd__t.html">opnd_t</a> src5)</td></tr>
<tr class="separator:a4e5a5241276ad8d2f392c7a1432efb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeadd422dcd43564d40b43ca0e03b6910"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aeadd422dcd43564d40b43ca0e03b6910">instr_create_2dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2)</td></tr>
<tr class="separator:aeadd422dcd43564d40b43ca0e03b6910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d0c6211ec93379e4ad6dc520506111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae6d0c6211ec93379e4ad6dc520506111">instr_create_2dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:ae6d0c6211ec93379e4ad6dc520506111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c614653cadce1e2e6e567f3f68de6a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a3c614653cadce1e2e6e567f3f68de6a8">instr_create_2dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:a3c614653cadce1e2e6e567f3f68de6a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711cac2989e3f2fa8fa702ce3b7f8ced"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a711cac2989e3f2fa8fa702ce3b7f8ced">instr_create_2dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:a711cac2989e3f2fa8fa702ce3b7f8ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a608e02e275eb868cd09ba8c454d78b5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a608e02e275eb868cd09ba8c454d78b5d">instr_create_2dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:a608e02e275eb868cd09ba8c454d78b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2926aa0d5305153de5ef57acf84d61d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a2926aa0d5305153de5ef57acf84d61d3">instr_create_2dst_5src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4, <a class="el" href="structopnd__t.html">opnd_t</a> src5)</td></tr>
<tr class="separator:a2926aa0d5305153de5ef57acf84d61d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678839fc8b937d70b63be5fcbbb2d014"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a678839fc8b937d70b63be5fcbbb2d014">instr_create_3dst_0src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3)</td></tr>
<tr class="separator:a678839fc8b937d70b63be5fcbbb2d014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11fe802705f63fee5b0b23b1f5325a2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a11fe802705f63fee5b0b23b1f5325a2f">instr_create_3dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:a11fe802705f63fee5b0b23b1f5325a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f963b19ebe6ff70c0ea8174b53d9ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ae5f963b19ebe6ff70c0ea8174b53d9ed">instr_create_3dst_3src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3)</td></tr>
<tr class="separator:ae5f963b19ebe6ff70c0ea8174b53d9ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32078373abe0c5fb3f97774a936569d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a32078373abe0c5fb3f97774a936569d9">instr_create_3dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:a32078373abe0c5fb3f97774a936569d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee21bbcad5d7ee35f8828ed5244132fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aee21bbcad5d7ee35f8828ed5244132fd">instr_create_3dst_5src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4, <a class="el" href="structopnd__t.html">opnd_t</a> src5)</td></tr>
<tr class="separator:aee21bbcad5d7ee35f8828ed5244132fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b00a25f7ec49fbf943df0e9c667136"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#ab8b00a25f7ec49fbf943df0e9c667136">instr_create_4dst_1src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> dst4, <a class="el" href="structopnd__t.html">opnd_t</a> src)</td></tr>
<tr class="separator:ab8b00a25f7ec49fbf943df0e9c667136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc4452f71c6c14ed6a3a1cd16d19dcf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6fc4452f71c6c14ed6a3a1cd16d19dcf">instr_create_4dst_2src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> dst4, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2)</td></tr>
<tr class="separator:a6fc4452f71c6c14ed6a3a1cd16d19dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd02600b967d24951bc7208b6d70d459"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#abd02600b967d24951bc7208b6d70d459">instr_create_4dst_4src</a> (void *drcontext, int opcode, <a class="el" href="structopnd__t.html">opnd_t</a> dst1, <a class="el" href="structopnd__t.html">opnd_t</a> dst2, <a class="el" href="structopnd__t.html">opnd_t</a> dst3, <a class="el" href="structopnd__t.html">opnd_t</a> dst4, <a class="el" href="structopnd__t.html">opnd_t</a> src1, <a class="el" href="structopnd__t.html">opnd_t</a> src2, <a class="el" href="structopnd__t.html">opnd_t</a> src3, <a class="el" href="structopnd__t.html">opnd_t</a> src4)</td></tr>
<tr class="separator:abd02600b967d24951bc7208b6d70d459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68585d249feac2ed5b9a759a47b2b740"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a68585d249feac2ed5b9a759a47b2b740">instr_create_Ndst_Msrc_varsrc</a> (void *drcontext, int opcode, uint fixed_dsts, uint fixed_srcs, uint var_srcs, uint var_ord,...)</td></tr>
<tr class="separator:a68585d249feac2ed5b9a759a47b2b740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00c1d8dcb83345801ee57fb079e6deef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a00c1d8dcb83345801ee57fb079e6deef">instr_create_Ndst_Msrc_vardst</a> (void *drcontext, int opcode, uint fixed_dsts, uint fixed_srcs, uint var_dsts, uint var_ord,...)</td></tr>
<tr class="separator:a00c1d8dcb83345801ee57fb079e6deef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa554f82d7fa8abd4f38dba90544c20ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#aa554f82d7fa8abd4f38dba90544c20ae">instr_create_popa</a> (void *drcontext)</td></tr>
<tr class="separator:aa554f82d7fa8abd4f38dba90544c20ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418865307bd5bd168cbde4ecd0f785a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a418865307bd5bd168cbde4ecd0f785a5">instr_create_pusha</a> (void *drcontext)</td></tr>
<tr class="separator:a418865307bd5bd168cbde4ecd0f785a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d31d6ba435e8a2f8226f3960248c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#add4d31d6ba435e8a2f8226f3960248c9">instr_is_reg_spill_or_restore</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, bool *tls OUT, bool *spill OUT, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *reg OUT, uint *offs OUT)</td></tr>
<tr class="separator:add4d31d6ba435e8a2f8226f3960248c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6baf5239817b639791916f3cbd6c7b9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#a6baf5239817b639791916f3cbd6c7b9d">instr_disassemble</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, file_t outfile)</td></tr>
<tr class="separator:a6baf5239817b639791916f3cbd6c7b9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ded4a34cef770ecc35e24e61813c8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__ir__instr_8h.html#af67ded4a34cef770ecc35e24e61813c8">instr_disassemble_to_buffer</a> (void *drcontext, <a class="el" href="structinstr__t.html">instr_t</a> *instr, char *buf, size_t bufsz)</td></tr>
<tr class="separator:af67ded4a34cef770ecc35e24e61813c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions to create and manipulate instructions. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ad61b67b227ebe0012829621c25ca65f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_6&#160;&#160;&#160;0x0000011f</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads all 6 arithmetic flags (CF, PF, AF, ZF, SF, OF). </p>

</div>
</div>
<a class="anchor" id="a43c54ddcc858950e361725de7bc870d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_AF&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads AF (Auxiliary Carry Flag). </p>

</div>
</div>
<a class="anchor" id="a88d4ed7d7b9c544c09c395872a86c0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_ALL&#160;&#160;&#160;0x000007ff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads all flags. </p>

</div>
</div>
<a class="anchor" id="aa28e6c817ab3ae8128d862a46b2f037b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_ARITH&#160;&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#ad61b67b227ebe0012829621c25ca65f5">EFLAGS_READ_6</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Platform-independent macro for reads all arithmetic flags. </p>

</div>
</div>
<a class="anchor" id="add002513aebf166b7fdae13d22828d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_CF&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads CF (Carry Flag). </p>

</div>
</div>
<a class="anchor" id="a241f4fe5f01af11fe8e9489fcf84ab4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_DF&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads DF (Direction Flag). </p>

</div>
</div>
<a class="anchor" id="a5a57b4b5098e1ff53bb8a990eec54a14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_IF&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads IF (Interrupt Enable Flag). </p>

</div>
</div>
<a class="anchor" id="a38b847fef029d2aef4ae9f7c79dae0d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_NON_PRED&#160;&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a88d4ed7d7b9c544c09c395872a86c0ea">EFLAGS_READ_ALL</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags not read by predicates. </p>

</div>
</div>
<a class="anchor" id="ab70baddbcff9ed31c328376956f7b0ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_NT&#160;&#160;&#160;0x00000200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads NT (Nested Task). </p>

</div>
</div>
<a class="anchor" id="a5b5f953da018e1530879109cb78095b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_OF&#160;&#160;&#160;0x00000100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads OF (Overflow Flag). </p>

</div>
</div>
<a class="anchor" id="afa533378650b8a86c903410a8abe5789"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_PF&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads PF (Parity Flag). </p>

</div>
</div>
<a class="anchor" id="a14e4b47d88d4014fedaed25482d39b34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_RF&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads RF (Resume Flag). </p>

</div>
</div>
<a class="anchor" id="ae9e0eb52c091f04e29148ca5e7ae2199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_SF&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads SF (Sign Flag). </p>

</div>
</div>
<a class="anchor" id="aebf7d3cf0c4e6b2f39c3a07533419837"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_TF&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads TF (Trap Flag). </p>

</div>
</div>
<a class="anchor" id="afbe5d20458bd272fdeac681706c4bd14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_TO_WRITE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x) &lt;&lt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an EFLAGS_READ_* value to the corresponding EFLAGS_WRITE_* value. </p>

</div>
</div>
<a class="anchor" id="a8385b4d8340260aad30cf5b8455a4efd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_READ_ZF&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads ZF (Zero Flag). </p>

</div>
</div>
<a class="anchor" id="a8287fcf9cd6cd2338a57c54e45b08a7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_6&#160;&#160;&#160;0x0008f800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes all 6 arithmetic flags (CF, PF, AF, ZF, SF, OF). </p>

</div>
</div>
<a class="anchor" id="a9e0d29af655c408ddc915cc07c8ac95e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_AF&#160;&#160;&#160;0x00002000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes AF (Auxiliary Carry Flag). </p>

</div>
</div>
<a class="anchor" id="ab5727b7a5773bace9d656e4b969d7fce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_ALL&#160;&#160;&#160;0x003ff800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes all flags. </p>

</div>
</div>
<a class="anchor" id="a15d3e15ebbf2667f9a2df713b6cbe5ca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_ARITH&#160;&#160;&#160;<a class="el" href="dr__ir__instr_8h.html#a8287fcf9cd6cd2338a57c54e45b08a7f">EFLAGS_WRITE_6</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Platform-independent macor for writes all arithmetic flags. </p>

</div>
</div>
<a class="anchor" id="afafb04c014284b3c4b51b0c6d17be085"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_CF&#160;&#160;&#160;0x00000800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes CF (Carry Flag). </p>

</div>
</div>
<a class="anchor" id="abb180e5ea86b98e6bbd65708e202e6f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_DF&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes DF (Direction Flag). </p>

</div>
</div>
<a class="anchor" id="ab61834da87126c5c1b3b5b89a1bb254e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_IF&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes IF (Interrupt Enable Flag). </p>

</div>
</div>
<a class="anchor" id="a533d9a5cd836be7bd8f831256b9d407e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_NT&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes NT (Nested Task). </p>

</div>
</div>
<a class="anchor" id="a3d8edc641bb696aceadb34b6d5179761"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_OF&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes OF (Overflow Flag). </p>

</div>
</div>
<a class="anchor" id="a302bd46f54cf696a1039c5d25f68bd02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_PF&#160;&#160;&#160;0x00001000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes PF (Parity Flag). </p>

</div>
</div>
<a class="anchor" id="a1ad8fd64cd98ac35c20265b54de97cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_RF&#160;&#160;&#160;0x00200000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes RF (Resume Flag). </p>

</div>
</div>
<a class="anchor" id="a6b5ddab727f9e2c9d49f20bcfd07807b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_SF&#160;&#160;&#160;0x00008000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes SF (Sign Flag). </p>

</div>
</div>
<a class="anchor" id="aac1ee8f92225d554aba043211c34e18b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_TF&#160;&#160;&#160;0x00010000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes TF (Trap Flag). </p>

</div>
</div>
<a class="anchor" id="a2f1cca9ca8d0514a42f66c081f478231"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_TO_READ</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;((x) &gt;&gt; 11)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts an EFLAGS_WRITE_* value to the corresponding EFLAGS_READ_* value. </p>

</div>
</div>
<a class="anchor" id="a5329db528d9d749deae463b9b8edd736"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EFLAGS_WRITE_ZF&#160;&#160;&#160;0x00004000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes ZF (Zero Flag). </p>

</div>
</div>
<a class="anchor" id="a0e6a144b4030140faa950fe65fe9002d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_JCC_NOT_TAKEN&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Branch hint: conditional branch is taken. </p>

</div>
</div>
<a class="anchor" id="a327356db32ce7a884e9a516b2d91b738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_JCC_TAKEN&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Branch hint: conditional branch is not taken. </p>

</div>
</div>
<a class="anchor" id="a697ecea613b828838ff6f08b88adf1d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_LOCK&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes the instruction's memory accesses atomic. </p>

</div>
</div>
<a class="anchor" id="ac3c11ed8105a5cecf5345ab5262a784f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_XACQUIRE&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transaction hint: start lock elision. </p>

</div>
</div>
<a class="anchor" id="aba06eaa86f6bbe22f58a1e2ddffb33da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PREFIX_XRELEASE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transaction hint: end lock elision. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="af29c184442681322a7a77ab2a48ba889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__instr__label__data__t.html">_dr_instr_label_data_t</a>  <a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data slots available in a label (instr_create_label()) instruction for storing client-controlled data. Accessible via <a class="el" href="dr__ir__instr_8h.html#a7eab5eaa85e186349d200a87e8010fec">instr_get_label_data_area()</a>. </p>

</div>
</div>
<a class="anchor" id="ab02e5d9677a934f4c981d58d435d4b65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cd">_dr_opnd_query_flags_t</a>  <a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bitmask values passed as flags to routines that ask about whether operands and condition codes are read or written. These flags determine how to treat conditionally executed instructions. As a special case, the addressing registers inside a destination memory operand are covered by DR_QUERY_INCLUDE_COND_SRCS rather than DR_QUERY_INCLUDE_COND_DSTS. </p>

</div>
</div>
<a class="anchor" id="a4f7ea3616bfa61f7269cdd33086a70f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772">_dr_pred_trigger_t</a>  <a class="el" href="dr__ir__instr_8h.html#a4f7ea3616bfa61f7269cdd33086a70f4">dr_pred_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type holds the return values for <a class="el" href="dr__ir__instr_8h.html#a284a0bdc5a1cc7a841a061edd4d37c7d">instr_predicate_triggered()</a>. </p>

</div>
</div>
<a class="anchor" id="a27cda70ebaed7e6872a63c7316917d70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71">_dr_pred_type_t</a>  <a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers used for conditionally executed instructions. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The actual bits in the eflags register that we care about:<br />
</p><pre>
  11 10  9  8  7  6  5  4  3  2  1  0
  OF DF IF TF SF ZF  0 AF  0 PF  1 CF  </pre> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9aef9a85103f89f1abdcbc577177fe59dc"></a>EFLAGS_CF&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of CF (Carry Flag). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9abd82d6f3c93948e598947c3e60c5ffbe"></a>EFLAGS_PF&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of PF (Parity Flag). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9ae02f888626e1c77d3dadb0c69c4ccebe"></a>EFLAGS_AF&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of AF (Aux Carry Flag). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9aeb567fc9958d98e114e2aed3f73e6cf1"></a>EFLAGS_ZF&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of ZF (Zero Flag). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9a607506a5fd2d021972d2f7ecb397960f"></a>EFLAGS_SF&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of SF (Sign Flag). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9ad3cf0d7affac2713bfcb915f809200da"></a>EFLAGS_DF&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of DF (Direction Flag). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9ad4d56500271d500e241e46fdd7fdddb4"></a>EFLAGS_OF&#160;</td><td class="fielddoc">
<p>The bit in the eflags register of OF (Overflow Flag). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aae05225933a42f81e7c4a9fb286596f9a8e0641c833e66b6787c36170b3484a01"></a>EFLAGS_ARITH&#160;</td><td class="fielddoc">
<p>The bits in the eflags register of CF, PF, AF, ZF, SF, OF. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="add920ca9228d3e1daff67e0975a2e8cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__instr_8h.html#add920ca9228d3e1daff67e0975a2e8cd">_dr_opnd_query_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Bitmask values passed as flags to routines that ask about whether operands and condition codes are read or written. These flags determine how to treat conditionally executed instructions. As a special case, the addressing registers inside a destination memory operand are covered by DR_QUERY_INCLUDE_COND_SRCS rather than DR_QUERY_INCLUDE_COND_DSTS. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="add920ca9228d3e1daff67e0975a2e8cda97f20c43f26eb78a236c8e7ae031c8c6"></a>DR_QUERY_INCLUDE_COND_DSTS&#160;</td><td class="fielddoc">
<p>By default, routines that take in these flags will only consider destinations that are always written. Thus, all destinations are skipped for an instruction that is predicated and executes conditionally (see <a class="el" href="dr__ir__instr_8h.html#a8d25cfd2ef6384b820b244fbb45dfb27">instr_is_predicated()</a>). If this flag is set, a conditionally executed instruction's destinations are included just like any other instruction's. As a special case, the addressing registers inside a destination memory operand are covered by DR_QUERY_INCLUDE_COND_SRCS rather than this flag. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add920ca9228d3e1daff67e0975a2e8cda9c231d02d0dbfbfe89d01f69ed25f34d"></a>DR_QUERY_INCLUDE_COND_SRCS&#160;</td><td class="fielddoc">
<p>By default, routines that take in these flags will only consider sources that are always read. Thus, all sources are skipped for an instruction that is predicated and executes conditionally (see <a class="el" href="dr__ir__instr_8h.html#a8d25cfd2ef6384b820b244fbb45dfb27">instr_is_predicated()</a>), except for predication conditions that involve the source operand values. If this flag is set, a conditionally executed instruction's sources are included just like any other instruction's. As a special case, the addressing registers inside a destination memory operand are covered by this flag rather than DR_QUERY_INCLUDE_COND_DSTS. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add920ca9228d3e1daff67e0975a2e8cda5d5d0aac79cc4d1dbac875ae0a9f5a4e"></a>DR_QUERY_DEFAULT&#160;</td><td class="fielddoc">
<p>The default value that typical liveness analysis would want to use. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="add920ca9228d3e1daff67e0975a2e8cdaf795696f4e8d1b5a5aa446c717e6739b"></a>DR_QUERY_INCLUDE_ALL&#160;</td><td class="fielddoc">
<p>Includes all operands whether conditional or not. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a8c0ff6068a163a5cd113771ef5ee7772"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__instr_8h.html#a8c0ff6068a163a5cd113771ef5ee7772">_dr_pred_trigger_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type holds the return values for <a class="el" href="dr__ir__instr_8h.html#a284a0bdc5a1cc7a841a061edd4d37c7d">instr_predicate_triggered()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8c0ff6068a163a5cd113771ef5ee7772ae46430e5d5de989c13928bdda20229b3"></a>DR_PRED_TRIGGER_NOPRED&#160;</td><td class="fielddoc">
<p>This instruction is not predicated. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8c0ff6068a163a5cd113771ef5ee7772a04609c78333a6147ebb6bb8814183922"></a>DR_PRED_TRIGGER_MATCH&#160;</td><td class="fielddoc">
<p>The predicate matches and the instruction will execute. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8c0ff6068a163a5cd113771ef5ee7772a0bf091d9f7128fdc9591f566b177b0c1"></a>DR_PRED_TRIGGER_MISMATCH&#160;</td><td class="fielddoc">
<p>The predicate does not match and the instruction will not execute. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8c0ff6068a163a5cd113771ef5ee7772ab472d01df9fead8c13beaf75da010400"></a>DR_PRED_TRIGGER_UNKNOWN&#160;</td><td class="fielddoc">
<p>It is unknown whether the predicate matches. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8c0ff6068a163a5cd113771ef5ee7772a36d7eb98d337bb458d3afd3f2c902787"></a>DR_PRED_TRIGGER_INVALID&#160;</td><td class="fielddoc">
<p>An invalid parameter was passed. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ac55eea34836068d8d66196c3f1556d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71">_dr_pred_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers used for conditionally executed instructions. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71ad94a882e075b12c0e4e6e5f852e4e4b2"></a>DR_PRED_NONE&#160;</td><td class="fielddoc">
<p>No predicate is present. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a73fe4e68d99f10cbef5cd9e22fd23577"></a>DR_PRED_O&#160;</td><td class="fielddoc">
<p>x86 condition: overflow (OF=1). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a55f11d7f40baaa33ff1224d9b3d94210"></a>DR_PRED_NO&#160;</td><td class="fielddoc">
<p>x86 condition: no overflow (OF=0). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71ad15eddf8665676a15deedc5878f2c3bf"></a>DR_PRED_B&#160;</td><td class="fielddoc">
<p>x86 condition: below (CF=1). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a9e7e5cd4c46dfcd0524c89f97c5e5381"></a>DR_PRED_NB&#160;</td><td class="fielddoc">
<p>x86 condition: not below (CF=0). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a2bcac2d1e198e4708a2a08f4e429f748"></a>DR_PRED_Z&#160;</td><td class="fielddoc">
<p>x86 condition: zero (ZF=1). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71add0fb2af7372312d49ec62cd1705f046"></a>DR_PRED_NZ&#160;</td><td class="fielddoc">
<p>x86 condition: not zero (ZF=0). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a3afd847eebcbed1bb9695858727b5e57"></a>DR_PRED_BE&#160;</td><td class="fielddoc">
<p>x86 condition: below or equal (CF=1 or ZF=1). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a1286e03cd056a94201c46f3ed416074d"></a>DR_PRED_NBE&#160;</td><td class="fielddoc">
<p>x86 condition: not below or equal (CF=0 and ZF=0). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a0f3659e2b77ec4c3bf765394e14cea18"></a>DR_PRED_S&#160;</td><td class="fielddoc">
<p>x86 condition: sign (SF=1). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a1d73b15fb50af162b86ecfdca21cb067"></a>DR_PRED_NS&#160;</td><td class="fielddoc">
<p>x86 condition: not sign (SF=0). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a6f0cd6c3f9706dd5b6abe4baeaf385b5"></a>DR_PRED_P&#160;</td><td class="fielddoc">
<p>x86 condition: parity (PF=1). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71aba0e448a0a4bcf4de31e28a61c46e96b"></a>DR_PRED_NP&#160;</td><td class="fielddoc">
<p>x86 condition: not parity (PF=0). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a75f5f1a12d5b7707b7c3279bb71f7384"></a>DR_PRED_L&#160;</td><td class="fielddoc">
<p>x86 condition: less (SF != OF). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71a6c14dd778a1f20408247ab7948d9e3e6"></a>DR_PRED_NL&#160;</td><td class="fielddoc">
<p>x86 condition: not less (SF=OF). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71accf763617376a3a85588d6a79e601dfe"></a>DR_PRED_LE&#160;</td><td class="fielddoc">
<p>x86 condition: less or equal (ZF=1 or SF != OF). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71aecaeb5a9b0412fcd97706330b3d03758"></a>DR_PRED_NLE&#160;</td><td class="fielddoc">
<p>x86 condition: not less or equal (ZF=0 and SF=OF). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ac55eea34836068d8d66196c3f1556d71ade60058c0eb6909b05024f9728c6b9bc"></a>DR_PRED_COMPLEX&#160;</td><td class="fielddoc">
<p>x86 condition: special opcode-specific condition that depends on the values of the source operands. Thus, unlike all of the other conditions, the source operands will be accessed even if the condition then fails and the destinations are not touched. Any written eflags are unconditionally written, unlike regular destination operands. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates which type of floating-point operation and instruction performs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba47d09b15b2ec78db7ce84ae6ddf333b0"></a>DR_FP_STATE&#160;</td><td class="fielddoc">
<p>Loads, stores, or queries general floating point state. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba973de5b2ea84fb3da6db3e2b5f8ec5e3"></a>DR_FP_MOVE&#160;</td><td class="fielddoc">
<p>Moves floating point values from one location to another. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba24a7a4e2a7b4558a1e2a26b690c5b6c7"></a>DR_FP_CONVERT&#160;</td><td class="fielddoc">
<p>Converts to or from floating point values. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a192e9ddf90889e6de003d95ebdaa7beba20c0efa9e59f5424338edcbae638c6d3"></a>DR_FP_MATH&#160;</td><td class="fielddoc">
<p>Performs arithmetic or conditional operations. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af7b33f34d4dd11993224b4fb10e136dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_allocate_raw_bits </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>num_bytes</code> of memory for <code>instr's</code> raw bits. If <code>instr</code> currently points to raw bits, the allocated memory is initialized with the bytes pointed to. <code>instr</code> is then set to point to the allocated memory. </p>

</div>
</div>
<a class="anchor" id="a88ef462712287c564d125a71383a09c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_build </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_srcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine: calls</p><ul>
<li>instr_create(dcontext)</li>
<li>instr_set_opcode(opcode)</li>
<li>instr_set_num_opnds(dcontext, instr, num_dsts, num_srcs)</li>
</ul>
<p>and returns the resulting <a class="el" href="structinstr__t.html">instr_t</a>. </p>

</div>
</div>
<a class="anchor" id="a947d5940c5e43001ee44577a05d433f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_build_bits </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine: calls</p><ul>
<li>instr_create(dcontext)</li>
<li>instr_set_opcode(instr, opcode)</li>
<li>instr_allocate_raw_bits(dcontext, instr, num_bytes)</li>
</ul>
<p>and returns the resulting <a class="el" href="structinstr__t.html">instr_t</a>. </p>

</div>
</div>
<a class="anchor" id="af8c874bf0f8b67dd6a85f2d54c1e87dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_clone </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>orig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a copy of <code>orig</code> with separately allocated memory for operands and raw bytes if they were present in <code>orig</code>. Only a shallow copy of the <code>note</code> field is made. </p>

</div>
</div>
<a class="anchor" id="a222195624605490e7844ed3737ad3668"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_cmovcc_to_jcc </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cmovcc_opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a cmovcc opcode <code>cmovcc_opcode</code> to the OP_jcc opcode that tests the same bits in eflags. </p>

</div>
</div>
<a class="anchor" id="a238dc0a1168701e30a95b57dd0c845a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_cmovcc_triggered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>eflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>eflags</code>, returns whether or not the conditional move instruction <code>instr</code> would execute the move. The conditional move can be an OP_cmovcc or an OP_fcmovcc instruction. </p>

</div>
</div>
<a class="anchor" id="aa13ec559a17ab70816f80de784e5632f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_compute_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns NULL if none of <code>instr's</code> operands is a memory reference. Otherwise, returns the effective address of the first memory operand when the operands are considered in this order: destinations and then sources. The address is computed using the passed-in registers. <code>mc-&gt;flags</code> must include DR_MC_CONTROL and DR_MC_INTEGER. For instructions that use vector addressing (VSIB, introduced in AVX2), mc-&gt;flags must additionally include DR_MC_MULTIMEDIA.</p>
<p>Like <a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory()</a>, this routine does not consider multi-byte nops that use addressing operands, or the <a class="el" href="dr__ir__opcodes__x86_8h.html#a94798fdadfbf49a7c658ace669a1d310a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction's source operand, to be memory references. </p>

</div>
</div>
<a class="anchor" id="aa04322a189dd7f17ab245594e02cc6a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_compute_address_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs address calculation in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address()</a> but handles multiple memory operands. The <code>index</code> parameter should be initially set to 0 and then incremented with each successive call until this routine returns false, which indicates that there are no more memory operands. The address of each is computed in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa13ec559a17ab70816f80de784e5632f">instr_compute_address()</a> and returned in <code>addr</code>; whether it is a write is returned in <code>is_write</code>. Either or both OUT variables can be NULL. <code>mc-&gt;flags</code> must include DR_MC_CONTROL and DR_MC_INTEGER. For instructions that use vector addressing (VSIB, introduced in AVX2), mc-&gt;flags must additionally include DR_MC_MULTIMEDIA.</p>
<p>Like <a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory()</a>, this routine does not consider multi-byte nops that use addressing operands, or the <a class="el" href="dr__ir__opcodes__x86_8h.html#a94798fdadfbf49a7c658ace669a1d310a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction's source operand, to be memory references. </p>

</div>
</div>
<a class="anchor" id="a25107e1fb5a49de3c627b70acc7b2eef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_compute_address_ex_pos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT app_pc *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT bool *&#160;</td>
          <td class="paramname"><em>is_write</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs address calculation in the same manner as <a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex()</a> with additional information of which opnd is used for address computation returned in <code>pos</code>. If <code>pos</code> is NULL, it is the same as <a class="el" href="dr__ir__instr_8h.html#aa04322a189dd7f17ab245594e02cc6a8">instr_compute_address_ex()</a>.</p>
<p>Like <a class="el" href="dr__ir__instr_8h.html#ae408fe229bea0aa800cddb6b911c0e94">instr_reads_memory()</a>, this routine does not consider multi-byte nops that use addressing operands, or the <a class="el" href="dr__ir__opcodes__x86_8h.html#a94798fdadfbf49a7c658ace669a1d310a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction's source operand, to be memory references. </p>

</div>
</div>
<a class="anchor" id="a33a349e086f96bb03bd6700129dc6135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_convert_short_meta_jmp_to_long </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that instr is a meta instruction (<a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta()</a>) and an <a class="el" href="dr__ir__instr_8h.html#a2782471943558d57296b89a3f41a530d">instr_is_cti_short()</a> (&lt;=8-bit reach). Converts instr's opcode to a long form (32-bit reach for x86). If instr's opcode is OP_loop* or OP_jecxz for x86 or OP_cbnz or OP_cbz for ARM, converts it to a sequence of multiple instructions (which is different from <a class="el" href="dr__ir__instr_8h.html#a8c61714f2632d46211d61ebb55d4bbde">instr_is_cti_short_rewrite()</a>). Each added instruction is marked <a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta()</a>. Returns the long form of the instruction, which is identical to <code>instr</code> unless <code>instr</code> is OP_{loop*,jecxz,cbnz,cbz}, in which case the return value is the final instruction in the sequence, the one that has long reach. </p><dl class="section note"><dt>Note</dt><dd>DR automatically converts app short ctis to long form. </dd></dl>

</div>
</div>
<a class="anchor" id="a65f53f3c43c91833faf11b5e6cd9e905"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap. Sets the x86/x64 mode of the returned <a class="el" href="structinstr__t.html">instr_t</a> to the mode of dcontext. </p>

</div>
</div>
<a class="anchor" id="ac00a75c880108dde16b137370be5cedb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and no sources or destinations. </p>

</div>
</div>
<a class="anchor" id="ad3835ac2d78ba9b90e1ced9c58cada5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and a single source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="a54d0c2cbad95bfe24daade84c6add8af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a21033066f65f8dfd23ca24215ea99b70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="ae11b0fd63ac17f6054ad2834f900b536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_0dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="a4db9f5f8dfd216fab6e9153170fb479f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code> and one destination (<code>dst</code>). </p>

</div>
</div>
<a class="anchor" id="a0202b3cf63b50d16947f6be6f2b00891"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination(<code>dst</code>), and one source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="ac469b18246e67b23f758c636f460d8ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a4a34019f73e797090b3ab9625cdbc5fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a39dacd6683dce94ed6cddd249c0432f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="a4e5a5241276ad8d2f392c7a1432efb61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_1dst_5src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, one destination (<code>dst</code>), and five sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>, <code>src5</code>). </p>

</div>
</div>
<a class="anchor" id="aeadd422dcd43564d40b43ca0e03b6910"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and no sources. </p>

</div>
</div>
<a class="anchor" id="ae6d0c6211ec93379e4ad6dc520506111"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and one source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="a3c614653cadce1e2e6e567f3f68de6a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="a711cac2989e3f2fa8fa702ce3b7f8ced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a608e02e275eb868cd09ba8c454d78b5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="a2926aa0d5305153de5ef57acf84d61d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_2dst_5src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, two destinations (<code>dst1</code>, <code>dst2</code>) and five sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>, <code>src5</code>). </p>

</div>
</div>
<a class="anchor" id="a678839fc8b937d70b63be5fcbbb2d014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_0src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and no sources. </p>

</div>
</div>
<a class="anchor" id="a11fe802705f63fee5b0b23b1f5325a2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and two sources (<code>src1</code>, <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="ae5f963b19ebe6ff70c0ea8174b53d9ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_3src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and three sources (<code>src1</code>, <code>src2</code>, <code>src3</code>). </p>

</div>
</div>
<a class="anchor" id="a32078373abe0c5fb3f97774a936569d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="aee21bbcad5d7ee35f8828ed5244132fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_3dst_5src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src5</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, three destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>) and five sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>, <code>src5</code>). </p>

</div>
</div>
<a class="anchor" id="ab8b00a25f7ec49fbf943df0e9c667136"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_4dst_1src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, four destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>, <code>dst4</code>) and 1 source (<code>src</code>). </p>

</div>
</div>
<a class="anchor" id="a6fc4452f71c6c14ed6a3a1cd16d19dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_4dst_2src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, four destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>, <code>dst4</code>) and 2 sources (<code>src1</code> and <code>src2</code>). </p>

</div>
</div>
<a class="anchor" id="abd02600b967d24951bc7208b6d70d459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_4dst_4src </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>dst4</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>src4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, four destinations (<code>dst1</code>, <code>dst2</code>, <code>dst3</code>, <code>dst4</code>) and four sources (<code>src1</code>, <code>src2</code>, <code>src3</code>, <code>src4</code>). </p>

</div>
</div>
<a class="anchor" id="a00c1d8dcb83345801ee57fb079e6deef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_Ndst_Msrc_vardst </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>fixed_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>fixed_srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>var_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>var_ord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, <code>fixed_dsts</code> plus <code>var_dsts</code> destination operands, and <code>fixed_srcs</code> source operands. The variable arguments must start with the fixed destinations, followed by the (fixed) sources, followed by the variable destinations. The <code>var_ord</code> parameter specifies the (0-based) ordinal position within the resulting instruction's destination array at which the variable destinations should be placed, allowing them to be inserted in the middle of the fixed destinations. </p>

</div>
</div>
<a class="anchor" id="a68585d249feac2ed5b9a759a47b2b740"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_Ndst_Msrc_varsrc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>fixed_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>fixed_srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>var_srcs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>var_ord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> allocated on the thread-local heap with opcode <code>opcode</code>, <code>fixed_dsts</code> destination operands, and <code>fixed_srcs</code> plus <code>var_srcs</code> source operands. The variable arguments must start with the (fixed) destinations, followed by the fixed sources, followed by the variable sources. The <code>var_ord</code> parameter specifies the (0-based) ordinal position within the resulting instruction's source array at which the variable sources should be placed, allowing them to be inserted in the middle of the fixed sources. </p>

</div>
</div>
<a class="anchor" id="aa554f82d7fa8abd4f38dba90544c20ae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_popa </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> for OP_popa. </p>

</div>
</div>
<a class="anchor" id="a418865307bd5bd168cbde4ecd0f785a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_create_pusha </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience routine that returns an initialized <a class="el" href="structinstr__t.html">instr_t</a> for OP_pusha. </p>

</div>
</div>
<a class="anchor" id="acb082bbf9ac73968667b79b4cd14d73f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs <a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free()</a> and then deallocates the thread-local heap storage for <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a6baf5239817b639791916f3cbd6c7b9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_disassemble </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>outfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the instruction <code>instr</code> to file <code>outfile</code>. Does not print address-size or data-size prefixes for other than just-decoded instrs, and does not check that the instruction has a valid encoding. Prints each operand with leading zeros indicating the size. The default is to use DR's custom syntax (see <a class="el" href="dr__ir__utils_8h.html#a3082c5db55039c72ae30e3276f622aae">disassemble_set_syntax()</a>). </p>

</div>
</div>
<a class="anchor" id="af67ded4a34cef770ecc35e24e61813c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t instr_disassemble_to_buffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints the instruction <code>instr</code> to the buffer <code>buf</code>. Always null-terminates, and will not print more than <code>bufsz</code> characters, which includes the final null character. Returns the number of characters printed, not including the final null.</p>
<p>Does not print address-size or data-size prefixes for other than just-decoded instrs, and does not check that the instruction has a valid encoding. Prints each operand with leading zeros indicating the size. The default is to use DR's custom syntax (see <a class="el" href="dr__ir__utils_8h.html#a3082c5db55039c72ae30e3276f622aae">disassemble_set_syntax()</a>). </p>

</div>
</div>
<a class="anchor" id="a1cd4d0740eb0a0bcd2d387685719263c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_encode </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>pc</code>. Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p><dl class="section note"><dt>Note</dt><dd>: In Thumb mode, some instructions have different behavior depending on whether they are in an IT block. To correctly encode such instructions, they should be encoded within an instruction list with the corresponding IT instruction using <a class="el" href="dr__ir__instrlist_8h.html#aaac5ae2bc9af179b56bbbe5efc14e8b5">instrlist_encode()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5356c2dd3388496158fa0a918f8c2a53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_encode_to_copy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>copy_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>final_pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes <code>instr</code> into the memory at <code>copy_pc</code> in preparation for copying to <code>final_pc</code>. Any pc-relative component is encoded as though the instruction were located at <code>final_pc</code>. This allows for direct copying of the encoded bytes to <code>final_pc</code> without re-relativization.</p>
<p>Uses the x86/x64 mode stored in instr, not the mode of the current thread. Returns the pc after the encoded instr, or NULL if the encoding failed. If instr is a cti with an <a class="el" href="structinstr__t.html">instr_t</a> target, the note fields of instr and of the target must be set with the respective offsets of each instr_t! (instrlist_encode does this automatically, if the target is in the list). x86 instructions can occupy up to 17 bytes, so the caller should ensure the target location has enough room to avoid overflow. </p><dl class="section note"><dt>Note</dt><dd>: In Thumb mode, some instructions have different behavior depending on whether they are in an IT block. To correctly encode such instructions, they should be encoded within an instruction list with the corresponding IT instruction using <a class="el" href="dr__ir__instrlist_8h.html#aaac5ae2bc9af179b56bbbe5efc14e8b5">instrlist_encode()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae0f3cc7fb91265cb6c8eb15a84184c1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deallocates all memory that was allocated by <code>instr</code>. This includes raw bytes allocated by <a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits()</a> and operands allocated by <a class="el" href="dr__ir__instr_8h.html#aee0d80a8e69e8f0abe867f1903a107ea">instr_set_num_opnds()</a>. Does not deallocate the storage for <code>instr</code> itself. </p>

</div>
</div>
<a class="anchor" id="aa7af19aa3aadf7b05900a39ef62b01b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_free_raw_bits </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>instr</code> has raw bits allocated, frees them. </p>

</div>
</div>
<a class="anchor" id="a57dbc129ab88dfdcf49f1105eba394a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_get_app_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the original application PC of <code>instr</code> if it exists. </p>

</div>
</div>
<a class="anchor" id="a362aa1ce2cc38c3e3754c44ad976dca8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_arith_flags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> arithmetic flags (bottom 6 eflags) use as EFLAGS_ constants (e.g., EFLAGS_READ_CF, EFLAGS_WRITE_OF, etc.) or'ed together. If <code>instr's</code> eflags behavior has not been calculated yet or is invalid, the entire eflags use is calculated and returned (not just the arithmetic flags). Which eflags are considered to be accessed for conditionally executed instructions are controlled by <code>flags</code>. </p>

</div>
</div>
<a class="anchor" id="ab4c178ef16a57aa4c89976cb11419719"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc instr_get_branch_target_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the taken target pc of the (direct branch) instruction. </p>

</div>
</div>
<a class="anchor" id="aed999847d48a5a9eb1032239a660e398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> destination operand at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="a2ad68b83f3990306d6af6b5a66447038"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_eflags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> eflags use as EFLAGS_ constants (e.g., EFLAGS_READ_CF, EFLAGS_WRITE_OF, etc.) or'ed together. Which eflags are considered to be accessed for conditionally executed instructions are controlled by <code>flags</code>. </p>

</div>
</div>
<a class="anchor" id="a784fcd66cdda36aaf218121f1b75ab2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_interrupt_number </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> opcode is OP_int and that either <code>instr's</code> operands or its raw bits are valid. Returns the first source operand if <code>instr's</code> operands are valid, else if <code>instr's</code> raw bits are valid returns the first raw byte. </p>

</div>
</div>
<a class="anchor" id="ac086123f4336dac9783232c87ba7e52c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__utils_8h.html#a83ebdc7f73d889146aaf9f6ea7865d94">dr_isa_mode_t</a> instr_get_isa_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each instruction stores the processor mode under which it should be interpreted. This routine returns the mode for <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a7eab5eaa85e186349d200a87e8010fec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__instr_8h.html#af29c184442681322a7a77ab2a48ba889">dr_instr_label_data_t</a>* instr_get_label_data_area </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>a pointer to user-controlled data fields in a label instruction. These fields are available for use by clients for their own purposes. Returns NULL if <code>instr</code> is not a label instruction. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>These data fields are copied (shallowly) across <a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a11b5b0700f7601087e2fda87175040"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a>* instr_get_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next <a class="el" href="structinstr__t.html">instr_t</a> in the instrlist_t that contains <code>instr</code>. </p><dl class="section note"><dt>Note</dt><dd>The next pointer for an <a class="el" href="structinstr__t.html">instr_t</a> is inside the <a class="el" href="structinstr__t.html">instr_t</a> data structure itself, making it impossible to have on <a class="el" href="structinstr__t.html">instr_t</a> in two different InstrLists (but removing the need for an extra data structure for each element of the instrlist_t). </dd></dl>

</div>
</div>
<a class="anchor" id="a1114903afc8f9a3539aed43330117627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a>* instr_get_next_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next application (non-meta) instruction in the instruction list that contains <code>instr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>As opposed to <a class="el" href="dr__ir__instr_8h.html#a9a11b5b0700f7601087e2fda87175040">instr_get_next()</a>, this routine skips all meta instructions inserted by either DynamoRIO or its clients.</dd>
<dd>
We recommend using this routine during the phase of application code analysis, as any meta instructions present are guaranteed to be ok to skip. However, caution should be exercised if using this routine after any instrumentation insertion has already happened, as instrumentation might affect register usage or other factors being analyzed. </dd></dl>

</div>
</div>
<a class="anchor" id="a776a1fd0cf8f783b2a969a24432fee6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void* instr_get_note </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the value of the user-controlled note field in <code>instr</code>. </p><dl class="section note"><dt>Note</dt><dd>Important: is also used when emitting for targets that are other instructions. Thus it will be overwritten when calling <a class="el" href="dr__ir__instrlist_8h.html#aaac5ae2bc9af179b56bbbe5efc14e8b5">instrlist_encode()</a> or <a class="el" href="dr__ir__instrlist_8h.html#a8ae48a113e137b95cd3499f9fa57f5ea">instrlist_encode_to_copy()</a> with <code>has_instr_jmp_targets</code> set to true. </dd>
<dd>
The note field is copied (shallowly) by <a class="el" href="dr__ir__instr_8h.html#af8c874bf0f8b67dd6a85f2d54c1e87dc">instr_clone()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a90d36984352b073089da3c91b901c853"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> opcode (an OP_ constant). </p>

</div>
</div>
<a class="anchor" id="a749df373b340acb6437fea2f02b2fe69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_opcode_eflags </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the eflags usage of instructions with opcode <code>opcode</code>, as EFLAGS_ constants (e.g., EFLAGS_READ_CF, EFLAGS_WRITE_OF, etc.) or'ed together. If <code>opcode</code> is predicated (see <a class="el" href="dr__ir__instr_8h.html#a8d25cfd2ef6384b820b244fbb45dfb27">instr_is_predicated()</a>) or if the set of flags read or written varies with an operand value, this routine returns the maximal set that might be accessed or written. </p>

</div>
</div>
<a class="anchor" id="a7a1ba8cfdd319503cf12d0af2dd217c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> instr_get_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the DR_PRED_ constant for <code>instr</code> that describes what its conditional execution is dependent on. </p>

</div>
</div>
<a class="anchor" id="a3722cd7a5b3728b5edeefd4b07bd456c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_prefix_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>prefix</code> is a PREFIX_ constant. Returns true if <code>instr's</code> prefixes contain the flag <code>prefix</code>. </p>

</div>
</div>
<a class="anchor" id="a1432bded4f063c3c9d41f1a798f703b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a>* instr_get_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the previous <a class="el" href="structinstr__t.html">instr_t</a> in the instrlist_t that contains <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a520a1d1ef99a993196fb1bd54aebd7df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE <a class="el" href="structinstr__t.html">instr_t</a>* instr_get_prev_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the previous application (non-meta) instruction in the instruction list that contains <code>instr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>As opposed to <a class="el" href="dr__ir__instr_8h.html#a1432bded4f063c3c9d41f1a798f703b0">instr_get_prev()</a>, this routine skips all meta instructions inserted by either DynamoRIO or its clients.</dd>
<dd>
We recommend using this routine during the phase of application code analysis, as any meta instructions present are guaranteed to be ok to skip. However, caution should be exercised if using this routine after any instrumentation insertion has already happened, as instrumentation might affect register usage or other factors being analyzed. </dd></dl>

</div>
</div>
<a class="anchor" id="a964928ee44090aba9aef343c5d34df5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* instr_get_raw_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid. Returns a pointer to <code>instr's</code> raw bits. </p><dl class="section note"><dt>Note</dt><dd>A freshly-decoded instruction has valid raw bits that point to the address from which it was decoded. However, for instructions presented in the basic block or trace events, use <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc()</a> to retrieve the corresponding application address, as the raw bits will not be set for instructions added after decoding, and may point to a different location for insructions that have been modified. </dd></dl>

</div>
</div>
<a class="anchor" id="af8d41e2a8da7c0ef207d269020053ecc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte instr_get_raw_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and have &gt; <code>pos</code> bytes. Returns a pointer to <code>instr's</code> raw byte at position <code>pos</code> (beginning with 0). </p>

</div>
</div>
<a class="anchor" id="ae0d1b19bf4e736c6f361164a295160a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_get_raw_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and have &gt; <code>pos</code> + 3 bytes. Returns the 4 bytes beginning at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="ae9e4c9cbe4890f8e37af9e299affc86c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_rel_addr_dst_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If any of <code>instr's</code> destination operands is a rip-relative memory reference, returns the operand position. If there is no such destination operand, returns -1.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a8942eef70af97b8018b31df431ef1822"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_get_rel_addr_src_idx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If any of <code>instr's</code> source operands is a rip-relative memory reference, returns the operand position. If there is no such source operand, returns -1.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a19b43ab8c3edd905329429075e91ea1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_rel_addr_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc *&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If any of <code>instr's</code> operands is a rip-relative memory reference, returns the address that reference targets. Else returns false.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="aa60219f08461b9bc143214c937893d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns <code>instr's</code> source operand at position <code>pos</code> (0-based). </p>

</div>
</div>
<a class="anchor" id="a6ff26384b57a52838dbd9b854db44cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> instr_get_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>cti_instr</code> is a control transfer instruction Returns the first source operand of <code>cti_instr</code> (its target). </p>

</div>
</div>
<a class="anchor" id="acf3a5a5abd40c0c0694f037fcfac5705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_get_x86_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <code>instr</code> is an x86 instruction (32-bit) and false if <code>instr</code> is an x64 instruction (64-bit).</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="dr__ir__instr_8h.html#ac086123f4336dac9783232c87ba7e52c">instr_get_isa_mode()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="add5ea7e7d0387d7d1461830c1e5253c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_has_allocated_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> has its own allocated memory for raw bits. </p>

</div>
</div>
<a class="anchor" id="a7c2b7bfe6c9670ac127a24ea7aef33d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_has_rel_addr_reference </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff any of <code>instr's</code> operands is a rip-relative memory reference.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a77b55daa2b3780d2c07e33b8330b2f62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_init </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes <code>instr</code>. Sets the x86/x64 mode of <code>instr</code> to the mode of dcontext. </p>

</div>
</div>
<a class="anchor" id="acc25aa34b90fcf0cdcfdbd8028464274"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_invert_cbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> is a conditional branch instruction Reverses the logic of <code>instr's</code> conditional e.g., changes OP_jb to OP_jnb. Works on cti_short_rewrite as well. </p>

</div>
</div>
<a class="anchor" id="a506a5fb59ed91706a99dd15d60f63234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> instr_invert_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the DR_PRED_ constant that represents the opposite condition from <code>pred</code>. A valid conditional branch predicate must be passed (i.e., not <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ad94a882e075b12c0e4e6e5f852e4e4b2">DR_PRED_NONE</a>, DR_PRED_AL, or DR_PRED_OP). </p><dl class="section note"><dt>Note</dt><dd>ARM-only. </dd></dl>

</div>
</div>
<a class="anchor" id="afa10a8067ef7d4b13f6f5bcc7a0160b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_3DNow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of AMD's 3D-Now! instructions. </p>

</div>
</div>
<a class="anchor" id="a5e6d7eea24e55c4a4851ab4e3c0aa108"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE bool instr_is_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is an application (non-meta) instruction (see <a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app()</a> for more information). </p>

</div>
</div>
<a class="anchor" id="a9d347723617986e9424b042cb69495e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call, OP_call_far, OP_call_ind, or OP_call_far_ind on x86; OP_bl, OP_blx, or OP_blx_ind on ARM. </p>

</div>
</div>
<a class="anchor" id="a5cb0fc26f65991c24002df14abb7e461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call or OP_call_far. </p>

</div>
</div>
<a class="anchor" id="a1fe1cc575e2870720ceee8ce134771f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_call_indirect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call_ind or OP_call_far_ind on x86; OP_blx_ind on ARM. </p>

</div>
</div>
<a class="anchor" id="a006c261a813d4e91fc25c549e5ebbb8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a conditional branch: OP_jcc, OP_jcc_short, OP_loop*, or OP_jecxz on x86; OP_cbnz, OP_cbz, or when a predicate is present any of OP_b, OP_b_short, OP_bx, OP_bxj, OP_bl, OP_blx, OP_blx_ind on ARM. </p>

</div>
</div>
<a class="anchor" id="a076d0445255d4902181cb272bacd80aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a control transfer instruction of any kind This includes OP_jcc, OP_jcc_short, OP_loop*, OP_jecxz, OP_call*, and OP_jmp*. </p>

</div>
</div>
<a class="anchor" id="a4af759611c486c5ac9e1a5336a809661"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is one of OP_loop* or OP_jecxz. </p>

</div>
</div>
<a class="anchor" id="a2782471943558d57296b89a3f41a530d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a control transfer instruction that takes an 8-bit offset on x86 (OP_loop*, OP_jecxz, OP_jmp_short, or OP_jcc_short) or a small offset on ARM (OP_cbz, OP_cbnz, OP_b_short). </p>

</div>
</div>
<a class="anchor" id="a8c61714f2632d46211d61ebb55d4bbde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_cti_short_rewrite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_loop* or OP_jecxz on x86 or OP_cbz or OP_cbnz on ARM and instr has been transformed to a sequence of instruction that will allow a larger offset. If <code>pc</code> != NULL, <code>pc</code> is expected to point to the beginning of the encoding of <code>instr</code>, and the following instructions are assumed to be encoded in sequence after <code>instr</code>. Otherwise, the encoding is expected to be found in <code>instr's</code> allocated bits. </p>

</div>
</div>
<a class="anchor" id="a56419903595cc4bd2bb39f887a5275d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_encoding_possible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> can be encoding as a valid IA-32 instruction. </p>

</div>
</div>
<a class="anchor" id="a3156edfed281e089c234fc475df6c82a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_exclusive_store </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is an exclusive store instruction, e.g., OP_strex on ARM. </p>

</div>
</div>
<a class="anchor" id="ad7abc869b82542e5ea0e564ec671b7cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_exit_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a conditional branch, unconditional branch, or indirect branch with a program address target (NOT an <a class="el" href="structinstr__t.html">instr_t</a> address target) and <code>instr</code> is ok to mangle. </p>

</div>
</div>
<a class="anchor" id="ac83165c08bdab6b1bf0933bccba7d557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_far_abs_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <code>instr</code> is an absolute call or jmp that is far. </p>

</div>
</div>
<a class="anchor" id="a45ee0433816dfcfbe8ca41988d757aee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_far_cti </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a far control transfer instruction: OP_jmp_far, OP_call_far, OP_jmp_far_ind, OP_call_far_ind, OP_ret_far, or OP_iret. </p>

</div>
</div>
<a class="anchor" id="a81cdb64c78235caf707130680d1f156d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_floating </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a floating point instruction. </p>

</div>
</div>
<a class="anchor" id="ac609abca95ab7f30d7f289f5dd19fdad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_floating_ex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a192e9ddf90889e6de003d95ebdaa7beb">dr_fp_type_t</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a floating point instruction. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">instr</td><td>The instruction to query </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">type</td><td>If the return value is true and <code>type</code> is non-NULL, the type of the floating point operation is written to <code>type</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa21d0c15479e3a0ee88a7ec06fe9eb22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_interrupt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr's</code> opcode is OP_int, OP_into, or OP_int3. </p>

</div>
</div>
<a class="anchor" id="ae61355d1ac416d4f04ed286eebc7c251"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_label </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a label meta-instruction. </p>

</div>
</div>
<a class="anchor" id="a963ac2677038071fc295b3b6eb45ce1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mbr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a multi-way (indirect) branch: OP_jmp_ind, OP_call_ind, OP_ret, OP_jmp_far_ind, OP_call_far_ind, OP_ret_far, or OP_iret on x86; OP_bx, OP_bxj, OP_blx_ind, or any instruction with a destination register operand of DR_REG_PC on ARM. </p>

</div>
</div>
<a class="anchor" id="ad03f60b3110fcbd793381245bed502be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE bool instr_is_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is a meta instruction (see <a class="el" href="dr__ir__instr_8h.html#ad0919782b67d3918ec6feb838e373f15">instr_set_meta()</a> for more information). </p>

</div>
</div>
<a class="anchor" id="a954715b40fa2668d7cde0c4a1bf47e51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_meta_may_fault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is not a meta-instruction that can fault (see <a class="el" href="dr__ir__instr_8h.html#a94227a193446d370f0180e6a844be0c2">instr_set_meta_may_fault()</a> for more information).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>Any meta instruction can fault if it has a non-NULL translation field and the client fully handles all of its faults, so this routine is no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e297cd513cbde904d0e09b721f1e9c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mmx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's MMX instructions. </p>

</div>
</div>
<a class="anchor" id="a8b39dade5681d6135379a5d53fe57512"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is an IA-32/AMD64 "mov" instruction: either OP_mov_st, OP_mov_ld, OP_mov_imm, OP_mov_seg, or OP_mov_priv. </p>

</div>
</div>
<a class="anchor" id="ac8da7990fa33f321134102323546516b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov_constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ptr_int_t *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries to identify common cases of moving a constant into either a register or a memory address. Returns true and sets <code>*value</code> to the constant being moved for the following cases: OP_mov_imm, OP_mov_st, and OP_xor where the source equals the destination, for x86; OP_mov, OP_movs, OP_movw, OP_mvn, OP_mvns, or OP_eor where the sources equal the destination and there is no shift, for ARM. </p>

</div>
</div>
<a class="anchor" id="a1cf18b53c422fdb11efe7bdcc596aea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_mov_imm_to_tos </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a "mov $imm -&gt; (%esp)". </p>

</div>
</div>
<a class="anchor" id="a87d172e2621d4548fe2c414fb0ed333a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_near_call_direct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_call on x86; OP_bl or OP_blx on ARM. </p>

</div>
</div>
<a class="anchor" id="ab5541d2b9311f842c43c0cfca020eb5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_near_ubr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a near unconditional direct branch: OP_jmp, or OP_jmp_short on x86; OP_b with no predicate on ARM. </p>

</div>
</div>
<a class="anchor" id="acb2c91a7868ad6a8e5c47af985edde61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_nop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if <code>instr</code> is one of a class of common nops. currently checks:</p><ul>
<li>nop</li>
<li>nop reg/mem</li>
<li>xchg reg, reg</li>
<li>mov reg, reg</li>
<li>lea reg, (reg) </li>
</ul>

</div>
</div>
<a class="anchor" id="a8d25cfd2ef6384b820b244fbb45dfb27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_predicated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether <code>instr</code> is predicated: i.e., whether its operation is conditional. </p>

</div>
</div>
<a class="anchor" id="aa653a23cf2029fc4eeaf05eb7523849d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_prefetch </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is a prefetch instruction. </p>

</div>
</div>
<a class="anchor" id="add4d31d6ba435e8a2f8226f3960248c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_reg_spill_or_restore </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *tls&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *spill&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *reg&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *offs&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether <code>instr</code> is a register spill or restore, whether it was created by <a class="el" href="dr__ir__utils_8h.html#af294ac021c84f5ec47230ee7df0e6c02">dr_save_reg()</a>, <a class="el" href="dr__ir__utils_8h.html#a453bc3ecddb4298ffdc1c429f30881b8">dr_restore_reg()</a>, <a class="el" href="dr__tools_8h.html#ac69f21285d41fe00b3f4231fcbaf39b3">dr_insert_read_raw_tls()</a>, <a class="el" href="dr__tools_8h.html#a481c4c988efd4d81ce0a92fe0cc3f276">dr_insert_write_raw_tls()</a>, routines that call the aforementioned routines (e.g., <a class="el" href="dr__ir__utils_8h.html#a44636ca6809a9fb22cf817701de9ee09">dr_save_arith_flags()</a>), or DR's own internal spills and restores. Returns information about the spill/restore in the OUT parameters. The returned <code>offs</code> is the raw offset in bytes from the TLS segment base, the stolen register base, or the thread-private context area. </p>

</div>
</div>
<a class="anchor" id="ade184d50e1016f220a10f40a60a4f8ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_return </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is OP_ret, OP_ret_far, or OP_iret on x86. On ARM, returns true iff <code>instr</code> reads DR_REG_LR and writes DR_REG_PC. </p>

</div>
</div>
<a class="anchor" id="aa7ab772125d06465662c15bd3f94cda6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE instructions. </p>

</div>
</div>
<a class="anchor" id="a68a8d4187a66f98538b09738027941ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE2 instructions. </p>

</div>
</div>
<a class="anchor" id="aaeba8e0bc76cb3b58b32320963a67401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE3 instructions. </p>

</div>
</div>
<a class="anchor" id="a0c7803a383529af652ed1c990bf1e2ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse41 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE4.1 instructions. </p>

</div>
</div>
<a class="anchor" id="a4ac2f94297357cfa59af50bfe8c21ec6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse42 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE4.2 instructions. </p>

</div>
</div>
<a class="anchor" id="a9c2f45cf71161208586e3bd8666a2242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse4A </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of AMD's SSE4A instructions. </p>

</div>
</div>
<a class="anchor" id="a33bb11334437a3076fbb81c0493f6e7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_sse_or_sse2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSE or SSE2 instructions. </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Use <a class="el" href="dr__ir__instr_8h.html#aa7ab772125d06465662c15bd3f94cda6">instr_is_sse()</a> combined with <a class="el" href="dr__ir__instr_8h.html#a68a8d4187a66f98538b09738027941ea">instr_is_sse2()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a933b1ffd9da886403f647f2adbedc3fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_ssse3 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is part of Intel's SSSE3 instructions. </p>

</div>
</div>
<a class="anchor" id="a86d982227aea8aa8647694b35cc592b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_syscall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is used to implement system calls: OP_int with a source operand of 0x80 on linux or 0x2e on windows, or OP_sysenter, or OP_syscall, or <a class="el" href="dr__ir__instr_8h.html#a4a4d5454f266483029bd88e5a17e398c">instr_is_wow64_syscall()</a> for WOW64. </p>

</div>
</div>
<a class="anchor" id="ac39c368adab3332628a34c1f48afc466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_ubr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is an unconditional direct branch: OP_jmp, OP_jmp_short, or OP_jmp_far on x86; OP_b or OP_b_short with no predicate on ARM. </p>

</div>
</div>
<a class="anchor" id="a465cc4935f184c4d224afbb9547a445c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_undefined </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is an "undefined" instruction (ud2) </p>

</div>
</div>
<a class="anchor" id="a4a4d5454f266483029bd88e5a17e398c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_is_wow64_syscall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> is the indirect transfer from the 32-bit ntdll.dll to the wow64 system call emulation layer. This instruction will also return true for instr_is_syscall, as well as appear as an indirect call, so clients modifying indirect calls may want to avoid modifying this type.</p>
<dl class="section note"><dt>Note</dt><dd>Windows-only </dd></dl>

</div>
</div>
<a class="anchor" id="a6e3ce6c289fa92d4cffdaf84bbbf691a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_it_block_compute_immediates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>firstcond_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>mask_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes immediates (firstcond and mask) for creating a new instruction with opcode <a class="el" href="dr__ir__opcodes__arm_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a651b96b5040e974b49d32bf7f6277309">OP_it</a> with the given predicates. Up to four instructions can exist in a single IT block. Pass <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ad94a882e075b12c0e4e6e5f852e4e4b2">DR_PRED_NONE</a> for all predicates beyond the desired instruction count in the newly created IT block. Returns whether the given predicates are valid for creating an IT block. </p><dl class="section note"><dt>Note</dt><dd>ARM-only. </dd></dl>

</div>
</div>
<a class="anchor" id="aeee83fd953b3c6ae6554b56d57e720c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_it_block_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new instruction with opcode <a class="el" href="dr__ir__opcodes__arm_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a651b96b5040e974b49d32bf7f6277309">OP_it</a> and immediates set to encode an IT block with the given predicates. Up to four instructions can exist in a single IT block. Pass <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ad94a882e075b12c0e4e6e5f852e4e4b2">DR_PRED_NONE</a> for all predicates beyond the desired instruction count in the newly created IT block. </p><dl class="section note"><dt>Note</dt><dd>ARM-only. </dd></dl>

</div>
</div>
<a class="anchor" id="ac3633ffd22f844dd7e525a17234c0a7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_it_block_get_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>it_instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>it_instr's</code> opcode is <a class="el" href="dr__ir__opcodes__arm_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a651b96b5040e974b49d32bf7f6277309">OP_it</a>. Returns the number of instructions in the IT block that <code>it_instr</code> heads. </p><dl class="section note"><dt>Note</dt><dd>ARM-only. </dd></dl>

</div>
</div>
<a class="anchor" id="a07d45123c213dd6bfce245d78b45b3a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a> instr_it_block_get_pred </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>it_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>it_instr's</code> opcode is <a class="el" href="dr__ir__opcodes__arm_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a651b96b5040e974b49d32bf7f6277309">OP_it</a>. Returns the predicate for the instruction with ordinal <code>index</code> in IT block that <code>it_instr</code> heads. </p><dl class="section note"><dt>Note</dt><dd>ARM-only. </dd></dl>

</div>
</div>
<a class="anchor" id="a79a9b2a0b21a18dbfd0a7a534204b92b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_jcc_taken </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>eflags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given <code>eflags</code>, returns whether or not the conditional branch, <code>instr</code>, would be taken. </p>

</div>
</div>
<a class="anchor" id="ace0e57a48576a4aac25b1554f6ebcbf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_length </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of <code>instr</code>. As a side effect, if instr_is_app(instr) and <code>instr's</code> raw bits are invalid, encodes <code>instr</code> into bytes allocated with <a class="el" href="dr__ir__instr_8h.html#af7b33f34d4dd11993224b4fb10e136dc">instr_allocate_raw_bits()</a>, after which instr is marked as having valid raw bits. </p>

</div>
</div>
<a class="anchor" id="a8620fe9a0391247fcd9183e7cac291c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_make_persistent </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calling this function with <code>instr</code> makes it safe to keep the instruction around indefinitely when its raw bits point into the cache. The function allocates memory local to <code>instr</code> to hold a copy of the raw bits. If this was not done, the original raw bits could be deleted at some point. Making an instruction persistent is necessary if you want to keep it beyond returning from the call that produced the instruction. </p>

</div>
</div>
<a class="anchor" id="af679a00bb888cbb46ae266a8591997ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int instr_mem_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns number of bytes of heap used by <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a67563b7baa993aa824ba1803562fc029"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint instr_memory_reference_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculates the size, in bytes, of the memory read or write of <code>instr</code>. If <code>instr</code> does not reference memory, or is invalid, returns 0. If <code>instr</code> is a repeated string instruction, considers only one iteration. If <code>instr</code> uses vector addressing (VSIB, introduced in AVX2), considers only the size of each separate memory access. </p>

</div>
</div>
<a class="anchor" id="adb8c87b75de66fe9fcdf3db864a08702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_needs_encoding </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> raw bits are not a valid encoding of <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a41c99383d4ffa44c28d6fed33b449b2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE int instr_num_dsts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of destination operands of <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="a2f43bb8dee8ee7c8d07727247d3428b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE int instr_num_srcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of source operands of <code>instr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Addressing registers used in destination memory references (i.e., base, index, or segment registers) are not separately listed as source operands. </dd></dl>

</div>
</div>
<a class="anchor" id="a221092e79cb7fd9a701c2e260685a6dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_ok_to_emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is to be emitted into the cache. </p>

</div>
</div>
<a class="anchor" id="a95454ba978870e70aa6b882155c4dabd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE bool instr_ok_to_mangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true iff <code>instr</code> is not a meta-instruction (see <a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app()</a> for more information).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd><a class="el" href="dr__ir__instr_8h.html#a5e6d7eea24e55c4a4851ab4e3c0aa108">instr_is_app()</a>/instr_is_meta() should be used instead. </dd></dl>

</div>
</div>
<a class="anchor" id="afeaf6ea858ca81c8b9968e4be43749f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_opcode_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is valid. If the opcode is ever set to other than OP_INVALID or OP_UNDECODED it is assumed to be valid. However, calling <a class="el" href="dr__ir__instr_8h.html#a90d36984352b073089da3c91b901c853">instr_get_opcode()</a> will attempt to decode a valid opcode, hence the purpose of this routine. </p>

</div>
</div>
<a class="anchor" id="a9c820f4c4b82638289cca3c40f1d15c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_operands_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> operands are up to date. </p>

</div>
</div>
<a class="anchor" id="a2c79cd1dd94bb1ba7e3740a80c42184f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* instr_predicate_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the string name corresponding to the given DR_PRED_ constant. </p><dl class="section note"><dt>Note</dt><dd>ARM-only. </dd></dl>

</div>
</div>
<a class="anchor" id="a284a0bdc5a1cc7a841a061edd4d37c7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__ir__instr_8h.html#a4f7ea3616bfa61f7269cdd33086a70f4">dr_pred_trigger_t</a> instr_predicate_triggered </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *&#160;</td>
          <td class="paramname"><em>mc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given the machine context <code>mc</code>, returns whether or not the predicated instruction <code>instr</code> will execute. Currently condition-code predicates are supported and OP_bsf and OP_bsr from <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ade60058c0eb6909b05024f9728c6b9bc">DR_PRED_COMPLEX</a>; other instances of <a class="el" href="dr__ir__instr_8h.html#ac55eea34836068d8d66196c3f1556d71ade60058c0eb6909b05024f9728c6b9bc">DR_PRED_COMPLEX</a> are not supported. <code>mc-&gt;flags</code> must include <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4ab7914092947d4a374f4a95e089870218">DR_MC_CONTROL</a> for condition-code predicates, and additionally <a class="el" href="dr__defines_8h.html#af0434595b47158e7512c2bf5f0e43ae4af2252e055eafe402a7bf12b9951410d8">DR_MC_INTEGER</a> for OP_bsf and OP_bsr.</p>
<dl class="section note"><dt>Note</dt><dd>More complex predicates will be added in the future and they may require additional state in <code>mc</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="af08de27201e4c64a655e309b47d096c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_raw_bits_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> raw bits are a valid encoding of instr. </p>

</div>
</div>
<a class="anchor" id="a7eedc2c20258ebd1e50d0a99dcda89fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reads_from_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that reg is a DR_REG_ constant. Returns true iff at least one of instr's operands reads from a register that overlaps reg (checks both source operands and addressing registers used in destination operands).</p>
<p>Returns false for multi-byte nops with an operand using reg.</p>
<p>Which operands are considered to be accessed for conditionally executed instructions are controlled by <code>flags</code>. As a special case, the addressing registers inside a destination memory operand are covered by DR_QUERY_INCLUDE_COND_SRCS rather than DR_QUERY_INCLUDE_COND_DSTS. </p>

</div>
</div>
<a class="anchor" id="ae408fe229bea0aa800cddb6b911c0e94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reads_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff any of <code>instr's</code> source operands is a memory reference.</p>
<p>Unlike <a class="el" href="dr__ir__opnd_8h.html#a5ed7af0d7ea648245c8efd77b30d7e69">opnd_is_memory_reference()</a>, this routine conisders the semantics of the instruction and returns false for both multi-byte nops with a memory operand and for the <a class="el" href="dr__ir__opcodes__x86_8h.html#a94798fdadfbf49a7c658ace669a1d310a8e5722f2fffd08c1e03efa408a6a0f55">OP_lea</a> instruction, as they do not really reference the memory. It does return true for prefetch instructions.</p>
<p>If <code>instr</code> is predicated (see <a class="el" href="dr__ir__instr_8h.html#a8d25cfd2ef6384b820b244fbb45dfb27">instr_is_predicated()</a>), the memory reference may not always be accessed. </p>

</div>
</div>
<a class="anchor" id="a7e0752a69bd5b0331f8e98512ec15c2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reg_in_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands references <code>reg</code>. </p>

</div>
</div>
<a class="anchor" id="ae1092dee2d8367ca2fec50cba5e632d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_reg_in_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> source operands references <code>reg</code>.</p>
<p>Returns false for multi-byte nops with a source operand using reg.</p>
<dl class="section note"><dt>Note</dt><dd>Use <a class="el" href="dr__ir__instr_8h.html#a7eedc2c20258ebd1e50d0a99dcda89fa">instr_reads_from_reg()</a> to also consider addressing registers in destination operands. </dd></dl>

</div>
</div>
<a class="anchor" id="ae86db389d26757898fb8a614e43bf4b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_remove_dsts </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes <code>instr's</code> destination operands from position <code>start</code> up to but not including position <code>end</code> (so pass n,n+1 to remove just position n). Shifts all subsequent destination operands (if any) down in the operand array. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="afcc087f8b47135d8f08520bf0fffa630"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_remove_srcs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes <code>instr's</code> source operands from position <code>start</code> up to but not including position <code>end</code> (so pass n,n+1 to remove just position n). Shifts all subsequent source operands (if any) down in the operand array. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="a7ff0a9b43777e95bf6932260f4b5cc09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_replace_src_opnd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>old_opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>new_opnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces all instances of <code>old_opnd</code> in <code>instr's</code> source operands with <code>new_opnd</code> (uses <a class="el" href="dr__ir__opnd_8h.html#adabfafe5e90003ff8e05775beef1f283">opnd_same()</a> to detect sameness). </p>

</div>
</div>
<a class="anchor" id="accd2bdee07d2e6ca0be3b252bc7b913f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_reset </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs both <a class="el" href="dr__ir__instr_8h.html#ae0f3cc7fb91265cb6c8eb15a84184c1f">instr_free()</a> and <a class="el" href="dr__ir__instr_8h.html#a77b55daa2b3780d2c07e33b8330b2f62">instr_init()</a>. <code>instr</code> must have been initialized. </p>

</div>
</div>
<a class="anchor" id="ab9b44a1db49dc5cd8da8b6b27fa47d50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_reuse </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees all dynamically allocated storage that was allocated by <code>instr</code>, except for allocated bits. Also zeroes out <code>instr's</code> fields, except for raw bit fields, whether <code>instr</code> is <a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta()</a>, and the x86 mode of <code>instr</code>. <code>instr</code> must have been initialized. </p>

</div>
</div>
<a class="anchor" id="a9e75c7fe47cb20acfae6bca1cd4bd2e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_same </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr1</code> and <code>instr2</code> have the same opcode, prefixes, and source and destination operands (uses <a class="el" href="dr__ir__opnd_8h.html#adabfafe5e90003ff8e05775beef1f283">opnd_same()</a> to compare the operands). </p>

</div>
</div>
<a class="anchor" id="ab7d47ceb0c0c0b5f50b78346c85a7f47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_app </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr</code> as an application (non-meta) instruction. An application instruction might be mangled by DR if necessary, e.g., to create an exit stub for a branch instruction. All application instructions that are added to basic blocks or traces should have their translation fields set (via <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a>). </p>

</div>
</div>
<a class="anchor" id="a1429cf1d1da8156898fde712e59e86db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_branch_target_pc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the taken target pc of the (direct branch) instruction. </p>

</div>
</div>
<a class="anchor" id="a8e843e39613655f6a5c49e081fe593c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_dst </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> destination operand at position <code>pos</code> to be <code>opnd</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="ac5a3e9d1d3cfd1a9db59a9b518cf7b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_set_isa_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__utils_8h.html#a83ebdc7f73d889146aaf9f6ea7865d94">dr_isa_mode_t</a>&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each instruction stores the processor mode under which it should be interpreted. This routine sets the mode for <code>instr</code>. </p>

</div>
</div>
<a class="anchor" id="ad0919782b67d3918ec6feb838e373f15"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr</code> as a meta instruction. A meta instruction will not be mangled by DR in any way, which is necessary to have DR not create an exit stub for a branch instruction. Meta instructions should not fault (unless such faults are handled by the client) and are not considered application instructions but rather added instrumentation code (see <a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event()</a> for further information). </p>

</div>
</div>
<a class="anchor" id="a94227a193446d370f0180e6a844be0c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta_may_fault </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000005">Deprecated:</a></b></dt><dd>Any meta instruction can fault if it has a non-NULL translation field and the client fully handles all of its faults, so this routine is no longer needed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5206d055a5b06435bd5e919da40e8bd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_meta_no_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience routine that calls both <a class="el" href="dr__ir__instr_8h.html#ad0919782b67d3918ec6feb838e373f15">instr_set_meta</a> (instr) and <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation</a> (instr, NULL). </p>

</div>
</div>
<a class="anchor" id="aa8c3ae1eb25b05c337889022f35e6187"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void instr_set_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>next</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the next field of <code>instr</code> to point to <code>next</code>. </p>

</div>
</div>
<a class="anchor" id="a85a8f92faa0d368fec240e6fa819ca9c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void instr_set_note </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user-controlled note field in <code>instr</code> to <code>value</code>. </p>

</div>
</div>
<a class="anchor" id="aee0d80a8e69e8f0abe867f1903a107ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_num_opnds </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_dsts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_srcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> has been initialized but does not have any operands yet. Allocates storage for <code>num_srcs</code> source operands and <code>num_dsts</code> destination operands. </p>

</div>
</div>
<a class="anchor" id="ae34605a2cff286d358941be6aa91788d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_ok_to_emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set <code>instr</code> to "ok to emit" if <code>val</code> is true and "not ok to emit" if <code>val</code> is false. An instruction that should not be emitted is treated normally by DR for purposes of exits but is not placed into the cache. It is used for final jumps that are to be elided. </p>

</div>
</div>
<a class="anchor" id="a2335bd8d05936e8308506ef11f1be401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_ok_to_mangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr</code> to "ok to mangle" if <code>val</code> is true and "not ok to
mangle" if <code>val</code> is false.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000003">Deprecated:</a></b></dt><dd><a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app()</a>/instr_set_meta() should be used instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e1efc53088af35fa0ed6eefd80af5dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_opcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opcode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes <code>opcode</code> is an OP_ constant and sets it to be instr's opcode. </p>

</div>
</div>
<a class="anchor" id="ac8f4d5f068f69df848c0dd1cacebc90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_operands_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> operands to be valid if <code>valid</code> is true, invalid otherwise. </p>

</div>
</div>
<a class="anchor" id="ac668216d6d231b12cf2845c5dc982ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_set_predicate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#a27cda70ebaed7e6872a63c7316917d70">dr_pred_type_t</a>&#160;</td>
          <td class="paramname"><em>pred</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the predication for <code>instr</code> to the given DR_PRED_ constant. Returns <code>instr</code> if successful, or NULL if unsuccessful. </p>

</div>
</div>
<a class="anchor" id="a3948b6ce886753002699286061faef26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_set_prefix_flag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>prefix</code> is a PREFIX_ constant. Ors <code>instr's</code> prefixes with <code>prefix</code>. Returns the supplied instr (for easy chaining). </p>

</div>
</div>
<a class="anchor" id="a208fe2bdba4a5ea47f1a0588fdc3278b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">INSTR_INLINE void instr_set_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the prev field of <code>instr</code> to point to <code>prev</code>. </p>

</div>
</div>
<a class="anchor" id="a7b9c3a55529a9e5467851821fe53fdb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr</code> does not currently have any raw bits allocated. Sets <code>instr's</code> raw bits to be <code>length</code> bytes starting at <code>addr</code>. Does not set the operands invalid. </p>

</div>
</div>
<a class="anchor" id="a76b3326d827b06a1d1d0bc3d20ba17a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bits_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> raw bits to be valid if <code>valid</code> is true, invalid otherwise. </p>

</div>
</div>
<a class="anchor" id="ad11045a1b7b7cbd2053048f028e5e687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_byte </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte&#160;</td>
          <td class="paramname"><em>byte</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt; <code>pos</code> bytes. Sets instr's raw byte at position <code>pos</code> (beginning with 0) to the value <code>byte</code>. </p>

</div>
</div>
<a class="anchor" id="a71fba42e58fa08ed1e0da9be2fbde4d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt;= num_bytes bytes. Copies the <code>num_bytes</code> beginning at start to <code>instr's</code> raw bits. </p>

</div>
</div>
<a class="anchor" id="a22ea2d9c35a7b4fcf89e4d160314babb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_raw_word </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>instr's</code> raw bits are valid and allocated by <code>instr</code> and have &gt; pos+3 bytes. Sets the 4 bytes beginning at position <code>pos</code> (0-based) to the value word. </p>

</div>
</div>
<a class="anchor" id="a96bfa15e2f3a95174e36c80c585a24e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_src </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets <code>instr's</code> source operand at position <code>pos</code> to be <code>opnd</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="adbf4b84b7a6b07e22af66b0aec7cacf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_target </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>cti_instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>cti_instr</code> is a control transfer instruction. Sets the first source operand of <code>cti_instr</code> to be <code>target</code>. Also calls instr_set_raw_bits_valid(<code>instr</code>, false) and instr_set_operands_valid(<code>instr</code>, true). </p>

</div>
</div>
<a class="anchor" id="af1beda2d570ba04d74ca9cbd7c31bb1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structinstr__t.html">instr_t</a>* instr_set_translation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the translation pointer for <code>instr</code>, used to recreate the application address corresponding to this instruction. When adding or modifying instructions that are to be considered application instructions (i.e., non meta-instructions: see <a class="el" href="dr__ir__instr_8h.html#a5e6d7eea24e55c4a4851ab4e3c0aa108">instr_is_app</a>), the translation should always be set. Pick the application address that if executed will be equivalent to restarting <code>instr</code>. Currently the translation address must lie within the existing bounds of the containing code block. Returns the supplied <code>instr</code> (for easy chaining). Use <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc</a> to see the current value of the translation. </p>

</div>
</div>
<a class="anchor" id="a74814111812ff20b281f7350fb626746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_set_x86_mode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>x86</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each instruction stores whether it should be interpreted in 32-bit (x86) or 64-bit (x64) mode. This routine sets the mode for <code>instr</code>.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only.</dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000006">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="dr__ir__instr_8h.html#ac5a3e9d1d3cfd1a9db59a9b518cf7b61">instr_set_isa_mode()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2dba2c8ede2bb35a708bd8dba95d5746"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_shrink_to_16_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks all registers not used as addresses, and all immed integer and address sizes, to 16 bits. Does not shrink DR_REG_ESI or DR_REG_EDI used in string instructions. </p>

</div>
</div>
<a class="anchor" id="ae0db1cec99a6fff7dde7201a87ca8892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void instr_shrink_to_32_bits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shrinks all registers, including addresses, and all immed integer and address sizes, to 32 bits.</p>
<dl class="section note"><dt>Note</dt><dd>For 64-bit DR builds only. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b828bdfc3723d5b05d7147cfc237397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_uses_fp_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff at least one of <code>instr's</code> operands references a floating point register. </p>

</div>
</div>
<a class="anchor" id="a15a3336a497835085cc0a7be3b010cf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_uses_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> operands references a register that overlaps <code>reg</code>.</p>
<p>Returns false for multi-byte nops with an operand using reg. </p>

</div>
</div>
<a class="anchor" id="a9890dc9d4dbc40589c974a0ff221db72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_valid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr's</code> opcode is NOT OP_INVALID. Not to be confused with an invalid opcode, which can be OP_INVALID or OP_UNDECODED. OP_INVALID means an instruction with no valid fields: raw bits (may exist but do not correspond to a valid instr), opcode, eflags, or operands. It could be an uninitialized instruction or the result of decoding an invalid sequence of bytes. </p>

</div>
</div>
<a class="anchor" id="ae1aac8cef8bb6ab075238e38ad6888a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff any of <code>instr's</code> destination operands is a memory reference. If <code>instr</code> is predicated (see <a class="el" href="dr__ir__instr_8h.html#a8d25cfd2ef6384b820b244fbb45dfb27">instr_is_predicated()</a>), the destination may not always be written. </p>

</div>
</div>
<a class="anchor" id="aae4c5c2c93e36bc599d327d301ddb4f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_to_exact_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands is the same register (not enough to just overlap) as <code>reg</code>. Which operands are considered to be accessed for conditionally executed instructions are controlled by <code>flags</code>. </p>

</div>
</div>
<a class="anchor" id="aa4eeb11aca6356b8f190cee7119c7ea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_writes_to_reg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__instr_8h.html#ab02e5d9677a934f4c981d58d435d4b65">dr_opnd_query_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assumes that <code>reg</code> is a DR_REG_ constant. Returns true iff at least one of <code>instr's</code> destination operands is a register operand for a register that overlaps <code>reg</code>. Which operands are considered to be accessed for conditionally executed instructions are controlled by <code>flags</code>. </p>

</div>
</div>
<a class="anchor" id="a785671aba1adec0f47add596f7e6a440"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool instr_zeroes_ymmh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>instr</code> writes to an xmm register and zeroes the top half of the corresponding ymm register as a result (some instructions preserve the top half while others zero it when writing to the bottom half). This zeroing will occur even if <code>instr</code> is predicated (see <a class="el" href="dr__ir__instr_8h.html#a8d25cfd2ef6384b820b244fbb45dfb27">instr_is_predicated()</a>). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_7e8c68b3a1981dda5ab1ff5587b4f0bc.html">include</a></li><li class="navelem"><a class="el" href="dr__ir__instr_8h.html">dr_ir_instr.h</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 7.0.0 --- Fri Feb 3 2017 00:37:39 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>

<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: dr_tools.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dr__tools_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_tools.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Main API routines, including transparency support.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union__version__number__t.html">_version_number_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__names__t.html">_module_names_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__os__version__info__t.html">_dr_os_version_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__memory__dump__spec__t.html">_dr_memory_dump_spec_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__segment__data__t.html">_module_segment_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__module__data__t.html">_module_data_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__module__import__t.html">_dr_module_import_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__symbol__import__t.html">_dr_symbol_import_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__symbol__export__t.html">_dr_symbol_export_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__syscall__result__info__t.html">_dr_syscall_result_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac2c501052e751bc9c72c622b1ca8b96c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac2c501052e751bc9c72c622b1ca8b96c">DR_MEMPROT_NONE</a>&#160;&#160;&#160;0x00</td></tr>
<tr class="separator:ac2c501052e751bc9c72c622b1ca8b96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab430d92dd0d6338ec3e42b527ae91efb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab430d92dd0d6338ec3e42b527ae91efb">DR_MEMPROT_READ</a>&#160;&#160;&#160;0x01</td></tr>
<tr class="separator:ab430d92dd0d6338ec3e42b527ae91efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dafb99a4933112c603189bc091fa752"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1dafb99a4933112c603189bc091fa752">DR_MEMPROT_WRITE</a>&#160;&#160;&#160;0x02</td></tr>
<tr class="separator:a1dafb99a4933112c603189bc091fa752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98be75b6fde3dc1dbfb8bfda59fce66"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad98be75b6fde3dc1dbfb8bfda59fce66">DR_MEMPROT_EXEC</a>&#160;&#160;&#160;0x04</td></tr>
<tr class="separator:ad98be75b6fde3dc1dbfb8bfda59fce66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bb4e765c888211477c17e73abf992f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af8bb4e765c888211477c17e73abf992f">DR_MEMPROT_GUARD</a>&#160;&#160;&#160;0x08</td></tr>
<tr class="separator:af8bb4e765c888211477c17e73abf992f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcb0f62864c67d1aa74381035b5bbfe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0dcb0f62864c67d1aa74381035b5bbfe">DR_MEMPROT_PRETEND_WRITE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a0dcb0f62864c67d1aa74381035b5bbfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9c33a04e71ed6d6ec41e26013a005fd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac9c33a04e71ed6d6ec41e26013a005fd">DR_MEMPROT_VDSO</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:ac9c33a04e71ed6d6ec41e26013a005fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6bdc93e35ee5a9f081564a162ec3b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4e6bdc93e35ee5a9f081564a162ec3b9">GLOBAL_DCONTEXT</a>&#160;&#160;&#160;((void *)-1)</td></tr>
<tr class="separator:a4e6bdc93e35ee5a9f081564a162ec3b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6d066ab9bdd578d4000e80df8503bc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x,  msg)</td></tr>
<tr class="separator:abd6d066ab9bdd578d4000e80df8503bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c07630dffdfd92bc6ee63abf405768c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7c07630dffdfd92bc6ee63abf405768c">DR_ASSERT</a>(x)&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#abd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x, &quot;&quot;)</td></tr>
<tr class="separator:a7c07630dffdfd92bc6ee63abf405768c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d467c1d283fdfa1f2081ba1e0d01b6e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7d467c1d283fdfa1f2081ba1e0d01b6e">PAGE_SIZE</a>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a2ac0d710a2af2ab256bd5940b936ac3f">dr_page_size</a>()</td></tr>
<tr class="separator:a7d467c1d283fdfa1f2081ba1e0d01b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef0efe8b0b596d8f85a144c2f2c2c3a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adef0efe8b0b596d8f85a144c2f2c2c3a">PAGE_START</a>(x)&#160;&#160;&#160;(((ptr_uint_t)(x)) &amp; ~(<a class="el" href="dr__tools_8h.html#a2ac0d710a2af2ab256bd5940b936ac3f">dr_page_size</a>()-1))</td></tr>
<tr class="separator:adef0efe8b0b596d8f85a144c2f2c2c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9ba447c606e5e58400ac7b6ef719d1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT</a>(drcontext,  try_statement,  except_statement)</td></tr>
<tr class="separator:adb9ba447c606e5e58400ac7b6ef719d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0772bc47090cec1a333baf1259f226d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad0772bc47090cec1a333baf1259f226d">DR_FILE_READ</a>&#160;&#160;&#160;0x1</td></tr>
<tr class="separator:ad0772bc47090cec1a333baf1259f226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f713faf2e1eac95bc26a98b67e28cc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a11f713faf2e1eac95bc26a98b67e28cc">DR_FILE_WRITE_REQUIRE_NEW</a>&#160;&#160;&#160;0x2</td></tr>
<tr class="separator:a11f713faf2e1eac95bc26a98b67e28cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac989ab040f48c4c91cc3a6ea63f9ec1f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac989ab040f48c4c91cc3a6ea63f9ec1f">DR_FILE_WRITE_APPEND</a>&#160;&#160;&#160;0x4</td></tr>
<tr class="separator:ac989ab040f48c4c91cc3a6ea63f9ec1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb30eb2b5d14486b3ecbc2b2457dfdb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5fb30eb2b5d14486b3ecbc2b2457dfdb">DR_FILE_WRITE_OVERWRITE</a>&#160;&#160;&#160;0x8</td></tr>
<tr class="separator:a5fb30eb2b5d14486b3ecbc2b2457dfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a3b276c8d9a62bf6d78c3707d4effd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a77a3b276c8d9a62bf6d78c3707d4effd">DR_FILE_ALLOW_LARGE</a>&#160;&#160;&#160;0x10</td></tr>
<tr class="separator:a77a3b276c8d9a62bf6d78c3707d4effd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0401a3003f578602bf31a984a4d5419d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0401a3003f578602bf31a984a4d5419d">DR_FILE_CLOSE_ON_FORK</a>&#160;&#160;&#160;0x20</td></tr>
<tr class="separator:a0401a3003f578602bf31a984a4d5419d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71a8471b604df56ae2fa05ba66e03be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac71a8471b604df56ae2fa05ba66e03be">DR_FILE_WRITE_ONLY</a>&#160;&#160;&#160;0x40</td></tr>
<tr class="separator:ac71a8471b604df56ae2fa05ba66e03be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa675a6270b664511299295ebc1f5562e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa675a6270b664511299295ebc1f5562e">DR_SEEK_SET</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:aa675a6270b664511299295ebc1f5562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31bd52878d2454d8263d0951cfd1ca0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad31bd52878d2454d8263d0951cfd1ca0">DR_SEEK_CUR</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:ad31bd52878d2454d8263d0951cfd1ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e58c043e838f1457853329fd4344a3"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06e58c043e838f1457853329fd4344a3">DR_SEEK_END</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a06e58c043e838f1457853329fd4344a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1632479322efa3952798f98177b54471"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1632479322efa3952798f98177b54471">LOG_NONE</a>&#160;&#160;&#160;0x00000000</td></tr>
<tr class="separator:a1632479322efa3952798f98177b54471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dd9f361c4a23133f724c84192eef8e1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9dd9f361c4a23133f724c84192eef8e1">LOG_STATS</a>&#160;&#160;&#160;0x00000001</td></tr>
<tr class="separator:a9dd9f361c4a23133f724c84192eef8e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdb93b09477bb1b1ee08d132dd6f4dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9fdb93b09477bb1b1ee08d132dd6f4dc">LOG_TOP</a>&#160;&#160;&#160;0x00000002</td></tr>
<tr class="separator:a9fdb93b09477bb1b1ee08d132dd6f4dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9390202fe239f2ee56c097d6940d10f6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9390202fe239f2ee56c097d6940d10f6">LOG_THREADS</a>&#160;&#160;&#160;0x00000004</td></tr>
<tr class="separator:a9390202fe239f2ee56c097d6940d10f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ef794555c43a1988eb760835b2fa76"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a87ef794555c43a1988eb760835b2fa76">LOG_SYSCALLS</a>&#160;&#160;&#160;0x00000008</td></tr>
<tr class="separator:a87ef794555c43a1988eb760835b2fa76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5895b0ef2efc255ad93e50bc88277b6d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5895b0ef2efc255ad93e50bc88277b6d">LOG_ASYNCH</a>&#160;&#160;&#160;0x00000010</td></tr>
<tr class="separator:a5895b0ef2efc255ad93e50bc88277b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bbda8cb7e78f2ea32209bab2d7201c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a54bbda8cb7e78f2ea32209bab2d7201c">LOG_INTERP</a>&#160;&#160;&#160;0x00000020</td></tr>
<tr class="separator:a54bbda8cb7e78f2ea32209bab2d7201c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06582648acdd995a11019f726b15adda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06582648acdd995a11019f726b15adda">LOG_EMIT</a>&#160;&#160;&#160;0x00000040</td></tr>
<tr class="separator:a06582648acdd995a11019f726b15adda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a438ad3561d9d8616ff702b36d0b2bb7c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a438ad3561d9d8616ff702b36d0b2bb7c">LOG_LINKS</a>&#160;&#160;&#160;0x00000080</td></tr>
<tr class="separator:a438ad3561d9d8616ff702b36d0b2bb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031661fca6b5cb813db972d758caca2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a031661fca6b5cb813db972d758caca2b">LOG_CACHE</a>&#160;&#160;&#160;0x00000100</td></tr>
<tr class="separator:a031661fca6b5cb813db972d758caca2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5fcb805e6a1fdfac332931888b3ef7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7c5fcb805e6a1fdfac332931888b3ef7">LOG_FRAGMENT</a>&#160;&#160;&#160;0x00000200</td></tr>
<tr class="separator:a7c5fcb805e6a1fdfac332931888b3ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9929e24db31369398fbdc52ee040b234"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9929e24db31369398fbdc52ee040b234">LOG_DISPATCH</a>&#160;&#160;&#160;0x00000400</td></tr>
<tr class="separator:a9929e24db31369398fbdc52ee040b234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2575baf458eee6334f746544f91fa6cf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2575baf458eee6334f746544f91fa6cf">LOG_MONITOR</a>&#160;&#160;&#160;0x00000800</td></tr>
<tr class="separator:a2575baf458eee6334f746544f91fa6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5522e92b98898a21b7c26ba9df95f094"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5522e92b98898a21b7c26ba9df95f094">LOG_HEAP</a>&#160;&#160;&#160;0x00001000</td></tr>
<tr class="separator:a5522e92b98898a21b7c26ba9df95f094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a557f3a77c5d95b7cd06661245030c687"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a557f3a77c5d95b7cd06661245030c687">LOG_VMAREAS</a>&#160;&#160;&#160;0x00002000</td></tr>
<tr class="separator:a557f3a77c5d95b7cd06661245030c687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8879b800acfbbe8f2ada805be6ef5121"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8879b800acfbbe8f2ada805be6ef5121">LOG_SYNCH</a>&#160;&#160;&#160;0x00004000</td></tr>
<tr class="separator:a8879b800acfbbe8f2ada805be6ef5121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb9931c63f1cf95cacca6463d5a9b09"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aabb9931c63f1cf95cacca6463d5a9b09">LOG_MEMSTATS</a>&#160;&#160;&#160;0x00008000</td></tr>
<tr class="separator:aabb9931c63f1cf95cacca6463d5a9b09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f746aa1ef6a208cd1cd7174a694c9e5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9f746aa1ef6a208cd1cd7174a694c9e5">LOG_OPTS</a>&#160;&#160;&#160;0x00010000</td></tr>
<tr class="separator:a9f746aa1ef6a208cd1cd7174a694c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad7f6071c29a882af67d3a72fe4e787"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8ad7f6071c29a882af67d3a72fe4e787">LOG_SIDELINE</a>&#160;&#160;&#160;0x00020000</td></tr>
<tr class="separator:a8ad7f6071c29a882af67d3a72fe4e787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65630bab8d9fcde517b3f8ecb03c6de9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a65630bab8d9fcde517b3f8ecb03c6de9">LOG_SYMBOLS</a>&#160;&#160;&#160;0x00040000</td></tr>
<tr class="separator:a65630bab8d9fcde517b3f8ecb03c6de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a297668a84187b740ff4fe1e1d6e52eeb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a297668a84187b740ff4fe1e1d6e52eeb">LOG_RCT</a>&#160;&#160;&#160;0x00080000</td></tr>
<tr class="separator:a297668a84187b740ff4fe1e1d6e52eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f3856a58f1f9971ebcd62c99a448a5a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4f3856a58f1f9971ebcd62c99a448a5a">LOG_NT</a>&#160;&#160;&#160;0x00100000</td></tr>
<tr class="separator:a4f3856a58f1f9971ebcd62c99a448a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51c2bbdf11618716da67a305dd24ddde"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a51c2bbdf11618716da67a305dd24ddde">LOG_HOT_PATCHING</a>&#160;&#160;&#160;0x00200000</td></tr>
<tr class="separator:a51c2bbdf11618716da67a305dd24ddde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ec73009ed3f0c2baa1d3c44033c261e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6ec73009ed3f0c2baa1d3c44033c261e">LOG_HTABLE</a>&#160;&#160;&#160;0x00400000</td></tr>
<tr class="separator:a6ec73009ed3f0c2baa1d3c44033c261e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba5e74dd3a5577b7af5177960ecb9dd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abba5e74dd3a5577b7af5177960ecb9dd">LOG_MODULEDB</a>&#160;&#160;&#160;0x00800000</td></tr>
<tr class="separator:abba5e74dd3a5577b7af5177960ecb9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7574ce4aa047de1f4a564c9b441e69dc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7574ce4aa047de1f4a564c9b441e69dc">LOG_ALL</a>&#160;&#160;&#160;0x00ffffff</td></tr>
<tr class="separator:a7574ce4aa047de1f4a564c9b441e69dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af2dcd801f468cdc1cce40f7e885ffc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7af2dcd801f468cdc1cce40f7e885ffc">BB_ORIGIN_HEADER_SIZE</a>&#160;&#160;&#160;(sizeof(app_pc)+sizeof(int))</td></tr>
<tr class="separator:a7af2dcd801f468cdc1cce40f7e885ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25512292915eb6d1109b90f9c3bd1518"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a25512292915eb6d1109b90f9c3bd1518">STUB_DATA_FIXED_SIZE</a>&#160;&#160;&#160;(offsetof(<a class="el" href="dr__tools_8h.html#afbec914b027f98ee51e888671aac55f0">tracedump_stub_data_t</a>, count))</td></tr>
<tr class="separator:a25512292915eb6d1109b90f9c3bd1518"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad4bb25312a86996379357f79a4c7c1c1"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a></td></tr>
<tr class="separator:ad4bb25312a86996379357f79a4c7c1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac429103cb983108880aee9b1377c430c"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac429103cb983108880aee9b1377c430c">dr_auxlib_routine_ptr_t</a>) ()</td></tr>
<tr class="separator:ac429103cb983108880aee9b1377c430c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2834876d9bbe13989ed6ebc2e2f94c6a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2834876d9bbe13989ed6ebc2e2f94c6a">dr_mem_info_t</a></td></tr>
<tr class="separator:a2834876d9bbe13989ed6ebc2e2f94c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee552e6017b95b4708435b9467223d98"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union__version__number__t.html">_version_number_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aee552e6017b95b4708435b9467223d98">version_number_t</a></td></tr>
<tr class="separator:aee552e6017b95b4708435b9467223d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2fef062beef2b521283369e0108282"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__module__names__t.html">_module_names_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8d2fef062beef2b521283369e0108282">module_names_t</a></td></tr>
<tr class="separator:a8d2fef062beef2b521283369e0108282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b7c9d9efa9ec7a767855587eaa622e"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__os__version__info__t.html">_dr_os_version_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad4b7c9d9efa9ec7a767855587eaa622e">dr_os_version_info_t</a></td></tr>
<tr class="separator:ad4b7c9d9efa9ec7a767855587eaa622e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61869abe84d5de25e7dd02f247cb4c74"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__memory__dump__spec__t.html">_dr_memory_dump_spec_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a61869abe84d5de25e7dd02f247cb4c74">dr_memory_dump_spec_t</a></td></tr>
<tr class="separator:a61869abe84d5de25e7dd02f247cb4c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd116a488df74505f27ff57cd49b9f88"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a></td></tr>
<tr class="separator:afd116a488df74505f27ff57cd49b9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49d9cfe4b0a8495532e5e4189515e83"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__module__segment__data__t.html">_module_segment_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab49d9cfe4b0a8495532e5e4189515e83">module_segment_data_t</a></td></tr>
<tr class="separator:ab49d9cfe4b0a8495532e5e4189515e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e62023d3be1c972a03ac53f15aff55"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__module__import__t.html">_dr_module_import_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a20e62023d3be1c972a03ac53f15aff55">dr_module_import_t</a></td></tr>
<tr class="separator:a20e62023d3be1c972a03ac53f15aff55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97862b54ff9ef6f20494449ff47242e6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__symbol__import__t.html">_dr_symbol_import_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a97862b54ff9ef6f20494449ff47242e6">dr_symbol_import_t</a></td></tr>
<tr class="separator:a97862b54ff9ef6f20494449ff47242e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f313b8ed7cdc35283e82a59a6492077"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__symbol__export__t.html">_dr_symbol_export_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5f313b8ed7cdc35283e82a59a6492077">dr_symbol_export_t</a></td></tr>
<tr class="separator:a5f313b8ed7cdc35283e82a59a6492077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e96c875a305558239b74496c4030d0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af3e96c875a305558239b74496c4030d0">dr_export_info_t</a></td></tr>
<tr class="separator:af3e96c875a305558239b74496c4030d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af154bb3f9b057795c65b51687bb2ba50"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__syscall__result__info__t.html">_dr_syscall_result_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a></td></tr>
<tr class="separator:af154bb3f9b057795c65b51687bb2ba50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99aca5de3a975309ebf0f24cfe42c1e8"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a99aca5de3a975309ebf0f24cfe42c1e8">tracedump_file_header_t</a></td></tr>
<tr class="separator:a99aca5de3a975309ebf0f24cfe42c1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fe0415406026b8daf538ab6ac31519d"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3fe0415406026b8daf538ab6ac31519d">tracedump_trace_header_t</a></td></tr>
<tr class="separator:a3fe0415406026b8daf538ab6ac31519d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbec914b027f98ee51e888671aac55f0"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afbec914b027f98ee51e888671aac55f0">tracedump_stub_data_t</a></td></tr>
<tr class="separator:afbec914b027f98ee51e888671aac55f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ad051d9da5ddb2100eb450587e7551a70"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70">dr_state_flags_t</a> { <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70ade45f51ff07512196129df690c9351fc">DR_STATE_PEB</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70a1e89b3980660dea49687e08fea96df09">DR_STATE_TEB_MISC</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70a1075136763677e70239a776f8111b3c3">DR_STATE_STACK_BOUNDS</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70a6f0f881ce02e1caf28ffbbc1246aa9a8">DR_STATE_ALL</a> = ~0
<br />
 }<tr class="separator:ad051d9da5ddb2100eb450587e7551a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:aff97be516bbb1aecdb6bd043841aaa10"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10">dr_mem_type_t</a> { <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10a60e91c7b948d92d08b74ee0cd50dee3d">DR_MEMTYPE_FREE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10a6edf083337f9c953747a2cf4461dcbf7">DR_MEMTYPE_IMAGE</a>, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10ac0350de0d08726ea8a5a5f02bb7010b0">DR_MEMTYPE_DATA</a>, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10aa23ff267355a0b49da1b77da5bcc4d29">DR_MEMTYPE_RESERVED</a>, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10a990c1b40496fdfc22c89b67300c921ea">DR_MEMTYPE_ERROR</a>, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10a4155a1d348b4dc103ef7d5cd1c6dc257">DR_MEMTYPE_ERROR_WINKERNEL</a>
<br />
 }<tr class="separator:aff97be516bbb1aecdb6bd043841aaa10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a311ab26d3bdc2d6ff7830b6f3ae9760c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760c">dr_os_version_t</a> { <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca781e789a0171cf75fe5dedcfd9cb7f7c">DR_WINDOWS_VERSION_10_1607</a> = 102, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca2ce40ab4db406adf0613c77cc72112fd">DR_WINDOWS_VERSION_10_1511</a> = 101, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca7927b8c2058d3adf34e0e5c49474c979">DR_WINDOWS_VERSION_10</a> = 100, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760cacea85c24b6ec914a85dd58a39dde0d3e">DR_WINDOWS_VERSION_8_1</a> = 63, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca114432cbffadfec0fb011e9ef7ba8a87">DR_WINDOWS_VERSION_2012_R2</a> = DR_WINDOWS_VERSION_8_1, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca420fc7de0ba5c5b6dea013b4c2509ac0">DR_WINDOWS_VERSION_8</a> = 62, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca7c2a135c55d571883a94d9ff4e9da94f">DR_WINDOWS_VERSION_2012</a> = DR_WINDOWS_VERSION_8, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca8e8e36ac7efb1ad06cabb5f701306fde">DR_WINDOWS_VERSION_7</a> = 61, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760cae432c24e32ed3407f449f019d51d38ae">DR_WINDOWS_VERSION_2008_R2</a> = DR_WINDOWS_VERSION_7, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760cacb93ff69eabd6550b660012c55cacae1">DR_WINDOWS_VERSION_VISTA</a> = 60, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca252442772ce128b15408a140958c1c96">DR_WINDOWS_VERSION_2008</a> = DR_WINDOWS_VERSION_VISTA, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760caf960b684d92226cd35590c2804c8dfa6">DR_WINDOWS_VERSION_2003</a> = 52, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca4944bf33a5c3e637329fbdffe5051cee">DR_WINDOWS_VERSION_XP_X64</a> = DR_WINDOWS_VERSION_2003, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca3434e7522e1c3efc0fd898cf5f06c092">DR_WINDOWS_VERSION_XP</a> = 51, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760ca6364725219ede21bfbbf10d71fc844f0">DR_WINDOWS_VERSION_2000</a> = 50, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760caf3fa92ea36f47c6008fdbae9e78631b9">DR_WINDOWS_VERSION_NT</a> = 40
<br />
 }<tr class="separator:a311ab26d3bdc2d6ff7830b6f3ae9760c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a00269a3ba590923c5d0ec4e0bcf5a9ff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a00269a3ba590923c5d0ec4e0bcf5a9ff">dr_memory_dump_flags_t</a> { <a class="el" href="dr__tools_8h.html#a00269a3ba590923c5d0ec4e0bcf5a9ffa00ec80b5919c0e6e1dc361a5fa9af02f">DR_MEMORY_DUMP_LDMP</a> = 0x0001
 }<tr class="separator:a00269a3ba590923c5d0ec4e0bcf5a9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:abb7e20e83f7b8e1b65428e45c8ab4211"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a> { <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a312d65229e3450b24e59aec4b7d7410e">DR_ALLOC_THREAD_PRIVATE</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585">DR_ALLOC_FIXED_LOCATION</a> = 0x0008, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a> = 0x0010, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a> = 0x0020, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a5d2a736bd28da9bfd1a3238777c74558">DR_ALLOC_RESERVE_ONLY</a> = 0x0040, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a0f6cd06c9a4aa053b4e39fbde1fe7be1">DR_ALLOC_COMMIT_ONLY</a> = 0x0080
<br />
 }<tr class="separator:abb7e20e83f7b8e1b65428e45c8ab4211"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ade307e7bb7b7ac46e874097fe62b9fef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a> { <a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fefa183f27400568e903a072c9fc5bf0af96">DR_MAPEXE_SKIP_WRITABLE</a> = 0x0002
 }<tr class="separator:ade307e7bb7b7ac46e874097fe62b9fef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a5d76b81b0ad4c19007a781d4edb8181f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a5d76b81b0ad4c19007a781d4edb8181face272a4f3f0eff24ef44c983bfa4ce63">DR_MAP_PRIVATE</a> = 0x0001, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a5d76b81b0ad4c19007a781d4edb8181faec0156a07c55523ed4bb3d2f05c00b58">DR_MAP_FIXED</a> = 0x0002, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa12a6a7af3936e4c932effc9505f23be5">DR_MAP_IMAGE</a> = 0x0004, 
<br />
&#160;&#160;<a class="el" href="dr__tools_8h.html#a5d76b81b0ad4c19007a781d4edb8181fa6ba2a46cb1c2697fa81841feb05a777c">DR_MAP_CACHE_REACHABLE</a> = 0x0008
<br />
 }<tr class="separator:a5d76b81b0ad4c19007a781d4edb8181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a66bef18f8eabc7a8b8b0368e8a96d179"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a> { <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179a21ba834e13979aa7ad97fd13c69b3ae4">DR_SUSPEND_NATIVE</a> = 0x0001
 }<tr class="separator:a66bef18f8eabc7a8b8b0368e8a96d179"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af63184f56cc0508e2840f64e84b1c48d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af63184f56cc0508e2840f64e84b1c48d">dr_standalone_init</a> (void)</td></tr>
<tr class="separator:af63184f56cc0508e2840f64e84b1c48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54934632c814904bd9e0ce9c83980466"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a54934632c814904bd9e0ce9c83980466">dr_using_all_private_caches</a> (void)</td></tr>
<tr class="separator:a54934632c814904bd9e0ce9c83980466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902bfca468a7a2cc3dbc45b4bd127444"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a902bfca468a7a2cc3dbc45b4bd127444">dr_request_synchronized_exit</a> (void)</td></tr>
<tr class="separator:a902bfca468a7a2cc3dbc45b4bd127444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10831623706378cfc3082c0e27e31c4c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a10831623706378cfc3082c0e27e31c4c">dr_get_options</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr class="separator:a10831623706378cfc3082c0e27e31c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52ee0b4adc12d9e67f58d55f1313f9fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a52ee0b4adc12d9e67f58d55f1313f9fe">dr_get_option_array</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id, int *argc OUT, const char ***argv OUT)</td></tr>
<tr class="separator:a52ee0b4adc12d9e67f58d55f1313f9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cabd36923c3e56efb50bc10ee866918"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0cabd36923c3e56efb50bc10ee866918">dr_get_string_option</a> (const char *option_name, char *buf OUT, size_t len)</td></tr>
<tr class="separator:a0cabd36923c3e56efb50bc10ee866918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba205966cb16d0478ecf159cdfeaee8b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aba205966cb16d0478ecf159cdfeaee8b">dr_get_integer_option</a> (const char *option_name, uint64 *val OUT)</td></tr>
<tr class="separator:aba205966cb16d0478ecf159cdfeaee8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7d403eb032bd14ae78807ae3d59ea0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afb7d403eb032bd14ae78807ae3d59ea0">dr_get_client_path</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr class="separator:afb7d403eb032bd14ae78807ae3d59ea0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae96ea91548daf1a0b5a78197bc86f07"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aae96ea91548daf1a0b5a78197bc86f07">dr_get_client_base</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id)</td></tr>
<tr class="separator:aae96ea91548daf1a0b5a78197bc86f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401eb84af927fa3bd1358f6b639ec592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a401eb84af927fa3bd1358f6b639ec592">dr_set_client_name</a> (const char *name, const char *report_URL)</td></tr>
<tr class="separator:a401eb84af927fa3bd1358f6b639ec592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865f2d467e2732365a8e8c49e5a26310"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a865f2d467e2732365a8e8c49e5a26310">dr_set_client_version_string</a> (const char *version)</td></tr>
<tr class="separator:a865f2d467e2732365a8e8c49e5a26310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace5e8084f523fd25871b31463c7ecda"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aace5e8084f523fd25871b31463c7ecda">dr_get_application_name</a> (void)</td></tr>
<tr class="separator:aace5e8084f523fd25871b31463c7ecda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83b3658ca78e6b7adc81c57691f0fe50"><td class="memItemLeft" align="right" valign="top">process_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a83b3658ca78e6b7adc81c57691f0fe50">dr_get_process_id</a> (void)</td></tr>
<tr class="separator:a83b3658ca78e6b7adc81c57691f0fe50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11575b203a0558f5df50126ff04c4598"><td class="memItemLeft" align="right" valign="top">process_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a11575b203a0558f5df50126ff04c4598">dr_get_parent_id</a> (void)</td></tr>
<tr class="separator:a11575b203a0558f5df50126ff04c4598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abab30ef95ab36e4e885a9dc89f540c39"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abab30ef95ab36e4e885a9dc89f540c39">dr_get_os_version</a> (<a class="el" href="dr__tools_8h.html#ad4b7c9d9efa9ec7a767855587eaa622e">dr_os_version_info_t</a> *info)</td></tr>
<tr class="separator:abab30ef95ab36e4e885a9dc89f540c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5804006579a63b49827169d3ffbebc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac5804006579a63b49827169d3ffbebc8">dr_is_wow64</a> (void)</td></tr>
<tr class="separator:ac5804006579a63b49827169d3ffbebc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81037ee313844d4fbce3368f4421e5b4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a81037ee313844d4fbce3368f4421e5b4">dr_get_app_PEB</a> (void)</td></tr>
<tr class="separator:a81037ee313844d4fbce3368f4421e5b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153dc4defa904b033e122bb8957b0288"><td class="memItemLeft" align="right" valign="top">process_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a153dc4defa904b033e122bb8957b0288">dr_convert_handle_to_pid</a> (HANDLE process_handle)</td></tr>
<tr class="separator:a153dc4defa904b033e122bb8957b0288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9593c7e9b66e2020ebaea7e3911f2e22"><td class="memItemLeft" align="right" valign="top">HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9593c7e9b66e2020ebaea7e3911f2e22">dr_convert_pid_to_handle</a> (process_id_t pid)</td></tr>
<tr class="separator:a9593c7e9b66e2020ebaea7e3911f2e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae517c4817d67af6ad92b8f1d7694080a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae517c4817d67af6ad92b8f1d7694080a">dr_get_time</a> (<a class="el" href="structdr__time__t.html">dr_time_t</a> *time)</td></tr>
<tr class="separator:ae517c4817d67af6ad92b8f1d7694080a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b187636a3fc9ba7964ae11a7fd30fb6"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4b187636a3fc9ba7964ae11a7fd30fb6">dr_get_milliseconds</a> (void)</td></tr>
<tr class="separator:a4b187636a3fc9ba7964ae11a7fd30fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa6318d1d89060efb9567cdb4fedacc"><td class="memItemLeft" align="right" valign="top">uint64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aefa6318d1d89060efb9567cdb4fedacc">dr_get_microseconds</a> (void)</td></tr>
<tr class="separator:aefa6318d1d89060efb9567cdb4fedacc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3d12bdde33dd279f09bcb2a5bfd901"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeb3d12bdde33dd279f09bcb2a5bfd901">dr_get_random_value</a> (uint max)</td></tr>
<tr class="separator:aeb3d12bdde33dd279f09bcb2a5bfd901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53bfa41e85c457ff39452a68eaf2281b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a53bfa41e85c457ff39452a68eaf2281b">dr_set_random_seed</a> (uint seed)</td></tr>
<tr class="separator:a53bfa41e85c457ff39452a68eaf2281b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3212441c8fd1642d6d1fb7850562106"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af3212441c8fd1642d6d1fb7850562106">dr_get_random_seed</a> (void)</td></tr>
<tr class="separator:af3212441c8fd1642d6d1fb7850562106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c1ca981b7d3049cb2d31c0f19da332"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort</a> (void)</td></tr>
<tr class="separator:a12c1ca981b7d3049cb2d31c0f19da332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364db17ca1ba042f4fa3280b49fb2ad6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a364db17ca1ba042f4fa3280b49fb2ad6">dr_exit_process</a> (int exit_code)</td></tr>
<tr class="separator:a364db17ca1ba042f4fa3280b49fb2ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e70d60b5c4963fa277e27efc0482a60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9e70d60b5c4963fa277e27efc0482a60">dr_create_memory_dump</a> (<a class="el" href="dr__tools_8h.html#a61869abe84d5de25e7dd02f247cb4c74">dr_memory_dump_spec_t</a> *spec)</td></tr>
<tr class="separator:a9e70d60b5c4963fa277e27efc0482a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4274226adda06339e247e4a311abdd9b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc</a> (void *drcontext, size_t size)</td></tr>
<tr class="separator:a4274226adda06339e247e4a311abdd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1f3862009f52182e9ca1f943fa6f14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3f1f3862009f52182e9ca1f943fa6f14">dr_thread_free</a> (void *drcontext, void *mem, size_t size)</td></tr>
<tr class="separator:a3f1f3862009f52182e9ca1f943fa6f14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60faa40f7e8c819c34fd25cb367c5473"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc</a> (size_t size)</td></tr>
<tr class="separator:a60faa40f7e8c819c34fd25cb367c5473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8794210449c50fb4d411ad74a8dec1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ace8794210449c50fb4d411ad74a8dec1">dr_global_free</a> (void *mem, size_t size)</td></tr>
<tr class="separator:ace8794210449c50fb4d411ad74a8dec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfff0780cf83588e3d71da552490eb7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a> flags, size_t size, uint prot, void *addr)</td></tr>
<tr class="separator:a3cfff0780cf83588e3d71da552490eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f966c4d090cd499ffe3a5df7406604"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae4f966c4d090cd499ffe3a5df7406604">dr_custom_free</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a> flags, void *addr, size_t size)</td></tr>
<tr class="separator:ae4f966c4d090cd499ffe3a5df7406604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac32b5be072876c25a832d510efeba6e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc</a> (size_t size, uint prot)</td></tr>
<tr class="separator:ac32b5be072876c25a832d510efeba6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a401b819525f805d04e0a9560fdcfdf89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a401b819525f805d04e0a9560fdcfdf89">dr_nonheap_free</a> (void *mem, size_t size)</td></tr>
<tr class="separator:a401b819525f805d04e0a9560fdcfdf89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6201fa3676b0afb76f91f15822cf0d1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad6201fa3676b0afb76f91f15822cf0d1">dr_raw_mem_alloc</a> (size_t size, uint prot, void *addr)</td></tr>
<tr class="separator:ad6201fa3676b0afb76f91f15822cf0d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17b097679298ae00bab97d77ed4a17c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a17b097679298ae00bab97d77ed4a17c2">dr_raw_mem_free</a> (void *addr, size_t size)</td></tr>
<tr class="separator:a17b097679298ae00bab97d77ed4a17c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83555066ac1477ba607bee5f34626d35"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a83555066ac1477ba607bee5f34626d35">dr_raw_mremap</a> (void *old_address, size_t old_size, size_t new_size, int flags, void *new_address)</td></tr>
<tr class="separator:a83555066ac1477ba607bee5f34626d35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c9e86d9d052e7b4f6d47402185fbb79"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6c9e86d9d052e7b4f6d47402185fbb79">dr_raw_brk</a> (void *new_address)</td></tr>
<tr class="separator:a6c9e86d9d052e7b4f6d47402185fbb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3687f50774c89e7a09833a71adbb7771"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc</a> (size_t size)</td></tr>
<tr class="separator:a3687f50774c89e7a09833a71adbb7771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcaad79adf4fc109015dd6a2d49b9031"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adcaad79adf4fc109015dd6a2d49b9031">__wrap_realloc</a> (void *mem, size_t size)</td></tr>
<tr class="separator:adcaad79adf4fc109015dd6a2d49b9031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818524883cd69709fe0e3499d6748d14"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a818524883cd69709fe0e3499d6748d14">__wrap_calloc</a> (size_t nmemb, size_t size)</td></tr>
<tr class="separator:a818524883cd69709fe0e3499d6748d14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dca5b3d5bfbd3de8891502badd861e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free</a> (void *mem)</td></tr>
<tr class="separator:a82dca5b3d5bfbd3de8891502badd861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac0d710a2af2ab256bd5940b936ac3f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2ac0d710a2af2ab256bd5940b936ac3f">dr_page_size</a> (void)</td></tr>
<tr class="separator:a2ac0d710a2af2ab256bd5940b936ac3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1dd6ff985f0b21deada31ea33485737"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa1dd6ff985f0b21deada31ea33485737">dr_memory_is_readable</a> (const byte *pc, size_t size)</td></tr>
<tr class="separator:aa1dd6ff985f0b21deada31ea33485737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad158d2822dd8bb9caa9604d84b666bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad158d2822dd8bb9caa9604d84b666bfa">dr_query_memory</a> (const byte *pc, byte **base_pc, size_t *size, uint *prot)</td></tr>
<tr class="separator:ad158d2822dd8bb9caa9604d84b666bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6e4049f8accbc73ec5dbaf0deb25a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex</a> (const byte *pc, OUT <a class="el" href="dr__tools_8h.html#a2834876d9bbe13989ed6ebc2e2f94c6a">dr_mem_info_t</a> *info)</td></tr>
<tr class="separator:a5a6e4049f8accbc73ec5dbaf0deb25a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55ca77553e86a0656dc186ae3fc8222f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a55ca77553e86a0656dc186ae3fc8222f">dr_virtual_query</a> (const byte *pc, MEMORY_BASIC_INFORMATION *mbi, size_t mbi_size)</td></tr>
<tr class="separator:a55ca77553e86a0656dc186ae3fc8222f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a94558696130c76f34dcdac0ce50c47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read</a> (const void *base, size_t size, void *out_buf, size_t *bytes_read)</td></tr>
<tr class="separator:a6a94558696130c76f34dcdac0ce50c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94f47b693cc7dd9eecba07d8cfd1bc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab94f47b693cc7dd9eecba07d8cfd1bc8">dr_safe_write</a> (void *base, size_t size, const void *in_buf, size_t *bytes_written)</td></tr>
<tr class="separator:ab94f47b693cc7dd9eecba07d8cfd1bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef746f843b3270add2c763ab71457e5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aef746f843b3270add2c763ab71457e5d">dr_try_setup</a> (void *drcontext, void **try_cxt)</td></tr>
<tr class="separator:aef746f843b3270add2c763ab71457e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa59cdd4f9fa2884b5d236f0fedc5bda3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa59cdd4f9fa2884b5d236f0fedc5bda3">dr_try_start</a> (void *buf)</td></tr>
<tr class="separator:aa59cdd4f9fa2884b5d236f0fedc5bda3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde42618a83e7e1abdc58961a084e774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">dr_try_stop</a> (void *drcontext, void *try_cxt)</td></tr>
<tr class="separator:afde42618a83e7e1abdc58961a084e774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3a19a0dc146c1e5b6747e89bacfb55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2c3a19a0dc146c1e5b6747e89bacfb55">dr_memory_protect</a> (void *base, size_t size, uint new_prot)</td></tr>
<tr class="separator:a2c3a19a0dc146c1e5b6747e89bacfb55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a813f98fcc06c0a1198262b744e98eced"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal</a> (const byte *pc)</td></tr>
<tr class="separator:a813f98fcc06c0a1198262b744e98eced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a67b03d64626f3d0a78b64bf096ed25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client</a> (const byte *pc)</td></tr>
<tr class="separator:a2a67b03d64626f3d0a78b64bf096ed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c8a2e52880f44d43402d6b0d686db2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a94c8a2e52880f44d43402d6b0d686db2">dr_load_aux_library</a> (const char *name, byte **lib_start, byte **lib_end)</td></tr>
<tr class="separator:a94c8a2e52880f44d43402d6b0d686db2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814a1a50cc288dc902f2a2dcef9812c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#ac429103cb983108880aee9b1377c430c">dr_auxlib_routine_ptr_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a814a1a50cc288dc902f2a2dcef9812c6">dr_lookup_aux_library_routine</a> (<a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a> lib, const char *name)</td></tr>
<tr class="separator:a814a1a50cc288dc902f2a2dcef9812c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552563b1ccb84e3708041b276404d577"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a552563b1ccb84e3708041b276404d577">dr_unload_aux_library</a> (<a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a> lib)</td></tr>
<tr class="separator:a552563b1ccb84e3708041b276404d577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55da3fd48670f25ec69ee5daf5975de5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a55da3fd48670f25ec69ee5daf5975de5">dr_mutex_create</a> (void)</td></tr>
<tr class="separator:a55da3fd48670f25ec69ee5daf5975de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab148b68bc8e1479a14c175cbf42fc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aaab148b68bc8e1479a14c175cbf42fc0">dr_mutex_destroy</a> (void *mutex)</td></tr>
<tr class="separator:aaab148b68bc8e1479a14c175cbf42fc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04beaefb3e0be6bd0dac39f76398ec1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a04beaefb3e0be6bd0dac39f76398ec1e">dr_mutex_lock</a> (void *mutex)</td></tr>
<tr class="separator:a04beaefb3e0be6bd0dac39f76398ec1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a3a4ffffd0058a37211405fbb6ba51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a61a3a4ffffd0058a37211405fbb6ba51">dr_mutex_unlock</a> (void *mutex)</td></tr>
<tr class="separator:a61a3a4ffffd0058a37211405fbb6ba51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2ae4a29e2dc18dde2a6f01f26cbe79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6b2ae4a29e2dc18dde2a6f01f26cbe79">dr_mutex_trylock</a> (void *mutex)</td></tr>
<tr class="separator:a6b2ae4a29e2dc18dde2a6f01f26cbe79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae453a9c1ded7c8cd31d1a1aa2c8810af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae453a9c1ded7c8cd31d1a1aa2c8810af">dr_mutex_self_owns</a> (void *mutex)</td></tr>
<tr class="separator:ae453a9c1ded7c8cd31d1a1aa2c8810af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9accc32bf0c9c784516a7ce5373a3d2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9accc32bf0c9c784516a7ce5373a3d2b">dr_mutex_mark_as_app</a> (void *mutex)</td></tr>
<tr class="separator:a9accc32bf0c9c784516a7ce5373a3d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536222ea450d92cabebd3b24fe08098e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a536222ea450d92cabebd3b24fe08098e">dr_rwlock_create</a> (void)</td></tr>
<tr class="separator:a536222ea450d92cabebd3b24fe08098e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba97c3f8aea471718852b424e6bce35d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aba97c3f8aea471718852b424e6bce35d">dr_rwlock_destroy</a> (void *rwlock)</td></tr>
<tr class="separator:aba97c3f8aea471718852b424e6bce35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d7cd454ca96a0c2d1e701ab78cbcd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a96d7cd454ca96a0c2d1e701ab78cbcd8">dr_rwlock_read_lock</a> (void *rwlock)</td></tr>
<tr class="separator:a96d7cd454ca96a0c2d1e701ab78cbcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acf4f252a71dc5034aa0d99a59103a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3acf4f252a71dc5034aa0d99a59103a8">dr_rwlock_read_unlock</a> (void *rwlock)</td></tr>
<tr class="separator:a3acf4f252a71dc5034aa0d99a59103a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcb402769c7bc443876c00ad1f9cdbf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afcb402769c7bc443876c00ad1f9cdbf9">dr_rwlock_write_lock</a> (void *rwlock)</td></tr>
<tr class="separator:afcb402769c7bc443876c00ad1f9cdbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb241b0d90ee47cc3885d2c24c70d94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adfb241b0d90ee47cc3885d2c24c70d94">dr_rwlock_write_unlock</a> (void *rwlock)</td></tr>
<tr class="separator:adfb241b0d90ee47cc3885d2c24c70d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e812e134e71ea3b844387a75bfc273"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac7e812e134e71ea3b844387a75bfc273">dr_rwlock_write_trylock</a> (void *rwlock)</td></tr>
<tr class="separator:ac7e812e134e71ea3b844387a75bfc273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9b30addf3e5bf910109061159aef01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeb9b30addf3e5bf910109061159aef01">dr_rwlock_self_owns_write_lock</a> (void *rwlock)</td></tr>
<tr class="separator:aeb9b30addf3e5bf910109061159aef01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e6105ff0e2a3593f5ef296074e21e2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac3e6105ff0e2a3593f5ef296074e21e2">dr_rwlock_mark_as_app</a> (void *rwlock)</td></tr>
<tr class="separator:ac3e6105ff0e2a3593f5ef296074e21e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5563eff378a7e2ea61b7dd7fcd777a36"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5563eff378a7e2ea61b7dd7fcd777a36">dr_recurlock_create</a> (void)</td></tr>
<tr class="separator:a5563eff378a7e2ea61b7dd7fcd777a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a203f4a8ebcc35d50e51ed31a51b1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af7a203f4a8ebcc35d50e51ed31a51b1f">dr_recurlock_destroy</a> (void *reclock)</td></tr>
<tr class="separator:af7a203f4a8ebcc35d50e51ed31a51b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5a80009a8f667b86acb529fbc75ac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abf5a80009a8f667b86acb529fbc75ac4">dr_recurlock_lock</a> (void *reclock)</td></tr>
<tr class="separator:abf5a80009a8f667b86acb529fbc75ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d36a11978be634e28116da9dd408030"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7d36a11978be634e28116da9dd408030">dr_recurlock_unlock</a> (void *reclock)</td></tr>
<tr class="separator:a7d36a11978be634e28116da9dd408030"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d473debdc03a782d8aa5032fb3dd97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a16d473debdc03a782d8aa5032fb3dd97">dr_recurlock_trylock</a> (void *reclock)</td></tr>
<tr class="separator:a16d473debdc03a782d8aa5032fb3dd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33bd56345cfb4286a05e0c3eab6b3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac33bd56345cfb4286a05e0c3eab6b3a0">dr_recurlock_self_owns</a> (void *reclock)</td></tr>
<tr class="separator:ac33bd56345cfb4286a05e0c3eab6b3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a376d41758da76279edfe5f649382feb7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a376d41758da76279edfe5f649382feb7">dr_recurlock_mark_as_app</a> (void *reclock)</td></tr>
<tr class="separator:a376d41758da76279edfe5f649382feb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d121869aba7466a553effe8356bf5e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a28d121869aba7466a553effe8356bf5e">dr_mark_safe_to_suspend</a> (void *drcontext, bool enter)</td></tr>
<tr class="separator:a28d121869aba7466a553effe8356bf5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a669ec1a44523f58c52378020ecd87ccf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a669ec1a44523f58c52378020ecd87ccf">dr_atomic_add32_return_sum</a> (volatile int *x, int val)</td></tr>
<tr class="separator:a669ec1a44523f58c52378020ecd87ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4892d089da710e952a23055bd7db38af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a4892d089da710e952a23055bd7db38af">dr_lookup_module</a> (byte *pc)</td></tr>
<tr class="separator:a4892d089da710e952a23055bd7db38af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd653edd3322cfb025ef8bdc6ae1060"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#addd653edd3322cfb025ef8bdc6ae1060">dr_lookup_module_by_name</a> (const char *name)</td></tr>
<tr class="separator:addd653edd3322cfb025ef8bdc6ae1060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e44337705f8c8a2368427bcb69ca73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a21e44337705f8c8a2368427bcb69ca73">dr_get_main_module</a> (void)</td></tr>
<tr class="separator:a21e44337705f8c8a2368427bcb69ca73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3310b1bfc22da285af72b1a4a9d10945"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3310b1bfc22da285af72b1a4a9d10945">dr_module_iterator_start</a> (void)</td></tr>
<tr class="separator:a3310b1bfc22da285af72b1a4a9d10945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1702cf25e24e722d9441f92c41fac33e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1702cf25e24e722d9441f92c41fac33e">dr_module_iterator_hasnext</a> (<a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>
<tr class="separator:a1702cf25e24e722d9441f92c41fac33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d49edb3a7b59f5d817afaa8fc0f1ef9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next</a> (<a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>
<tr class="separator:a9d49edb3a7b59f5d817afaa8fc0f1ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15134844f1dd3e914c0da59c65cb3a8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a15134844f1dd3e914c0da59c65cb3a8d">dr_module_iterator_stop</a> (<a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *mi)</td></tr>
<tr class="separator:a15134844f1dd3e914c0da59c65cb3a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c99a2d79ed312cd852d57e975601adc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data</a> (const <a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>
<tr class="separator:a8c99a2d79ed312cd852d57e975601adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad72ba1e8b98c8e01f2c28ef2e4d3e16e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data</a> (<a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>
<tr class="separator:ad72ba1e8b98c8e01f2c28ef2e4d3e16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082fe71b00688310237fbc2e027c4388"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a082fe71b00688310237fbc2e027c4388">dr_module_preferred_name</a> (const <a class="el" href="struct__module__data__t.html">module_data_t</a> *data)</td></tr>
<tr class="separator:a082fe71b00688310237fbc2e027c4388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cac1e57889ba7d16815d8d3b203f256"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3cac1e57889ba7d16815d8d3b203f256">dr_module_contains_addr</a> (const <a class="el" href="struct__module__data__t.html">module_data_t</a> *data, app_pc addr)</td></tr>
<tr class="separator:a3cac1e57889ba7d16815d8d3b203f256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4208bf4fd46868975824d1c865f370e"><td class="memItemLeft" align="right" valign="top">dr_module_import_iterator_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab4208bf4fd46868975824d1c865f370e">dr_module_import_iterator_start</a> (module_handle_t handle)</td></tr>
<tr class="separator:ab4208bf4fd46868975824d1c865f370e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa057e58c848b5860617a10014f828f45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa057e58c848b5860617a10014f828f45">dr_module_import_iterator_hasnext</a> (dr_module_import_iterator_t *iter)</td></tr>
<tr class="separator:aa057e58c848b5860617a10014f828f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9863e3f8ac53d7b1d1c023e00c6ec4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#a20e62023d3be1c972a03ac53f15aff55">dr_module_import_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae9863e3f8ac53d7b1d1c023e00c6ec4a">dr_module_import_iterator_next</a> (dr_module_import_iterator_t *iter)</td></tr>
<tr class="separator:ae9863e3f8ac53d7b1d1c023e00c6ec4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3767d9282831c030307c9d89cd8c081b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3767d9282831c030307c9d89cd8c081b">dr_module_import_iterator_stop</a> (dr_module_import_iterator_t *iter)</td></tr>
<tr class="separator:a3767d9282831c030307c9d89cd8c081b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4b0ee00f77ddf42c5094735b1fc615"><td class="memItemLeft" align="right" valign="top">dr_symbol_import_iterator_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a6e4b0ee00f77ddf42c5094735b1fc615">dr_symbol_import_iterator_start</a> (module_handle_t handle, dr_module_import_desc_t *from_module)</td></tr>
<tr class="separator:a6e4b0ee00f77ddf42c5094735b1fc615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84b16b985754da06d7c8a864dfed2b44"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a84b16b985754da06d7c8a864dfed2b44">dr_symbol_import_iterator_hasnext</a> (dr_symbol_import_iterator_t *iter)</td></tr>
<tr class="separator:a84b16b985754da06d7c8a864dfed2b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b3e34e05cf82fb5b5801389eab835d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#a97862b54ff9ef6f20494449ff47242e6">dr_symbol_import_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af3b3e34e05cf82fb5b5801389eab835d">dr_symbol_import_iterator_next</a> (dr_symbol_import_iterator_t *iter)</td></tr>
<tr class="separator:af3b3e34e05cf82fb5b5801389eab835d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b57decf95101db3153968868c126e38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9b57decf95101db3153968868c126e38">dr_symbol_import_iterator_stop</a> (dr_symbol_import_iterator_t *iter)</td></tr>
<tr class="separator:a9b57decf95101db3153968868c126e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa00ccf3ea50bcfa7bb7623565bfb41"><td class="memItemLeft" align="right" valign="top">dr_symbol_export_iterator_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#adaa00ccf3ea50bcfa7bb7623565bfb41">dr_symbol_export_iterator_start</a> (module_handle_t handle)</td></tr>
<tr class="separator:adaa00ccf3ea50bcfa7bb7623565bfb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9913028815c4a9f76a14871b9f1d74d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9913028815c4a9f76a14871b9f1d74d3">dr_symbol_export_iterator_hasnext</a> (dr_symbol_export_iterator_t *iter)</td></tr>
<tr class="separator:a9913028815c4a9f76a14871b9f1d74d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84a9316bfb47fb3a854bf371da4e2190"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__tools_8h.html#a5f313b8ed7cdc35283e82a59a6492077">dr_symbol_export_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a84a9316bfb47fb3a854bf371da4e2190">dr_symbol_export_iterator_next</a> (dr_symbol_export_iterator_t *iter)</td></tr>
<tr class="separator:a84a9316bfb47fb3a854bf371da4e2190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab1fb16deb7bdec1216e61bbc265cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3ab1fb16deb7bdec1216e61bbc265cdb">dr_symbol_export_iterator_stop</a> (dr_symbol_export_iterator_t *iter)</td></tr>
<tr class="separator:a3ab1fb16deb7bdec1216e61bbc265cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac520aa05555ecbf9e525de582d4baa8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac520aa05555ecbf9e525de582d4baa8c">dr_lookup_module_section</a> (module_handle_t lib, byte *pc, IMAGE_SECTION_HEADER *section_out)</td></tr>
<tr class="separator:ac520aa05555ecbf9e525de582d4baa8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a02be4399639cc9c62cd38979f650f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a40a02be4399639cc9c62cd38979f650f">dr_module_set_should_instrument</a> (module_handle_t handle, bool should_instrument)</td></tr>
<tr class="separator:a40a02be4399639cc9c62cd38979f650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9bfd8b7be4967b8caa349e274cd7ea3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab9bfd8b7be4967b8caa349e274cd7ea3">dr_module_should_instrument</a> (module_handle_t handle)</td></tr>
<tr class="separator:ab9bfd8b7be4967b8caa349e274cd7ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da7923ecc4e020e31442bcc8d9f8d3e"><td class="memItemLeft" align="right" valign="top">generic_func_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address</a> (module_handle_t lib, const char *name)</td></tr>
<tr class="separator:a8da7923ecc4e020e31442bcc8d9f8d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1a068ad89408abbcfba026706810211"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af1a068ad89408abbcfba026706810211">dr_get_proc_address_ex</a> (module_handle_t lib, const char *name, <a class="el" href="dr__tools_8h.html#af3e96c875a305558239b74496c4030d0">dr_export_info_t</a> *info OUT, size_t info_len)</td></tr>
<tr class="separator:af1a068ad89408abbcfba026706810211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa88dc6d5b9bf7a3ce2cd907f87eba902"><td class="memItemLeft" align="right" valign="top">byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa88dc6d5b9bf7a3ce2cd907f87eba902">dr_map_executable_file</a> (const char *filename, <a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a> flags, size_t *size OUT)</td></tr>
<tr class="separator:aa88dc6d5b9bf7a3ce2cd907f87eba902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85779d0a5147a550f263a4381fff5ab5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a85779d0a5147a550f263a4381fff5ab5">dr_unmap_executable_file</a> (byte *base, size_t size)</td></tr>
<tr class="separator:a85779d0a5147a550f263a4381fff5ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e01fe123ecc9908ada9c9fccbf3f6ab"><td class="memItemLeft" align="right" valign="top">reg_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1e01fe123ecc9908ada9c9fccbf3f6ab">dr_syscall_get_param</a> (void *drcontext, int param_num)</td></tr>
<tr class="separator:a1e01fe123ecc9908ada9c9fccbf3f6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21a83f1812443112303ef3ea8b76de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param</a> (void *drcontext, int param_num, reg_t new_value)</td></tr>
<tr class="separator:ac21a83f1812443112303ef3ea8b76de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12463724bf63a891e991891c72e6a4b"><td class="memItemLeft" align="right" valign="top">reg_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad12463724bf63a891e991891c72e6a4b">dr_syscall_get_result</a> (void *drcontext)</td></tr>
<tr class="separator:ad12463724bf63a891e991891c72e6a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4cf94bfc4dca2deb04699c28a56e55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0e4cf94bfc4dca2deb04699c28a56e55">dr_syscall_get_result_ex</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a> *info INOUT)</td></tr>
<tr class="separator:a0e4cf94bfc4dca2deb04699c28a56e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601cd2b724ac627aef0756a4c4eee637"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a601cd2b724ac627aef0756a4c4eee637">dr_syscall_set_result</a> (void *drcontext, reg_t value)</td></tr>
<tr class="separator:a601cd2b724ac627aef0756a4c4eee637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae7ca4aa76652ddaaacb1e8dad9f6af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aaae7ca4aa76652ddaaacb1e8dad9f6af">dr_syscall_set_result_ex</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a> *info)</td></tr>
<tr class="separator:aaae7ca4aa76652ddaaacb1e8dad9f6af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc80dfdf8bff3c3feb486aacd69aba7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum</a> (void *drcontext, int new_num)</td></tr>
<tr class="separator:abc80dfdf8bff3c3feb486aacd69aba7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76797a9310bf67ebeb820d80e11764b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another</a> (void *drcontext)</td></tr>
<tr class="separator:a76797a9310bf67ebeb820d80e11764b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3747468d00df5cdc597688e1e079a64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae3747468d00df5cdc597688e1e079a64">dr_syscall_intercept_natively</a> (const char *name, int sysnum, int num_args, int wow64_index)</td></tr>
<tr class="separator:ae3747468d00df5cdc597688e1e079a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ee2651cad7bafe65f3df7d4aeb82120"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1ee2651cad7bafe65f3df7d4aeb82120">dr_create_dir</a> (const char *fname)</td></tr>
<tr class="separator:a1ee2651cad7bafe65f3df7d4aeb82120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0da447546ca8dd194a993607d66ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aab0da447546ca8dd194a993607d66ecb">dr_delete_dir</a> (const char *fname)</td></tr>
<tr class="separator:aab0da447546ca8dd194a993607d66ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2e62195a2732b0f5c1004138b800a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aae2e62195a2732b0f5c1004138b800a6">dr_get_current_directory</a> (char *buf, size_t bufsz)</td></tr>
<tr class="separator:aae2e62195a2732b0f5c1004138b800a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f86a68a105442a029baa05a1af9d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a02f86a68a105442a029baa05a1af9d57">dr_directory_exists</a> (const char *fname)</td></tr>
<tr class="separator:a02f86a68a105442a029baa05a1af9d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af471633d0954d80c09ca6c2bfe40475b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af471633d0954d80c09ca6c2bfe40475b">dr_file_exists</a> (const char *fname)</td></tr>
<tr class="separator:af471633d0954d80c09ca6c2bfe40475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3ae2190774a204af207602791a32cb6"><td class="memItemLeft" align="right" valign="top">file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae3ae2190774a204af207602791a32cb6">dr_open_file</a> (const char *fname, uint mode_flags)</td></tr>
<tr class="separator:ae3ae2190774a204af207602791a32cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25b305e0be9f6c09f9761b14f3bbc74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac25b305e0be9f6c09f9761b14f3bbc74">dr_close_file</a> (file_t f)</td></tr>
<tr class="separator:ac25b305e0be9f6c09f9761b14f3bbc74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab23dff0c2d6d045cd938fc5f2c77a1ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab23dff0c2d6d045cd938fc5f2c77a1ff">dr_rename_file</a> (const char *src, const char *dst, bool replace)</td></tr>
<tr class="separator:ab23dff0c2d6d045cd938fc5f2c77a1ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce7b5b2390cb5e03466cd605735bdfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7ce7b5b2390cb5e03466cd605735bdfc">dr_delete_file</a> (const char *filename)</td></tr>
<tr class="separator:a7ce7b5b2390cb5e03466cd605735bdfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae51098d1c742e3189a197db0c212eaa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae51098d1c742e3189a197db0c212eaa9">dr_flush_file</a> (file_t f)</td></tr>
<tr class="separator:ae51098d1c742e3189a197db0c212eaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddf708cc2271dc50209b3e78e1d23fb"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file</a> (file_t f, const void *buf, size_t count)</td></tr>
<tr class="separator:aeddf708cc2271dc50209b3e78e1d23fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71f6940085912cdce608f317a27fc397"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a71f6940085912cdce608f317a27fc397">dr_read_file</a> (file_t f, void *buf, size_t count)</td></tr>
<tr class="separator:a71f6940085912cdce608f317a27fc397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c2c9d68ceceef8c6455b06502667ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a18c2c9d68ceceef8c6455b06502667ee">dr_file_seek</a> (file_t f, int64 offset, int origin)</td></tr>
<tr class="separator:a18c2c9d68ceceef8c6455b06502667ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc1d26f3050d6f361e7b07f98c7e82d"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1fc1d26f3050d6f361e7b07f98c7e82d">dr_file_tell</a> (file_t f)</td></tr>
<tr class="separator:a1fc1d26f3050d6f361e7b07f98c7e82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ef4b43d78d787c7622569d30717051"><td class="memItemLeft" align="right" valign="top">file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a66ef4b43d78d787c7622569d30717051">dr_dup_file_handle</a> (file_t f)</td></tr>
<tr class="separator:a66ef4b43d78d787c7622569d30717051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a8173579db03d018935afb1ca891f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a06a8173579db03d018935afb1ca891f6">dr_file_size</a> (file_t fd, OUT uint64 *size)</td></tr>
<tr class="separator:a06a8173579db03d018935afb1ca891f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d3a723c65e3762dd62b115577e0625"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af7d3a723c65e3762dd62b115577e0625">dr_map_file</a> (file_t f, INOUT size_t *size, uint64 offs, app_pc addr, uint prot, uint flags)</td></tr>
<tr class="separator:af7d3a723c65e3762dd62b115577e0625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f36900cafd048db5b8d34cf92faa45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae7f36900cafd048db5b8d34cf92faa45">dr_unmap_file</a> (void *map, size_t size)</td></tr>
<tr class="separator:ae7f36900cafd048db5b8d34cf92faa45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332a14861f12823994465e8c9b6a3015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a332a14861f12823994465e8c9b6a3015">dr_log</a> (void *drcontext, uint mask, uint level, const char *fmt,...)</td></tr>
<tr class="separator:a332a14861f12823994465e8c9b6a3015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7e9d485a84aa147e0ec0e75ad6d962"><td class="memItemLeft" align="right" valign="top">file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afd7e9d485a84aa147e0ec0e75ad6d962">dr_get_logfile</a> (void *drcontext)</td></tr>
<tr class="separator:afd7e9d485a84aa147e0ec0e75ad6d962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af91a810b83f1173a5720a955c3d0fd4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af91a810b83f1173a5720a955c3d0fd4a">dr_is_notify_on</a> (void)</td></tr>
<tr class="separator:af91a810b83f1173a5720a955c3d0fd4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0353e78f517dc281de22539682d9e6d9"><td class="memItemLeft" align="right" valign="top">file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a0353e78f517dc281de22539682d9e6d9">dr_get_stdout_file</a> (void)</td></tr>
<tr class="separator:a0353e78f517dc281de22539682d9e6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20dccb3e2b03e8f408b2a340c70a28e2"><td class="memItemLeft" align="right" valign="top">file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a20dccb3e2b03e8f408b2a340c70a28e2">dr_get_stderr_file</a> (void)</td></tr>
<tr class="separator:a20dccb3e2b03e8f408b2a340c70a28e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed162d7ad949b05fe8232771eaeca6a9"><td class="memItemLeft" align="right" valign="top">file_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aed162d7ad949b05fe8232771eaeca6a9">dr_get_stdin_file</a> (void)</td></tr>
<tr class="separator:aed162d7ad949b05fe8232771eaeca6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad444a204e7ca45f9965cfe973470375a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad444a204e7ca45f9965cfe973470375a">dr_messagebox</a> (const char *fmt,...)</td></tr>
<tr class="separator:ad444a204e7ca45f9965cfe973470375a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad2eddb3786e3e909ff36da39b7e31e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf</a> (const char *fmt,...)</td></tr>
<tr class="separator:abad2eddb3786e3e909ff36da39b7e31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1affb1a9f1c49c1959f1a01967a0a0d9"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1affb1a9f1c49c1959f1a01967a0a0d9">dr_fprintf</a> (file_t f, const char *fmt,...)</td></tr>
<tr class="separator:a1affb1a9f1c49c1959f1a01967a0a0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a712de67b3f6adb6778ce302925009753"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing</a> (void)</td></tr>
<tr class="separator:a712de67b3f6adb6778ce302925009753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a505318c1ece53cdaff85f387dc6bf758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a505318c1ece53cdaff85f387dc6bf758">dr_using_console</a> (void)</td></tr>
<tr class="separator:a505318c1ece53cdaff85f387dc6bf758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c5f2529d9c076b5b0b0e92a70834b7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf</a> (char *buf, size_t max, const char *fmt,...)</td></tr>
<tr class="separator:ab0c5f2529d9c076b5b0b0e92a70834b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c362b4605972c0d54142c4469e45c6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a67c362b4605972c0d54142c4469e45c6">dr_snwprintf</a> (wchar_t *buf, size_t max, const wchar_t *fmt,...)</td></tr>
<tr class="separator:a67c362b4605972c0d54142c4469e45c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6b928d8cbc48fdf7d1d82c4fa95e40e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ad6b928d8cbc48fdf7d1d82c4fa95e40e">dr_vsnprintf</a> (char *buf, size_t max, const char *fmt, va_list ap)</td></tr>
<tr class="separator:ad6b928d8cbc48fdf7d1d82c4fa95e40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89fd0244d2133a1e37b5b6662a41cc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa89fd0244d2133a1e37b5b6662a41cc6">dr_vsnwprintf</a> (wchar_t *buf, size_t max, const wchar_t *fmt, va_list ap)</td></tr>
<tr class="separator:aa89fd0244d2133a1e37b5b6662a41cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae227695587313ae94369e43e459ee762"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae227695587313ae94369e43e459ee762">dr_sscanf</a> (const char *str, const char *fmt,...)</td></tr>
<tr class="separator:ae227695587313ae94369e43e459ee762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5567896b7c8fb25bff984fc6717f566"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae5567896b7c8fb25bff984fc6717f566">dr_get_token</a> (const char *str, char *buf, size_t buflen)</td></tr>
<tr class="separator:ae5567896b7c8fb25bff984fc6717f566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecb77c99028d913a72c6aaeef48db785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aecb77c99028d913a72c6aaeef48db785">dr_print_instr</a> (void *drcontext, file_t f, <a class="el" href="structinstr__t.html">instr_t</a> *instr, const char *msg)</td></tr>
<tr class="separator:aecb77c99028d913a72c6aaeef48db785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5902fa16202c9c42d96c755e9412d372"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5902fa16202c9c42d96c755e9412d372">dr_print_opnd</a> (void *drcontext, file_t f, <a class="el" href="structopnd__t.html">opnd_t</a> opnd, const char *msg)</td></tr>
<tr class="separator:a5902fa16202c9c42d96c755e9412d372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13217cc252506b06184c7c72adedf26c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext</a> (void)</td></tr>
<tr class="separator:a13217cc252506b06184c7c72adedf26c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3980d703cc13379a6b57396a7901b1d1"><td class="memItemLeft" align="right" valign="top">thread_id_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a3980d703cc13379a6b57396a7901b1d1">dr_get_thread_id</a> (void *drcontext)</td></tr>
<tr class="separator:a3980d703cc13379a6b57396a7901b1d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a820a6c60659ad40d59f7b574d671574d"><td class="memItemLeft" align="right" valign="top">HANDLE&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a820a6c60659ad40d59f7b574d671574d">dr_get_dr_thread_handle</a> (void *drcontext)</td></tr>
<tr class="separator:a820a6c60659ad40d59f7b574d671574d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787aff5df1ded3de8a7ce9f3efef0594"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field</a> (void *drcontext)</td></tr>
<tr class="separator:a787aff5df1ded3de8a7ce9f3efef0594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b499c8a3115e9ceb4c45dbee660738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a05b499c8a3115e9ceb4c45dbee660738">dr_set_tls_field</a> (void *drcontext, void *value)</td></tr>
<tr class="separator:a05b499c8a3115e9ceb4c45dbee660738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25889ae165da2ece91e591f3a8a32650"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a25889ae165da2ece91e591f3a8a32650">dr_get_dr_segment_base</a> (IN <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register)</td></tr>
<tr class="separator:a25889ae165da2ece91e591f3a8a32650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4bc51b4771fceb56f050d0f20cbc99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aea4bc51b4771fceb56f050d0f20cbc99">dr_raw_tls_calloc</a> (OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *tls_register, OUT uint *offset, IN uint num_slots, IN uint alignment)</td></tr>
<tr class="separator:aea4bc51b4771fceb56f050d0f20cbc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc53219d019078a38c80ffa80d71829e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afc53219d019078a38c80ffa80d71829e">dr_raw_tls_cfree</a> (uint offset, uint num_slots)</td></tr>
<tr class="separator:afc53219d019078a38c80ffa80d71829e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58eaa896c06cf679d299b804d6669926"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a58eaa896c06cf679d299b804d6669926">dr_raw_tls_opnd</a> (void *drcontext, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register, uint tls_offs)</td></tr>
<tr class="separator:a58eaa896c06cf679d299b804d6669926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69f21285d41fe00b3f4231fcbaf39b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac69f21285d41fe00b3f4231fcbaf39b3">dr_insert_read_raw_tls</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register, uint tls_offs, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:ac69f21285d41fe00b3f4231fcbaf39b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481c4c988efd4d81ce0a92fe0cc3f276"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a481c4c988efd4d81ce0a92fe0cc3f276">dr_insert_write_raw_tls</a> (void *drcontext, instrlist_t *ilist, <a class="el" href="structinstr__t.html">instr_t</a> *where, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> tls_register, uint tls_offs, <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> reg)</td></tr>
<tr class="separator:a481c4c988efd4d81ce0a92fe0cc3f276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b80b83502ff13d4674b13e7b30b555"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread</a> (void(*func)(void *param), void *arg)</td></tr>
<tr class="separator:ac6b80b83502ff13d4674b13e7b30b555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af57b95b87d8da29a16ca923a5b1b98b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af57b95b87d8da29a16ca923a5b1b98b3">dr_client_thread_set_suspendable</a> (bool suspendable)</td></tr>
<tr class="separator:af57b95b87d8da29a16ca923a5b1b98b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af154e498d8b185931ef970676cb65351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#af154e498d8b185931ef970676cb65351">dr_sleep</a> (int time_ms)</td></tr>
<tr class="separator:af154e498d8b185931ef970676cb65351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac262422c1e5e487113176bd4193c387f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac262422c1e5e487113176bd4193c387f">dr_thread_yield</a> (void)</td></tr>
<tr class="separator:ac262422c1e5e487113176bd4193c387f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c0a1bdefb011cf62eb2540e933cb331"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a8c0a1bdefb011cf62eb2540e933cb331">dr_suspend_all_other_threads_ex</a> (OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended, <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a> flags)</td></tr>
<tr class="separator:a8c0a1bdefb011cf62eb2540e933cb331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fbe357fcc8352ba63c9a1a23e0c207"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads</a> (OUT void ***drcontexts, OUT uint *num_suspended, OUT uint *num_unsuspended)</td></tr>
<tr class="separator:a01fbe357fcc8352ba63c9a1a23e0c207"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1193842150b09442a1b3c91f4e02d280"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1193842150b09442a1b3c91f4e02d280">dr_resume_all_other_threads</a> (IN void **drcontexts, IN uint num_suspended)</td></tr>
<tr class="separator:a1193842150b09442a1b3c91f4e02d280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f74b6f40f9462fe077f4b2cabc6b933"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9f74b6f40f9462fe077f4b2cabc6b933">dr_is_thread_native</a> (void *drcontext)</td></tr>
<tr class="separator:a9f74b6f40f9462fe077f4b2cabc6b933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36206cb11622f8c9aee12016e916a190"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a36206cb11622f8c9aee12016e916a190">dr_retakeover_suspended_native_thread</a> (void *drcontext)</td></tr>
<tr class="separator:a36206cb11622f8c9aee12016e916a190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9191c67a267070ed51289d7192f986aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9191c67a267070ed51289d7192f986aa">dr_set_itimer</a> (int which, uint millisec, void(*func)(void *drcontext, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mcontext))</td></tr>
<tr class="separator:a9191c67a267070ed51289d7192f986aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cd85ea911bd99dedbd8d05796260bc"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ab5cd85ea911bd99dedbd8d05796260bc">dr_get_itimer</a> (int which)</td></tr>
<tr class="separator:ab5cd85ea911bd99dedbd8d05796260bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5421c0abd69da94ed3e7fb898d5bb132"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a5421c0abd69da94ed3e7fb898d5bb132">dr_replace_fragment</a> (void *drcontext, void *tag, instrlist_t *ilist)</td></tr>
<tr class="separator:a5421c0abd69da94ed3e7fb898d5bb132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7600cc31d68dc0e30ab91261d08836ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7600cc31d68dc0e30ab91261d08836ed">dr_delete_fragment</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a7600cc31d68dc0e30ab91261d08836ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe87d17869a51a66d59eecf459d71cc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#abe87d17869a51a66d59eecf459d71cc0">dr_flush_region</a> (app_pc start, size_t size)</td></tr>
<tr class="separator:abe87d17869a51a66d59eecf459d71cc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56909cf76e4a71fca13731053ef48928"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region</a> (app_pc start, size_t size)</td></tr>
<tr class="separator:a56909cf76e4a71fca13731053ef48928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa5ea6649e644074ca55f456c89264e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region</a> (app_pc start, size_t size, uint flush_id, void(*flush_completion_callback)(int flush_id))</td></tr>
<tr class="separator:afa5ea6649e644074ca55f456c89264e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a775fdf1d5a55b5fbca094a4d2f18d28f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a775fdf1d5a55b5fbca094a4d2f18d28f">dr_fragment_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a775fdf1d5a55b5fbca094a4d2f18d28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad3b09e886366ac10341e69a577555dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aad3b09e886366ac10341e69a577555dd">dr_bb_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:aad3b09e886366ac10341e69a577555dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe1f6436b234406bde1970ecfa614b5"><td class="memItemLeft" align="right" valign="top">uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acfe1f6436b234406bde1970ecfa614b5">dr_fragment_size</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:acfe1f6436b234406bde1970ecfa614b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724aa7f7e87a604071fffa0a01925bf0"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a724aa7f7e87a604071fffa0a01925bf0">dr_fragment_app_pc</a> (void *tag)</td></tr>
<tr class="separator:a724aa7f7e87a604071fffa0a01925bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd67a10cd03a382853a0523bde9990f5"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#acd67a10cd03a382853a0523bde9990f5">dr_app_pc_for_decoding</a> (app_pc pc)</td></tr>
<tr class="separator:acd67a10cd03a382853a0523bde9990f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac150776be7e338321cbb8edc49ab7790"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ac150776be7e338321cbb8edc49ab7790">dr_app_pc_from_cache_pc</a> (byte *cache_pc)</td></tr>
<tr class="separator:ac150776be7e338321cbb8edc49ab7790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed94a2b046bb9ee777afe4f3ef1237f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a7ed94a2b046bb9ee777afe4f3ef1237f">dr_using_app_state</a> (void *drcontext)</td></tr>
<tr class="separator:a7ed94a2b046bb9ee777afe4f3ef1237f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2944aa54d591a236f5334a35bfb41bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state</a> (void *drcontext)</td></tr>
<tr class="separator:aa2944aa54d591a236f5334a35bfb41bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae937ce8bbb24330c25acd6d1c04cb5a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#ae937ce8bbb24330c25acd6d1c04cb5a0">dr_switch_to_app_state_ex</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70">dr_state_flags_t</a> flags)</td></tr>
<tr class="separator:ae937ce8bbb24330c25acd6d1c04cb5a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97ba972c50a47e7121c98652b461ae8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state</a> (void *drcontext)</td></tr>
<tr class="separator:a97ba972c50a47e7121c98652b461ae8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994e632ea892a947612b44027467ea2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a994e632ea892a947612b44027467ea2b">dr_switch_to_dr_state_ex</a> (void *drcontext, <a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70">dr_state_flags_t</a> flags)</td></tr>
<tr class="separator:a994e632ea892a947612b44027467ea2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e262e93823dbc5914eca34540afbc07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a9e262e93823dbc5914eca34540afbc07">dr_mark_trace_head</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a9e262e93823dbc5914eca34540afbc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e3f7e4e3e4048021966c04a4b00fbc9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1e3f7e4e3e4048021966c04a4b00fbc9">dr_trace_head_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a1e3f7e4e3e4048021966c04a4b00fbc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4c9a29f1c962457c123322aa3e1931"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__tools_8h.html#a1d4c9a29f1c962457c123322aa3e1931">dr_trace_exists_at</a> (void *drcontext, void *tag)</td></tr>
<tr class="separator:a1d4c9a29f1c962457c123322aa3e1931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Main API routines, including transparency support. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a7af2dcd801f468cdc1cce40f7e885ffc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BB_ORIGIN_HEADER_SIZE&#160;&#160;&#160;(sizeof(app_pc)+sizeof(int))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of tag + bb_code_size fields for each bb. <a class="el" href="struct__tracedump__stub__data.html#ab397d14965f6ac0c4f0c28a36f667200">tracedump_stub_data_t.stub_size</a> will not exceed this value. </p>

</div>
</div>
<a class="anchor" id="a7c07630dffdfd92bc6ee63abf405768c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#abd6d066ab9bdd578d4000e80df8503bc">DR_ASSERT_MSG</a>(x, &quot;&quot;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If <code>x</code> is false, displays a message about an assertion failure and then calls <a class="el" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort()</a> </p>

</div>
</div>
<a class="anchor" id="abd6d066ab9bdd578d4000e80df8503bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_ASSERT_MSG</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">msg&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((void)((!(x)) ? \</div>
<div class="line">        (<a class="code" href="dr__tools_8h.html#ad444a204e7ca45f9965cfe973470375a">dr_messagebox</a>(<span class="stringliteral">&quot;ASSERT FAILURE: %s:%d: %s (%s)&quot;</span>, __FILE__,  __LINE__, #x, msg),\</div>
<div class="line">         dr_abort(), 0) : 0))</div>
<div class="ttc" id="dr__tools_8h_html_ad444a204e7ca45f9965cfe973470375a"><div class="ttname"><a href="dr__tools_8h.html#ad444a204e7ca45f9965cfe973470375a">dr_messagebox</a></div><div class="ttdeci">void dr_messagebox(const char *fmt,...)</div></div>
</div><!-- fragment --><p>If <code>x</code> is false, displays a message about an assertion failure (appending <code>msg</code> to the message) and then calls <a class="el" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort()</a> </p>

</div>
</div>
<a class="anchor" id="a77a3b276c8d9a62bf6d78c3707d4effd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_ALLOW_LARGE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with large (&gt;2GB) file support. Only applicable on 32-bit Linux. </p><dl class="section note"><dt>Note</dt><dd>DR's log files and tracedump files are all created with this flag. </dd></dl>

</div>
</div>
<a class="anchor" id="a0401a3003f578602bf31a984a4d5419d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_CLOSE_ON_FORK&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Linux-only. This file will be closed in the child of a fork. </p>

</div>
</div>
<a class="anchor" id="ad0772bc47090cec1a333baf1259f226d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_READ&#160;&#160;&#160;0x1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with read access. </p>

</div>
</div>
<a class="anchor" id="ac989ab040f48c4c91cc3a6ea63f9ec1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_APPEND&#160;&#160;&#160;0x4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write access. If the file already exists, set the file position to the end of the file. </p>

</div>
</div>
<a class="anchor" id="ac71a8471b604df56ae2fa05ba66e03be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_ONLY&#160;&#160;&#160;0x40</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write-only access. Meant for use with pipes. Linux-only. Mutually exclusive with DR_FILE_WRITE_REQUIRE_NEW, DR_FILE_WRITE_APPEND, and DR_FILE_WRITE_OVERWRITE. </p>

</div>
</div>
<a class="anchor" id="a5fb30eb2b5d14486b3ecbc2b2457dfdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_OVERWRITE&#160;&#160;&#160;0x8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write access. If the file already exists, truncate the file to zero length. </p>

</div>
</div>
<a class="anchor" id="a11f713faf2e1eac95bc26a98b67e28cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_FILE_WRITE_REQUIRE_NEW&#160;&#160;&#160;0x2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open with write access, but do not open if the file already exists. </p>

</div>
</div>
<a class="anchor" id="ad98be75b6fde3dc1dbfb8bfda59fce66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_EXEC&#160;&#160;&#160;0x04</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Execute privileges. </p>

</div>
</div>
<a class="anchor" id="af8bb4e765c888211477c17e73abf992f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_GUARD&#160;&#160;&#160;0x08</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Guard page (Windows only) </p>

</div>
</div>
<a class="anchor" id="ac2c501052e751bc9c72c622b1ca8b96c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_NONE&#160;&#160;&#160;0x00</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>No read, write, or execute privileges. </p>

</div>
</div>
<a class="anchor" id="a0dcb0f62864c67d1aa74381035b5bbfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_PRETEND_WRITE&#160;&#160;&#160;0x10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DR's default cache consistency strategy modifies the page protection of pages containing code, making them read-only. It pretends on application and client queries that the page is writable. On a write fault to such a region by the application or by client-added instrumentation, DR automatically handles the fault and makes the page writable. This requires flushing the code from the code cache, which can only be done safely when in an application context. Thus, a client writing to such a page is only supported when these criteria are met:</p>
<ol type="1">
<li>The client code must be in an application code cache context. This rules out all event callbacks (including the basic block event) except for the pre and post system call events and the nudge event.</li>
<li>The client must not hold any locks. An exception is a lock marked as an application lock (via <a class="el" href="dr__tools_8h.html#a9accc32bf0c9c784516a7ce5373a3d2b">dr_mutex_mark_as_app()</a>, <a class="el" href="dr__tools_8h.html#ac3e6105ff0e2a3593f5ef296074e21e2">dr_rwlock_mark_as_app()</a>, or <a class="el" href="dr__tools_8h.html#a376d41758da76279edfe5f649382feb7">dr_recurlock_mark_as_app()</a>).</li>
<li>The client code must not rely on returning to a particular point in the code cache, as that point might be flushed and removed during the write fault processing. This rules out a clean call (unless <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> is used), but does allow something like <a class="el" href="group__drwrap.html#ga0ae2e383b0005a46848c7d0497be563a">drwrap_replace_native()</a> which uses a continuation strategy.</li>
</ol>
<p>A client write fault that does not meet the first two criteria will result in a fatal error report and an abort. It is up to the client to ensure it satisifies the third criterion.</p>
<p>Even when client writes do meet these criteria, for performance it's best for clients to avoid writing to such memory. </p>

</div>
</div>
<a class="anchor" id="ab430d92dd0d6338ec3e42b527ae91efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_READ&#160;&#160;&#160;0x01</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read privileges. </p>

</div>
</div>
<a class="anchor" id="ac9c33a04e71ed6d6ec41e26013a005fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_VDSO&#160;&#160;&#160;0x20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In addition to the appropriate DR_MEMPROT_READ and/or DR_MEMPROT_EXEC flags, this flag will be set for the VDSO and VVAR pages on Linux. The VVAR pages may only be identified by DR on kernels that explicitly label the pages in the /proc/self/maps file (kernel 3.15 and above). In some cases, accessing the VVAR pages can cause problems (e.g., <a href="https://github.com/DynamoRIO/drmemory/issues/1778">https://github.com/DynamoRIO/drmemory/issues/1778</a>). </p>

</div>
</div>
<a class="anchor" id="a1dafb99a4933112c603189bc091fa752"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_MEMPROT_WRITE&#160;&#160;&#160;0x02</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write privileges. </p>

</div>
</div>
<a class="anchor" id="ad31bd52878d2454d8263d0951cfd1ca0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_CUR&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>current file position </p>

</div>
</div>
<a class="anchor" id="a06e58c043e838f1457853329fd4344a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_END&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>end of file </p>

</div>
</div>
<a class="anchor" id="aa675a6270b664511299295ebc1f5562e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_SEEK_SET&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>start of file </p>

</div>
</div>
<a class="anchor" id="adb9ba447c606e5e58400ac7b6ef719d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DR_TRY_EXCEPT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">drcontext, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">try_statement, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">except_statement&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {\</div>
<div class="line">    void *try_cxt;                                                    \</div>
<div class="line">    dr_try_setup(drcontext, &amp;try_cxt);                                \</div>
<div class="line">    if (<a class="code" href="dr__tools_8h.html#aa59cdd4f9fa2884b5d236f0fedc5bda3">dr_try_start</a>(try_cxt) == 0) {                                 <a class="code" href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">\</a></div>
<div class="line"><a class="code" href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">        try_statement                                                 \</a></div>
<div class="line"><a class="code" href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">        dr_try_stop</a>(drcontext, try_cxt);                              \</div>
<div class="line">    } <span class="keywordflow">else</span> {                                                          \</div>
<div class="line">        <span class="comment">/* roll back first in case except faults or returns */</span>        \</div>
<div class="line">        dr_try_stop(drcontext, try_cxt);                              \</div>
<div class="line">        except_statement                                              \</div>
<div class="line">    }                                                                 \</div>
<div class="line">} <span class="keywordflow">while</span> (0)</div>
<div class="ttc" id="dr__tools_8h_html_afde42618a83e7e1abdc58961a084e774"><div class="ttname"><a href="dr__tools_8h.html#afde42618a83e7e1abdc58961a084e774">dr_try_stop</a></div><div class="ttdeci">void dr_try_stop(void *drcontext, void *try_cxt)</div></div>
<div class="ttc" id="dr__tools_8h_html_aa59cdd4f9fa2884b5d236f0fedc5bda3"><div class="ttname"><a href="dr__tools_8h.html#aa59cdd4f9fa2884b5d236f0fedc5bda3">dr_try_start</a></div><div class="ttdeci">int dr_try_start(void *buf)</div></div>
</div><!-- fragment --><p>Simple try..except support for executing operations that might fault and recovering if they do. Be careful with this feature as it has some limitations:</p><ul>
<li>do not use a return within a try statement (we do not have language support)</li>
<li>any automatic variables that you want to use in the except block should be declared volatile</li>
<li>no locks should be grabbed in a try statement (because there is no finally support to release them)</li>
<li>nesting is supported, but finally statements are not supported</li>
</ul>
<p>For fault-free reads in isolation, use <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> instead. <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> out-performs DR_TRY_EXCEPT.</p>
<p>For fault-free writes in isolation, <a class="el" href="dr__tools_8h.html#ab94f47b693cc7dd9eecba07d8cfd1bc8">dr_safe_write()</a> can be used, although on Windows it invokes a system call and can be less performant than DR_TRY_EXCEPT. </p>

</div>
</div>
<a class="anchor" id="a4e6bdc93e35ee5a9f081564a162ec3b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GLOBAL_DCONTEXT&#160;&#160;&#160;((void *)-1)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this dcontext for use with the standalone static decoder library. Pass it whenever a decoding-related API routine asks for a context. </p>

</div>
</div>
<a class="anchor" id="a7574ce4aa047de1f4a564c9b441e69dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ALL&#160;&#160;&#160;0x00ffffff</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log all data. </p>

</div>
</div>
<a class="anchor" id="a5895b0ef2efc255ad93e50bc88277b6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_ASYNCH&#160;&#160;&#160;0x00000010</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to signals/callbacks/etc. </p>

</div>
</div>
<a class="anchor" id="a031661fca6b5cb813db972d758caca2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_CACHE&#160;&#160;&#160;0x00000100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to code cache management. </p>

</div>
</div>
<a class="anchor" id="a9929e24db31369398fbdc52ee040b234"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_DISPATCH&#160;&#160;&#160;0x00000400</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data on every context switch dispatch. </p>

</div>
</div>
<a class="anchor" id="a06582648acdd995a11019f726b15adda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_EMIT&#160;&#160;&#160;0x00000040</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to emitting code. </p>

</div>
</div>
<a class="anchor" id="a7c5fcb805e6a1fdfac332931888b3ef7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_FRAGMENT&#160;&#160;&#160;0x00000200</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to app code fragments. </p>

</div>
</div>
<a class="anchor" id="a5522e92b98898a21b7c26ba9df95f094"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HEAP&#160;&#160;&#160;0x00001000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to memory management. </p>

</div>
</div>
<a class="anchor" id="a51c2bbdf11618716da67a305dd24ddde"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HOT_PATCHING&#160;&#160;&#160;0x00200000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to hot patching. </p>

</div>
</div>
<a class="anchor" id="a6ec73009ed3f0c2baa1d3c44033c261e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_HTABLE&#160;&#160;&#160;0x00400000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to hash tables. </p>

</div>
</div>
<a class="anchor" id="a54bbda8cb7e78f2ea32209bab2d7201c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_INTERP&#160;&#160;&#160;0x00000020</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to app interpretation. </p>

</div>
</div>
<a class="anchor" id="a438ad3561d9d8616ff702b36d0b2bb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_LINKS&#160;&#160;&#160;0x00000080</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to linking code. </p>

</div>
</div>
<a class="anchor" id="aabb9931c63f1cf95cacca6463d5a9b09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MEMSTATS&#160;&#160;&#160;0x00008000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to memory statistics. </p>

</div>
</div>
<a class="anchor" id="abba5e74dd3a5577b7af5177960ecb9dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MODULEDB&#160;&#160;&#160;0x00800000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to the module database. </p>

</div>
</div>
<a class="anchor" id="a2575baf458eee6334f746544f91fa6cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_MONITOR&#160;&#160;&#160;0x00000800</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to trace building. </p>

</div>
</div>
<a class="anchor" id="a1632479322efa3952798f98177b54471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NONE&#160;&#160;&#160;0x00000000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log no data. </p>

</div>
</div>
<a class="anchor" id="a4f3856a58f1f9971ebcd62c99a448a5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_NT&#160;&#160;&#160;0x00100000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to Windows Native API. </p>

</div>
</div>
<a class="anchor" id="a9f746aa1ef6a208cd1cd7174a694c9e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_OPTS&#160;&#160;&#160;0x00010000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to optimizations. </p>

</div>
</div>
<a class="anchor" id="a297668a84187b740ff4fe1e1d6e52eeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_RCT&#160;&#160;&#160;0x00080000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to indirect transfers. </p>

</div>
</div>
<a class="anchor" id="a8ad7f6071c29a882af67d3a72fe4e787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SIDELINE&#160;&#160;&#160;0x00020000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to sideline threads. </p>

</div>
</div>
<a class="anchor" id="a9dd9f361c4a23133f724c84192eef8e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_STATS&#160;&#160;&#160;0x00000001</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log per-thread and global statistics. </p>

</div>
</div>
<a class="anchor" id="a65630bab8d9fcde517b3f8ecb03c6de9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYMBOLS&#160;&#160;&#160;0x00040000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to app symbols. </p>

</div>
</div>
<a class="anchor" id="a8879b800acfbbe8f2ada805be6ef5121"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYNCH&#160;&#160;&#160;0x00004000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to synchronization. </p>

</div>
</div>
<a class="anchor" id="a87ef794555c43a1988eb760835b2fa76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_SYSCALLS&#160;&#160;&#160;0x00000008</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to system calls. </p>

</div>
</div>
<a class="anchor" id="a9390202fe239f2ee56c097d6940d10f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_THREADS&#160;&#160;&#160;0x00000004</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to threads. </p>

</div>
</div>
<a class="anchor" id="a9fdb93b09477bb1b1ee08d132dd6f4dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_TOP&#160;&#160;&#160;0x00000002</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log top-level information. </p>

</div>
</div>
<a class="anchor" id="a557f3a77c5d95b7cd06661245030c687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define LOG_VMAREAS&#160;&#160;&#160;0x00002000</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Log data related to address space regions. </p>

</div>
</div>
<a class="anchor" id="a7d467c1d283fdfa1f2081ba1e0d01b6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PAGE_SIZE&#160;&#160;&#160;<a class="el" href="dr__tools_8h.html#a2ac0d710a2af2ab256bd5940b936ac3f">dr_page_size</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Size of a page of memory. This uses a function call so be careful where performance is critical. </p>

</div>
</div>
<a class="anchor" id="adef0efe8b0b596d8f85a144c2f2c2c3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PAGE_START</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">x</td><td>)</td>
          <td>&#160;&#160;&#160;(((ptr_uint_t)(x)) &amp; ~(<a class="el" href="dr__tools_8h.html#a2ac0d710a2af2ab256bd5940b936ac3f">dr_page_size</a>()-1))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convenience macro to align to the start of a page of memory. It uses a function call so be careful where performance is critical. </p>

</div>
</div>
<a class="anchor" id="a25512292915eb6d1109b90f9c3bd1518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STUB_DATA_FIXED_SIZE&#160;&#160;&#160;(offsetof(<a class="el" href="dr__tools_8h.html#afbec914b027f98ee51e888671aac55f0">tracedump_stub_data_t</a>, count))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The last offset into tracedump_stub_data_t of always-present fields. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ad4bb25312a86996379357f79a4c7c1c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A handle to a loaded client auxiliary library. This is a different type than module_handle_t and is not necessarily the base address. </p>

</div>
</div>
<a class="anchor" id="ac429103cb983108880aee9b1377c430c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* dr_auxlib_routine_ptr_t) ()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An exported routine in a loaded client auxiliary library. </p>

</div>
</div>
<a class="anchor" id="af3e96c875a305558239b74496c4030d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__export__info__t.html">_dr_export_info_t</a>  <a class="el" href="dr__tools_8h.html#af3e96c875a305558239b74496c4030d0">dr_export_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure used by <a class="el" href="dr__tools_8h.html#af1a068ad89408abbcfba026706810211">dr_get_proc_address_ex()</a> to retrieve information about an exported symbol. </p>

</div>
</div>
<a class="anchor" id="a2834876d9bbe13989ed6ebc2e2f94c6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__mem__info__t.html">_dr_mem_info_t</a>  <a class="el" href="dr__tools_8h.html#a2834876d9bbe13989ed6ebc2e2f94c6a">dr_mem_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Describes a memory region. Used by <a class="el" href="dr__tools_8h.html#a5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex()</a>. </p>

</div>
</div>
<a class="anchor" id="a61869abe84d5de25e7dd02f247cb4c74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__memory__dump__spec__t.html">_dr_memory_dump_spec_t</a>  <a class="el" href="dr__tools_8h.html#a61869abe84d5de25e7dd02f247cb4c74">dr_memory_dump_spec_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of memory dump for <a class="el" href="dr__tools_8h.html#a9e70d60b5c4963fa277e27efc0482a60">dr_create_memory_dump()</a>. </p>

</div>
</div>
<a class="anchor" id="a20e62023d3be1c972a03ac53f15aff55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__module__import__t.html">_dr_module_import_t</a>  <a class="el" href="dr__tools_8h.html#a20e62023d3be1c972a03ac53f15aff55">dr_module_import_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Module import data returned from <a class="el" href="dr__tools_8h.html#ae9863e3f8ac53d7b1d1c023e00c6ec4a">dr_module_import_iterator_next()</a>.</p>
<p>String fields point into the importing module image. Robust clients should use DR_TRY_EXCEPT while inspecting the strings in case the module is partially mapped or the app racily unmaps it. The iterator routines themselves handle faults by stopping the iteration.</p>
<dl class="section note"><dt>Note</dt><dd>ELF does not import directly from other modules. </dd></dl>

</div>
</div>
<a class="anchor" id="afd116a488df74505f27ff57cd49b9f88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For dr_module_iterator_* interface </p>

</div>
</div>
<a class="anchor" id="ad4b7c9d9efa9ec7a767855587eaa622e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__os__version__info__t.html">_dr_os_version_info_t</a>  <a class="el" href="dr__tools_8h.html#ad4b7c9d9efa9ec7a767855587eaa622e">dr_os_version_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure used with <a class="el" href="dr__tools_8h.html#abab30ef95ab36e4e885a9dc89f540c39">dr_get_os_version()</a> </p>

</div>
</div>
<a class="anchor" id="a5f313b8ed7cdc35283e82a59a6492077"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__symbol__export__t.html">_dr_symbol_export_t</a>  <a class="el" href="dr__tools_8h.html#a5f313b8ed7cdc35283e82a59a6492077">dr_symbol_export_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symbol export data returned from <a class="el" href="dr__tools_8h.html#a84a9316bfb47fb3a854bf371da4e2190">dr_symbol_export_iterator_next()</a>.</p>
<p>String fields point into the exporting module image. Robust clients should use DR_TRY_EXCEPT while inspecting the strings in case the module is partially mapped or the app racily unmaps it.</p>
<p>On Windows, the address in <code>addr</code> may not be inside the exporting module if it is a forward and has been patched by the loader. In that case, <code>forward</code> will be NULL. </p>

</div>
</div>
<a class="anchor" id="a97862b54ff9ef6f20494449ff47242e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__symbol__import__t.html">_dr_symbol_import_t</a>  <a class="el" href="dr__tools_8h.html#a97862b54ff9ef6f20494449ff47242e6">dr_symbol_import_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symbol import data returned from <a class="el" href="dr__tools_8h.html#af3b3e34e05cf82fb5b5801389eab835d">dr_symbol_import_iterator_next()</a>.</p>
<p>String fields point into the importing module image. Robust clients should use DR_TRY_EXCEPT while inspecting the strings in case the module is partially mapped or the app racily unmaps it. </p>

</div>
</div>
<a class="anchor" id="af154bb3f9b057795c65b51687bb2ba50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__syscall__result__info__t.html">_dr_syscall_result_info_t</a>  <a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure used to obtain or modify the result of an application system call by <a class="el" href="dr__tools_8h.html#a0e4cf94bfc4dca2deb04699c28a56e55">dr_syscall_get_result_ex()</a> and <a class="el" href="dr__tools_8h.html#aaae7ca4aa76652ddaaacb1e8dad9f6af">dr_syscall_set_result_ex()</a>. </p>

</div>
</div>
<a class="anchor" id="a8d2fef062beef2b521283369e0108282"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__module__names__t.html">_module_names_t</a>  <a class="el" href="dr__tools_8h.html#a8d2fef062beef2b521283369e0108282">module_names_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Holds the names of a module. This structure contains multiple fields corresponding to different sources of a module name. Note that some of these names may not exist for certain modules. It is highly likely, however, that at least one name is available. Use <a class="el" href="dr__tools_8h.html#a082fe71b00688310237fbc2e027c4388">dr_module_preferred_name()</a> on the parent <a class="el" href="struct__module__data__t.html">_module_data_t</a> to get the preferred name of the module. </p>

</div>
</div>
<a class="anchor" id="ab49d9cfe4b0a8495532e5e4189515e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__module__segment__data__t.html">_module_segment_data_t</a>  <a class="el" href="dr__tools_8h.html#ab49d9cfe4b0a8495532e5e4189515e83">module_segment_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Holds information on a segment of a loaded module. </p>

</div>
</div>
<a class="anchor" id="a99aca5de3a975309ebf0f24cfe42c1e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__file__header__t.html">_tracedump_file_header_t</a>  <a class="el" href="dr__tools_8h.html#a99aca5de3a975309ebf0f24cfe42c1e8">tracedump_file_header_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<pre>
   Binary trace dump format:
   the file starts with a tracedump_file_header_t
   then, for each trace:
     struct _tracedump_trace_header
     if num_bbs &gt; 0 # tracedump_origins
       foreach bb:
           app_pc tag;
           int bb_code_size;
           byte code[bb_code_size];
     endif
     foreach exit:
       struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>
       if linkcount_size &gt; 0 # deprecated
         linkcount_type_t count; # sizeof == linkcount_size
       endif
       if separate from body
       (i.e., exit_stub &lt; cache_start_pc || exit_stub &gt;= cache_start_pc+code_size):
           byte stub_code[15]; # all separate stubs are 15
       endif
     endfor
     byte code[code_size];
</pre> 
</div>
</div>
<a class="anchor" id="afbec914b027f98ee51e888671aac55f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__stub__data.html">_tracedump_stub_data</a>  <a class="el" href="dr__tools_8h.html#afbec914b027f98ee51e888671aac55f0">tracedump_stub_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The format of a stub in a trace dump file. </p>

</div>
</div>
<a class="anchor" id="a3fe0415406026b8daf538ab6ac31519d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__tracedump__trace__header__t.html">_tracedump_trace_header_t</a>  <a class="el" href="dr__tools_8h.html#a3fe0415406026b8daf538ab6ac31519d">tracedump_trace_header_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Header for an individual trace in a binary trace dump file. </p>

</div>
</div>
<a class="anchor" id="aee552e6017b95b4708435b9467223d98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union__version__number__t.html">_version_number_t</a>  <a class="el" href="dr__tools_8h.html#aee552e6017b95b4708435b9467223d98">version_number_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Used to hold .rsrc section version number information. This number is usually presented as p1.p2.p3.p4 by PE parsing tools. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a5d76b81b0ad4c19007a781d4edb8181f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">anonymous enum</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a5d76b81b0ad4c19007a781d4edb8181face272a4f3f0eff24ef44c983bfa4ce63"></a>DR_MAP_PRIVATE&#160;</td><td class="fielddoc">
<p>If set, changes to mapped memory are private to the mapping process and are not reflected in the underlying file. If not set, changes are visible to other processes that map the same file, and will be propagated to the file itself. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5d76b81b0ad4c19007a781d4edb8181faec0156a07c55523ed4bb3d2f05c00b58"></a>DR_MAP_FIXED&#160;</td><td class="fielddoc">
<p>If set, indicates that the passed-in start address is required rather than a hint. On Linux, this has the same semantics as mmap with MAP_FIXED: i.e., any existing mapping in [addr,addr+size) will be unmapped. This flag is not supported on Windows. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5d76b81b0ad4c19007a781d4edb8181fa12a6a7af3936e4c932effc9505f23be5"></a>DR_MAP_IMAGE&#160;</td><td class="fielddoc">
<p>If set, loads the specified file as an executable image, rather than a data file. This flag is not supported on Linux. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a5d76b81b0ad4c19007a781d4edb8181fa6ba2a46cb1c2697fa81841feb05a777c"></a>DR_MAP_CACHE_REACHABLE&#160;</td><td class="fielddoc">
<p>If set, loads the specified file at a location that is reachable from the code cache and client libraries by a 32-bit displacement. If not set, the mapped file is not guaranteed to be reachable from the cache. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags used with <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f"></a>DR_ALLOC_NON_HEAP&#160;</td><td class="fielddoc">
<p>If this flag is not specified, <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a> uses a managed heap to allocate the memory, just like <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a> or <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>. In that case, it ignores any requested protection bits (<code>prot</code> parameter), and the location (<code>addr</code> parameter) must be NULL. If this flag is specified, a page-aligned, separate block of memory is allocated, in a similar fashion to <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211a312d65229e3450b24e59aec4b7d7410e"></a>DR_ALLOC_THREAD_PRIVATE&#160;</td><td class="fielddoc">
<p>This flag only applies to heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is not specified). If this flag is not specified, global heap is used (just like <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>) and the <code>drcontext</code> parameter is ignored. If it is specified, thread-private heap specific to <code>drcontext</code> is used, just like <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1"></a>DR_ALLOC_CACHE_REACHABLE&#160;</td><td class="fielddoc">
<p>Allocate memory that is 32-bit-displacement reachable from the code caches and from the client library. Memory allocated through <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>, <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>, and <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a> is also reachable, but for <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a>, the resulting memory is not reachable unless this flag is specified. If this flag is passed, the requested location (<code>addr</code> parameter) must be NULL. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a>, <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585">DR_ALLOC_FIXED_LOCATION</a>, or <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585"></a>DR_ALLOC_FIXED_LOCATION&#160;</td><td class="fielddoc">
<p>This flag only applies to non-heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is specified). The flag requests that memory be allocated at a specific address, given in the <code>addr</code> parameter. Without this flag, the <code>addr</code> parameter is not honored. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a> or <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186"></a>DR_ALLOC_LOW_2GB&#160;</td><td class="fielddoc">
<p>This flag only applies to non-heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is specified) in 64-bit mode. The flag requests that memory be allocated in the low 2GB of the address space. If this flag is passed, the requested location (<code>addr</code> parameter) must be NULL. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211a8bcd3bdb2ed2f71a1a7329274a195585">DR_ALLOC_FIXED_LOCATION</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376"></a>DR_ALLOC_NON_DR&#160;</td><td class="fielddoc">
<p>This flag only applies to non-heap memory (i.e., when <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> is specified). When this flag is specified, the allocated memory is not considered to be DynamoRIO or tool memory and thus is not kept separate from the application. This is similar to <a class="el" href="dr__tools_8h.html#ad6201fa3676b0afb76f91f15822cf0d1">dr_raw_mem_alloc()</a>. Use of this memory is at the client's own risk. This flag is not compatible with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211a5d2a736bd28da9bfd1a3238777c74558"></a>DR_ALLOC_RESERVE_ONLY&#160;</td><td class="fielddoc">
<p>This flag only applies to non-heap, non-DR memory (i.e., when both <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> and <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a> are specified) on Windows. When this flag is specified, the allocated memory is reserved but not committed, just like the MEM_RESERVE Windows API flag (the default is MEM_RESERVE|MEM_COMMIT). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="abb7e20e83f7b8e1b65428e45c8ab4211a0f6cd06c9a4aa053b4e39fbde1fe7be1"></a>DR_ALLOC_COMMIT_ONLY&#160;</td><td class="fielddoc">
<p>This flag only applies to non-heap, non-DR memory (i.e., when both <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211af279cdbfa6f350725efabcf5cc16a56f">DR_ALLOC_NON_HEAP</a> and <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a> are specified) on Windows. This flag must be combined with DR_ALLOC_FIXED_LOCATION. When this flag is specified, previously allocated memory is committed, just like the MEM_COMMIT Windows API flag (when this flag is not passed, the effect is MEM_RESERVE|MEM_COMMIT). When passed to <a class="el" href="dr__tools_8h.html#ae4f966c4d090cd499ffe3a5df7406604">dr_custom_free()</a>, this flag causes a de-commit, just like the MEM_DECOMMIT Windows API flag. This flag cannot be combined with <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ae32c4869e0c01cb57834e5ee7c163186">DR_ALLOC_LOW_2GB</a> and must include a non-NULL requested location (<code>addr</code> parameter). </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ade307e7bb7b7ac46e874097fe62b9fef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags for use with <a class="el" href="dr__tools_8h.html#aa88dc6d5b9bf7a3ce2cd907f87eba902">dr_map_executable_file()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ade307e7bb7b7ac46e874097fe62b9fefa183f27400568e903a072c9fc5bf0af96"></a>DR_MAPEXE_SKIP_WRITABLE&#160;</td><td class="fielddoc">
<p>Requests that writable segments are not mapped, to save address space. This may be ignored on some platforms and may only be honored for a writable segment that is at the very end of the loaded module. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10">dr_mem_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags describing memory used by <a class="el" href="dr__tools_8h.html#a5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10a60e91c7b948d92d08b74ee0cd50dee3d"></a>DR_MEMTYPE_FREE&#160;</td><td class="fielddoc">
<p>No memory is allocated here </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10a6edf083337f9c953747a2cf4461dcbf7"></a>DR_MEMTYPE_IMAGE&#160;</td><td class="fielddoc">
<p>An executable file is mapped here </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10ac0350de0d08726ea8a5a5f02bb7010b0"></a>DR_MEMTYPE_DATA&#160;</td><td class="fielddoc">
<p>Some other data is allocated here </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10aa23ff267355a0b49da1b77da5bcc4d29"></a>DR_MEMTYPE_RESERVED&#160;</td><td class="fielddoc">
<p>Reserved address space with no physical storage </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10a990c1b40496fdfc22c89b67300c921ea"></a>DR_MEMTYPE_ERROR&#160;</td><td class="fielddoc">
<p>Query failed for unspecified reason </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aff97be516bbb1aecdb6bd043841aaa10a4155a1d348b4dc103ef7d5cd1c6dc257"></a>DR_MEMTYPE_ERROR_WINKERNEL&#160;</td><td class="fielddoc">
<p>Query failed due to the address being located in Windows kernel space. No further information is available so iteration must stop. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a00269a3ba590923c5d0ec4e0bcf5a9ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#a00269a3ba590923c5d0ec4e0bcf5a9ff">dr_memory_dump_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates the type of memory dump for <a class="el" href="dr__tools_8h.html#a9e70d60b5c4963fa277e27efc0482a60">dr_create_memory_dump()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a00269a3ba590923c5d0ec4e0bcf5a9ffa00ec80b5919c0e6e1dc361a5fa9af02f"></a>DR_MEMORY_DUMP_LDMP&#160;</td><td class="fielddoc">
<p>A "livedump", or "ldmp", DynamoRIO's own custom memory dump format. The ldmp format does not currently support specifying a context for the calling thread, so it will always include the call frames to <a class="el" href="dr__tools_8h.html#a9e70d60b5c4963fa277e27efc0482a60">dr_create_memory_dump()</a>. The <code>ldmp.exe</code> tool can be used to create a dummy process (using the <code>dummy.exe</code> executable) which can then be attached to by the debugger (use a non-invasive attach) in order to view the memory dump contents.</p>
<dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#a311ab26d3bdc2d6ff7830b6f3ae9760c">dr_os_version_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Windows versions </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca781e789a0171cf75fe5dedcfd9cb7f7c"></a>DR_WINDOWS_VERSION_10_1607&#160;</td><td class="fielddoc">
<p>Windows 10 1607 major update. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca2ce40ab4db406adf0613c77cc72112fd"></a>DR_WINDOWS_VERSION_10_1511&#160;</td><td class="fielddoc">
<p>Windows 10 TH2 1511. For future Windows updates that change system call numbers, we'll perform our own artificial minor version number update as done here, and use the YYMM version as the sub-name, as officially the OS version will supposedly remain 10.0 forever. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca7927b8c2058d3adf34e0e5c49474c979"></a>DR_WINDOWS_VERSION_10&#160;</td><td class="fielddoc">
<p>Windows 10 pre-TH2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760cacea85c24b6ec914a85dd58a39dde0d3e"></a>DR_WINDOWS_VERSION_8_1&#160;</td><td class="fielddoc">
<p>Windows 8.1 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca114432cbffadfec0fb011e9ef7ba8a87"></a>DR_WINDOWS_VERSION_2012_R2&#160;</td><td class="fielddoc">
<p>Windows Server 2012 R2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca420fc7de0ba5c5b6dea013b4c2509ac0"></a>DR_WINDOWS_VERSION_8&#160;</td><td class="fielddoc">
<p>Windows 8 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca7c2a135c55d571883a94d9ff4e9da94f"></a>DR_WINDOWS_VERSION_2012&#160;</td><td class="fielddoc">
<p>Windows Server 2012 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca8e8e36ac7efb1ad06cabb5f701306fde"></a>DR_WINDOWS_VERSION_7&#160;</td><td class="fielddoc">
<p>Windows 7 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760cae432c24e32ed3407f449f019d51d38ae"></a>DR_WINDOWS_VERSION_2008_R2&#160;</td><td class="fielddoc">
<p>Windows Server 2008 R2 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760cacb93ff69eabd6550b660012c55cacae1"></a>DR_WINDOWS_VERSION_VISTA&#160;</td><td class="fielddoc">
<p>Windows Vista </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca252442772ce128b15408a140958c1c96"></a>DR_WINDOWS_VERSION_2008&#160;</td><td class="fielddoc">
<p>Windows Server 2008 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760caf960b684d92226cd35590c2804c8dfa6"></a>DR_WINDOWS_VERSION_2003&#160;</td><td class="fielddoc">
<p>Windows Server 2003 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca4944bf33a5c3e637329fbdffe5051cee"></a>DR_WINDOWS_VERSION_XP_X64&#160;</td><td class="fielddoc">
<p>Windows XP 64-bit </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca3434e7522e1c3efc0fd898cf5f06c092"></a>DR_WINDOWS_VERSION_XP&#160;</td><td class="fielddoc">
<p>Windows XP </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760ca6364725219ede21bfbbf10d71fc844f0"></a>DR_WINDOWS_VERSION_2000&#160;</td><td class="fielddoc">
<p>Windows 2000 </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a311ab26d3bdc2d6ff7830b6f3ae9760caf3fa92ea36f47c6008fdbae9e78631b9"></a>DR_WINDOWS_VERSION_NT&#160;</td><td class="fielddoc">
<p>Windows NT </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ad051d9da5ddb2100eb450587e7551a70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70">dr_state_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags that control the behavior of <a class="el" href="dr__tools_8h.html#ae937ce8bbb24330c25acd6d1c04cb5a0">dr_switch_to_app_state_ex()</a> and <a class="el" href="dr__tools_8h.html#a994e632ea892a947612b44027467ea2b">dr_switch_to_dr_state_ex()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ad051d9da5ddb2100eb450587e7551a70ade45f51ff07512196129df690c9351fc"></a>DR_STATE_PEB&#160;</td><td class="fielddoc">
<p>Switch the PEB pointer. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad051d9da5ddb2100eb450587e7551a70a1e89b3980660dea49687e08fea96df09"></a>DR_STATE_TEB_MISC&#160;</td><td class="fielddoc">
<p>Switch miscellaneous TEB fields. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad051d9da5ddb2100eb450587e7551a70a1075136763677e70239a776f8111b3c3"></a>DR_STATE_STACK_BOUNDS&#160;</td><td class="fielddoc">
<p>Switch the TEB stack bounds fields. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ad051d9da5ddb2100eb450587e7551a70a6f0f881ce02e1caf28ffbbc1246aa9a8"></a>DR_STATE_ALL&#160;</td><td class="fielddoc">
<p>Switch all state. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="a66bef18f8eabc7a8b8b0368e8a96d179"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling the behavior of <a class="el" href="dr__tools_8h.html#a8c0a1bdefb011cf62eb2540e933cb331">dr_suspend_all_other_threads_ex()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a66bef18f8eabc7a8b8b0368e8a96d179a21ba834e13979aa7ad97fd13c69b3ae4"></a>DR_SUSPEND_NATIVE&#160;</td><td class="fielddoc">
<p>By default, native threads are not suspended by <a class="el" href="dr__tools_8h.html#a8c0a1bdefb011cf62eb2540e933cb331">dr_suspend_all_other_threads_ex()</a>. This flag requests that native threads (including those temporarily-native due to actions such as <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a>) be suspended as well. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a818524883cd69709fe0e3499d6748d14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_calloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory from DR's global memory pool, but mimics the behavior of calloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. </p><dl class="section note"><dt>Note</dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a82dca5b3d5bfbd3de8891502badd861e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void __wrap_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory from DR's global memory pool. Memory must have been allocated with <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. </p><dl class="section note"><dt>Note</dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a3687f50774c89e7a09833a71adbb7771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_malloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory from DR's global memory pool, but mimics the behavior of malloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option to replace a client's use of malloc, realloc, and free with internal versions that allocate memory from DR's private pool. With -wrap, clients can link to libraries that allocate heap memory without interfering with application allocations. </p><dl class="section note"><dt>Note</dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="adcaad79adf4fc109015dd6a2d49b9031"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* __wrap_realloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reallocates memory from DR's global memory pool, but mimics the behavior of realloc. Memory must be freed with <a class="el" href="dr__tools_8h.html#a82dca5b3d5bfbd3de8891502badd861e">__wrap_free()</a>. The __wrap routines are intended to be used with ld's -wrap option; see <a class="el" href="dr__tools_8h.html#a3687f50774c89e7a09833a71adbb7771">__wrap_malloc()</a> for more information. </p><dl class="section note"><dt>Note</dt><dd>Currently Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a12c1ca981b7d3049cb2d31c0f19da332"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_abort </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Aborts the process immediately without any cleanup (i.e., the exit event will not be called). </p>

</div>
</div>
<a class="anchor" id="acd67a10cd03a382853a0523bde9990f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_app_pc_for_decoding </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given an application PC, returns a PC that contains the application code corresponding to the original PC. In some circumstances on Windows DR inserts a jump on top of the original code, which the client will not see in the bb and trace hooks due to DR replacing it there with the displaced original application code in order to present the client with an unmodified view of the application code. A client should use this routine when attempting to decode the original application instruction that caused a fault from the translated fault address, as the translated address may actually point in the middle of DR's jump.</p>
<dl class="section note"><dt>Note</dt><dd>Other applications on the system sometimes insert their own hooks, which will not be hidden by DR and will appear to the client as jumps and subsequent displaced code. </dd></dl>

</div>
</div>
<a class="anchor" id="ac150776be7e338321cbb8edc49ab7790"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_app_pc_from_cache_pc </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>cache_pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a code cache pc, returns the corresponding application pc. This involves translating the state and thus may incur calls to the basic block and trace events (see <a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event()</a>). If translation fails, returns NULL. This routine may not be called from a thread exit event. </p>

</div>
</div>
<a class="anchor" id="a669ec1a44523f58c52378020ecd87ccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_atomic_add32_return_sum </td>
          <td>(</td>
          <td class="paramtype">volatile int *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Atomically adds <code>*x</code> and <code>val</code> and returns the sum. </p>

</div>
</div>
<a class="anchor" id="aad3b09e886366ac10341e69a577555dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_bb_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if a basic block with tag <code>tag</code> exists in the code cache. </p>

</div>
</div>
<a class="anchor" id="af57b95b87d8da29a16ca923a5b1b98b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_client_thread_set_suspendable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>suspendable</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Can only be called from a client thread: returns false if called from a non-client thread.</p>
<p>Controls whether a client thread created with <a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread()</a> will be suspended by DR for synchronization operations such as flushing or client requests like <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. A client thread that spends a lot of time holding locks can gain greater performance by not being suspended.</p>
<p>A client thread <b>will</b> be suspended for a thread termination operation, including at process exit, regardless of its suspendable requests. </p>

</div>
</div>
<a class="anchor" id="ac25b305e0be9f6c09f9761b14f3bbc74"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_close_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Closes file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="a153dc4defa904b033e122bb8957b0288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_id_t dr_convert_handle_to_pid </td>
          <td>(</td>
          <td class="paramtype">HANDLE&#160;</td>
          <td class="paramname"><em>process_handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a process handle to a process id. </p><dl class="section return"><dt>Returns</dt><dd>Process id if successful; INVALID_PROCESS_ID on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="a9593c7e9b66e2020ebaea7e3911f2e22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE dr_convert_pid_to_handle </td>
          <td>(</td>
          <td class="paramtype">process_id_t&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a process id to a process handle. </p><dl class="section return"><dt>Returns</dt><dd>Process handle if successful; INVALID_HANDLE_VALUE on failure. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="a8c99a2d79ed312cd852d57e975601adc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_copy_module_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes a copy of <code>data</code>. Copy must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. Useful for making persistent copies of module_data_t's received as part of image load and unload event callbacks. </p>

</div>
</div>
<a class="anchor" id="ac6b80b83502ff13d4674b13e7b30b555"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_create_client_thread </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *param)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new thread that is marked as a non-application thread (i.e., DR will let it run natively and not execute its code from the code cache). The thread will terminate automatically simply by returning from <code>func</code>; if running when the application terminates its last thread, the client thread will also terminate when DR shuts the process down.</p>
<p>Init and exit events will not be raised for this thread (instead simply place init and exit code in <code>func</code>).</p>
<p>The new client thread has a drcontext that can be used for thread-private heap allocations. It has a stack of the same size as the DR stack used by application threads.</p>
<p>On Linux, this thread is guaranteed to have its own private itimer if <a class="el" href="dr__tools_8h.html#a9191c67a267070ed51289d7192f986aa">dr_set_itimer()</a> is called from it. However this does mean it will have its own process id.</p>
<p>A client thread should refrain from spending most of its time in calls to other libraries or making blocking or long-running system calls as such actions may incur performance or correctness problems with DR's synchronization engine, which needs to be able to suspend client threads at safe points and cannot determine whether the aforementioned actions are safe for suspension. Calling <a class="el" href="dr__tools_8h.html#af154e498d8b185931ef970676cb65351">dr_sleep()</a>, <a class="el" href="dr__tools_8h.html#ac262422c1e5e487113176bd4193c387f">dr_thread_yield()</a>, <a class="el" href="dr__tools_8h.html#ad444a204e7ca45f9965cfe973470375a">dr_messagebox()</a>, or using DR's locks are safe. If a client thread spends a lot of time holding locks, consider marking it as un-suspendable by calling <a class="el" href="dr__tools_8h.html#af57b95b87d8da29a16ca923a5b1b98b3">dr_client_thread_set_suspendable()</a> for better performance.</p>
<p>Client threads, whether suspendable or not, must never execute from the code cache as the underlying fragments might be removed by another thread.</p>
<dl class="section note"><dt>Note</dt><dd>Thread creation via this routine is not yet fully transparent: on Windows, the thread will show up in the list of application threads if the operating system is queried about threads. The thread will not trigger a DLL_THREAD_ATTACH message. On Linux, the thread will not receive signals meant for the application, and is guaranteed to have a private itimer. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ee2651cad7bafe65f3df7d4aeb82120"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_create_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new directory. Fails if the directory already exists or if it can't be created. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#ae3ae2190774a204af207602791a32cb6">dr_open_file()</a>. </p>

</div>
</div>
<a class="anchor" id="a9e70d60b5c4963fa277e27efc0482a60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_create_memory_dump </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#a61869abe84d5de25e7dd02f247cb4c74">dr_memory_dump_spec_t</a> *&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests that DR create a memory dump file of the current process. The type of dump is specified by <code>spec</code>.</p>
<dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>this function is only supported on Windows for now. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cfff0780cf83588e3d71da552490eb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_custom_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates memory with the properties requested by <code>flags</code>.</p>
<p>If <code>addr</code> is non-NULL (only allowed with certain flags), it must be page-aligned.</p>
<p>To make more space available for the code caches when running larger applications, or for clients that use a lot of heap memory that is not directly referenced from the cache, we recommend that <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a> be called to obtain memory that is not guaranteed to be reachable from the code cache (by not passing <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211ab33a2e990410bf314bdebe6a25aa06e1">DR_ALLOC_CACHE_REACHABLE</a>). This frees up space in the reachable region.</p>
<p>Returns NULL on failure. </p>

</div>
</div>
<a class="anchor" id="ae4f966c4d090cd499ffe3a5df7406604"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_custom_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211">dr_alloc_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a>. The same <code>flags</code> and <code>size</code> must be passed here as were passed to <a class="el" href="dr__tools_8h.html#a3cfff0780cf83588e3d71da552490eb7">dr_custom_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="afa5ea6649e644074ca55f456c89264e8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delay_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flush_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(int flush_id)&#160;</td>
          <td class="paramname"><em>flush_completion_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Request a flush of all fragments containing code from the region [<code>start</code>, <code>start</code> + <code>size</code>). The flush will be performed at the next safe point in time (usually before any new code is added to the cache after this routine is called). If <code>flush_completion_callback</code> is non-NULL, it will be called with the <code>flush_id</code> provided to this routine when the flush completes, after which no execution will occur out of the fragments flushed. Returns true if the flush was successfully queued.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="dr__tools_8h.html#abe87d17869a51a66d59eecf459d71cc0">dr_flush_region()</a> and <a class="el" href="dr__tools_8h.html#a56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region()</a> can give stronger guarantees on when the flush will occur, but have more restrictions on use. </dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. </dd>
<dd>
As currently implemented there may be a performance penalty for requesting a <code>flush_completion_callback</code>; for most performant usage set <code>flush_completion_callback</code> to NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="aab0da447546ca8dd194a993607d66ecb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delete_dir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the given directory. Fails if the directory is not empty. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#ae3ae2190774a204af207602791a32cb6">dr_open_file()</a>. </p>

</div>
</div>
<a class="anchor" id="a7ce7b5b2390cb5e03466cd605735bdfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delete_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the file referred to by <code>filename</code>. Returns true if successful. On both Linux and Windows, if filename refers to a symlink, the symlink will be deleted and not the target of the symlink. On Windows, this will fail to delete any file that was not opened with FILE_SHARE_DELETE and is still open. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#ae3ae2190774a204af207602791a32cb6">dr_open_file()</a>. </p>

</div>
</div>
<a class="anchor" id="a7600cc31d68dc0e30ab91261d08836ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_delete_fragment </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the fragment with tag <code>tag</code>. This routine is only valid with the -thread_private option; it deletes the fragment in the current thread only. After deletion, the existing fragment is allowed to complete execution. For example, a clean call deleting the currently executing fragment will safely return to the existing code. Subsequent executions will cause DynamoRIO to reconstruct the fragment, and therefore call the appropriate fragment-creation event hook, if registered.</p>
<dl class="section note"><dt>Note</dt><dd>This routine supports deletion for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list. This routine may not be called from the thread exit event.</dd>
<dd>
Other options of removing the code fragments from code cache include <a class="el" href="dr__tools_8h.html#abe87d17869a51a66d59eecf459d71cc0">dr_flush_region()</a>, <a class="el" href="dr__tools_8h.html#a56909cf76e4a71fca13731053ef48928">dr_unlink_flush_region()</a>, and <a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a>.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a02f86a68a105442a029baa05a1af9d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_directory_exists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for the existence of a directory. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#ae3ae2190774a204af207602791a32cb6">dr_open_file()</a>. </p>

</div>
</div>
<a class="anchor" id="a66ef4b43d78d787c7622569d30717051"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_dup_file_handle </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new copy of the file handle <code>f</code>. Returns INVALID_FILE on error. </p>

</div>
</div>
<a class="anchor" id="a712de67b3f6adb6778ce302925009753"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_enable_console_printing </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables <a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#a1affb1a9f1c49c1959f1a01967a0a0d9">dr_fprintf()</a> to work with a legacy console window (viz., <code>cmd</code> on Windows 7 or earlier). Loads a private copy of kernel32.dll (if not already loaded) in order to accomplish this. To keep the default DR lean and mean, loading kernel32.dll is not performed by default.</p>
<p>This routine must be called during client initialization (<code><a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a></code>). If called later, it will fail.</p>
<p>Without calling this routine, <a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#a1affb1a9f1c49c1959f1a01967a0a0d9">dr_fprintf()</a> will not print anything in a console window on Windows 7 or earlier, nor will they print anything when running a graphical application.</p>
<p>Even after calling this routine, there are significant limitations to console printing support in DR:</p>
<ul>
<li>On Windows versions prior to Vista, and for WOW64 applications on Vista, it does not work from the exit event. Once the application terminates its state with csrss (toward the very end of ExitProcess), no output will show up on the console. We have no good solution here yet as exiting early is not ideal.</li>
<li>In the future, with earliest injection (Issue 234), writing to the console may not work from the client init event on Windows 7 and earlier (it will work on Windows 8).</li>
</ul>
<p>These limitations stem from the complex arrangement of the console window in Windows (prior to Windows 8), where printing to it involves sending a message in an undocumented format to the <code>csrss</code> process, rather than a simple write to a file handle. We recommend using a terminal window such as cygwin's <code>rxvt</code> rather than the <code>cmd</code> window, or alternatively redirecting all output to a file, which will solve all of the above limitations.</p>
<p>Returns whether successful. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="a364db17ca1ba042f4fa3280b49fb2ad6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_exit_process </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>exit_code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exits the process, first performing a full cleanup that will trigger the exit event (<a class="el" href="dr__events_8h.html#a985537df683007e1392e8a3b095ef363">dr_register_exit_event()</a>). The process exit code is set to <code>exit_code</code>.</p>
<p>On Linux, only the bottom 8 bits of <code>exit_code</code> will be honored for a normal exit. If bits 9..16 are not all zero, DR will send an unhandled signal of that signal number instead of performing a normal exit.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this from <code>dr_client_main</code> or from the primary thread's initialization event is not guaranteed to always work, as DR may invoke a thread exit event where a thread init event was never called. We recommend using <a class="el" href="dr__tools_8h.html#a12c1ca981b7d3049cb2d31c0f19da332">dr_abort()</a> or waiting for full initialization prior to use of this routine. </dd></dl>

</div>
</div>
<a class="anchor" id="af471633d0954d80c09ca6c2bfe40475b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_exists </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks the existence of a file. Relative path support on Windows is identical to that described in <a class="el" href="dr__tools_8h.html#ae3ae2190774a204af207602791a32cb6">dr_open_file()</a>. </p>

</div>
</div>
<a class="anchor" id="a18c2c9d68ceceef8c6455b06502667ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_seek </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>origin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current file position for file <code>f</code> to <code>offset</code> bytes from the specified origin, where <code>origin</code> is one of the DR_SEEK_* values. Returns true if successful. </p>

</div>
</div>
<a class="anchor" id="a06a8173579db03d018935afb1ca891f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_file_size </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint64 *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determines the size of the file <code>fd</code>. On success, returns the size in <code>size</code>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fc1d26f3050d6f361e7b07f98c7e82d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 dr_file_tell </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current position for the file <code>f</code> in bytes from the start of the file. Returns -1 on an error. </p>

</div>
</div>
<a class="anchor" id="ae51098d1c742e3189a197db0c212eaa9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_flush_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes any buffers for file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="abe87d17869a51a66d59eecf459d71cc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Once this routine returns no execution will occur out of the fragments flushed. This routine may only be called during a clean call from the cache, from a nudge event handler, or from a pre- or post-system call event handler. It may not be called from any other event callback. No locks can held when calling this routine. If called from a clean call, caller can NOT return to the cache (the fragment that was called out of may have been flushed even if it doesn't apparently overlap the flushed region). Instead the caller must redirect execution via <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> (or DR_SIGNAL_REDIRECT from a signal callback) after this routine to continue execution. Returns true if successful.</p>
<dl class="section note"><dt>Note</dt><dd>This routine may not be called from any registered event callback other than the nudge event, the pre- or post-system call events, the exception event, or the signal event; clean calls out of the cache may call this routine.</dd>
<dd>
If called from a clean call, caller must continue execution by calling <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> after this routine, as the fragment containing the callout may have been flushed. The context to use can be obtained via <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> with the exception of the pc to continue at which must be passed as an argument to the callout (see <a class="el" href="dr__ir__instr_8h.html#a57dbc129ab88dfdcf49f1105eba394a7">instr_get_app_pc()</a>) or otherwise determined.</dd>
<dd>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout.</dd>
<dd>
<a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous.</dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed.</dd>
<dd>
As currently implemented, <a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> with no completion callback routine specified can be substantially more performant. </dd></dl>

</div>
</div>
<a class="anchor" id="a1affb1a9f1c49c1959f1a01967a0a0d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t dr_fprintf </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Printing to a file that won't interfere with the application's own printing. It is not buffered, which means that it should not be used for very frequent, small print amounts: for that the client should either do its own buffering or it should use printf from the C library via DR's private loader. </p><dl class="section note"><dt>Note</dt><dd>On Windows 7 and earlier, this routine is not able to print to STDOUT or STDERR in the <code>cmd</code> window unless <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations: see <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a>. </dd>
<dd>
This routine supports printing wide characters via the ls or S format specifiers. On Windows, they are assumed to be UTF-16, and are converted to UTF-8. On Linux, they are converted by simply dropping the high-order bytes. </dd>
<dd>
If the data to be printed is large it will be truncated to an internal buffer size. Use <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> and <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> for large output. </dd>
<dd>
On Linux this routine does not check for errors like EINTR. Use <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> if that is a concern. </dd>
<dd>
When printing floating-point values, the caller's code should use <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state. On success, the number of bytes written is returned. On error, -1 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a724aa7f7e87a604071fffa0a01925bf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_fragment_app_pc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the application PC of a fragment with tag <code>tag</code>. </p>

</div>
</div>
<a class="anchor" id="a775fdf1d5a55b5fbca094a4d2f18d28f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_fragment_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not there is a fragment in code cache with tag <code>tag</code>. </p>

</div>
</div>
<a class="anchor" id="acfe1f6436b234406bde1970ecfa614b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_fragment_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the fragment with tag <code>tag</code>. If not found, returns 0. If found, returns the total size occupied in the cache by the fragment. </p>

</div>
</div>
<a class="anchor" id="ad72ba1e8b98c8e01f2c28ef2e4d3e16e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_free_module_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees a module_data_t returned by <a class="el" href="dr__tools_8h.html#a9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next()</a>, <a class="el" href="dr__tools_8h.html#a4892d089da710e952a23055bd7db38af">dr_lookup_module()</a>, <a class="el" href="dr__tools_8h.html#addd653edd3322cfb025ef8bdc6ae1060">dr_lookup_module_by_name()</a>, or <a class="el" href="dr__tools_8h.html#a8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data()</a>. </p><dl class="section note"><dt>Note</dt><dd>Should NOT be used with a module_data_t obtained as part of a module load or unload event. </dd></dl>

</div>
</div>
<a class="anchor" id="a81037ee313844d4fbce3368f4421e5b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_app_PEB </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the application's Process Environment Block (PEB). DR swaps to a private PEB when running client code, in order to isolate the client and its dependent libraries from the application, so conventional methods of reading the PEB will obtain the private PEB instead of the application PEB. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="aace5e8084f523fd25871b31463c7ecda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_application_name </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the image name (without path) of the current application. </p>

</div>
</div>
<a class="anchor" id="aae96ea91548daf1a0b5a78197bc86f07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* dr_get_client_base </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the base address of the client library. <code>client_id</code> is the client ID passed to a client's <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> function. </p>

</div>
</div>
<a class="anchor" id="afb7d403eb032bd14ae78807ae3d59ea0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_client_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the client library name and path that were originally specified to load the library. If the resulting string is longer than <a class="el" href="dr__defines_8h.html#a95c7b582d53e0a376f2a0e89323b2a7b">MAXIMUM_PATH</a> it will be truncated. <code>client_id</code> is the client ID passed to a client's <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> function. </p>

</div>
</div>
<a class="anchor" id="aae2e62195a2732b0f5c1004138b800a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_current_directory </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current directory for this process in <code>buf</code>. On Windows, reading the current directory is considered unsafe except during initialization, as it is stored in user memory and access is not controlled via any standard synchronization. </p>

</div>
</div>
<a class="anchor" id="a13217cc252506b06184c7c72adedf26c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_current_drcontext </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the DR context of the current thread. </p>

</div>
</div>
<a class="anchor" id="a25889ae165da2ece91e591f3a8a32650"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_dr_segment_base </td>
          <td>(</td>
          <td class="paramtype">IN <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get DR's thread local storage segment base pointed at by <code>tls_register</code>. It can be used to get the base of the thread-local storage segment used by <a class="el" href="dr__tools_8h.html#aea4bc51b4771fceb56f050d0f20cbc99">dr_raw_tls_calloc</a>.</p>
<dl class="section note"><dt>Note</dt><dd>It should not be called on thread exit event, as the thread exit event may be invoked from other threads. See <a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event</a> for details. </dd></dl>

</div>
</div>
<a class="anchor" id="a820a6c60659ad40d59f7b574d671574d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">HANDLE dr_get_dr_thread_handle </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a Windows handle to the thread with drcontext <code>drcontext</code>. This handle is DR's handle to this thread (it is not a separate copy) and as such it should not be closed by the caller; nor should it be used beyond the thread's exit, as DR's handle will be closed at that point.</p>
<p>The handle should have THREAD_ALL_ACCESS privileges. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="aba205966cb16d0478ecf159cdfeaee8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_integer_option </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>option_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64 *val&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value of an integer DynamoRIO runtime option named <code>option_name</code> into <code>val</code>. This includes boolean options. Options are listed in <a class="el" href="using.html#sec_options">Fine-Tuning DynamoRIO: Runtime Parameters</a>. DynamoRIO has many other undocumented options which may be queried through this API, but they are not officially supported. </p><dl class="section warning"><dt>Warning</dt><dd>Always pass a full uint64 for <code>val</code> even if the option is a smaller integer to avoid overwriting nearby data. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if no option named <code>option_name</code> exists, and true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="ab5cd85ea911bd99dedbd8d05796260bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_get_itimer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If an interval timer is already installed in the itimer sharing group that contains the calling thread, returns its frequency. Else returns 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">which</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a class="anchor" id="afd7e9d485a84aa147e0ec0e75ad6d962"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_logfile </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the log file for the thread with drcontext <code>drcontext</code>. If <code>drcontext</code> is NULL, returns the main log file. </p>

</div>
</div>
<a class="anchor" id="a21e44337705f8c8a2368427bcb69ca73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_get_main_module </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up module data for the main executable. </p><dl class="section note"><dt>Note</dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aefa6318d1d89060efb9567cdb4fedacc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 dr_get_microseconds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of microseconds since Jan 1, 1601 (this is the current UTC time).</p>
<dl class="section note"><dt>Note</dt><dd>This is the Windows standard. UNIX time functions typically count from the Epoch (Jan 1, 1970). The Epoch is 11644473600*1000*1000 microseconds after Jan 1, 1601. </dd></dl>

</div>
</div>
<a class="anchor" id="a4b187636a3fc9ba7964ae11a7fd30fb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64 dr_get_milliseconds </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of milliseconds since Jan 1, 1601 (this is the current UTC time).</p>
<dl class="section note"><dt>Note</dt><dd>This is the Windows standard. UNIX time functions typically count from the Epoch (Jan 1, 1970). The Epoch is 11644473600*1000 milliseconds after Jan 1, 1601. </dd></dl>

</div>
</div>
<a class="anchor" id="a52ee0b4adc12d9e67f58d55f1313f9fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_option_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *argc&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char ***argv&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the client-specific option string specified at client registration, parsed into an array of <code>argc</code> separate option tokens stored in <code>argv</code>. This is the same array of arguments passed to the <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> routine. </p>

</div>
</div>
<a class="anchor" id="a10831623706378cfc3082c0e27e31c4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_options </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the client-specific option string specified at client registration. <code>client_id</code> is the client ID passed to <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a>.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>This routine is replaced by <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a>'s arguments and by <a class="el" href="dr__tools_8h.html#a52ee0b4adc12d9e67f58d55f1313f9fe">dr_get_option_array()</a>. The front-end <code>drrun</code> and other utilities now re-quote all tokens, providing simpler option passing without escaping or extra quote layers. This routine, for compatibility, strips those quotes off and returns a flat string without any token-delimiting quotes. </dd></dl>

</div>
</div>
<a class="anchor" id="abab30ef95ab36e4e885a9dc89f540c39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_os_version </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ad4b7c9d9efa9ec7a767855587eaa622e">dr_os_version_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information about the version of the operating system. Returns whether successful. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd>
<dd>
The Windows API routine GetVersionEx may hide distinctions between versions, such as between Windows 8 and Windows 8.1. DR reports the true low-level version. </dd></dl>

</div>
</div>
<a class="anchor" id="a11575b203a0558f5df50126ff04c4598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_id_t dr_get_parent_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the process id of the parent of the current process. </p><dl class="section note"><dt>Note</dt><dd>Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="a8da7923ecc4e020e31442bcc8d9f8d3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">generic_func_t dr_get_proc_address </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the entry point of the exported function with the given name in the module with the given base. Returns NULL on failure.</p>
<p>On Linux, when we say "exported" we mean present in the dynamic symbol table (.dynsym). Global functions and variables in an executable (as opposed to a library) are not exported by default. If an executable is built with the <code>-rdynamic</code> flag to <code>gcc</code>, its global symbols will be present in .dynsym and <a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a> will locate them. Otherwise, the drsyms Extension (see <a class="el" href="page_drsyms.html">Symbol Access Library</a>) must be used to locate the symbols. drsyms searches the debug symbol table (.symtab) in addition to .dynsym.</p>
<dl class="section note"><dt>Note</dt><dd>On Linux this ignores symbol preemption by other modules and only examines the specified module. </dd>
<dd>
On Linux, in order to handle indirect code objects, use <a class="el" href="dr__tools_8h.html#af1a068ad89408abbcfba026706810211">dr_get_proc_address_ex()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="af1a068ad89408abbcfba026706810211"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_proc_address_ex </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#af3e96c875a305558239b74496c4030d0">dr_export_info_t</a> *info&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>info_len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns information in <code>info</code> about the symbol <code>name</code> exported by the module <code>lib</code>. Returns false if the symbol is not found. See the information in <a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a> about what an "exported" function is on Linux.</p>
<dl class="section note"><dt>Note</dt><dd>On Linux this ignores symbol preemption by other modules and only examines the specified module. </dd></dl>

</div>
</div>
<a class="anchor" id="a83b3658ca78e6b7adc81c57691f0fe50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">process_id_t dr_get_process_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the process id of the current process. </p>

</div>
</div>
<a class="anchor" id="af3212441c8fd1642d6d1fb7850562106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_get_random_seed </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the seed used for <a class="el" href="dr__tools_8h.html#aeb3d12bdde33dd279f09bcb2a5bfd901">dr_get_random_value()</a>. </p>

</div>
</div>
<a class="anchor" id="aeb3d12bdde33dd279f09bcb2a5bfd901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint dr_get_random_value </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>max</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pseudo-random number in the range [0..max). The pseudo-random sequence can be repeated by passing the seed used during a run to the next run via the -prng_seed runtime option. </p>

</div>
</div>
<a class="anchor" id="a20dccb3e2b03e8f408b2a340c70a28e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stderr_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a handle to stderr. </p>

</div>
</div>
<a class="anchor" id="aed162d7ad949b05fe8232771eaeca6a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stdin_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a handle to stdin. </p>

</div>
</div>
<a class="anchor" id="a0353e78f517dc281de22539682d9e6d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_get_stdout_file </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a handle to stdout. </p>

</div>
</div>
<a class="anchor" id="a0cabd36923c3e56efb50bc10ee866918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_get_string_option </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>option_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *buf&#160;</td>
          <td class="paramname"><em>OUT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value of a string DynamoRIO runtime option named <code>option_name</code> into <code>buf</code>. Options are listed in <a class="el" href="using.html#sec_options">Fine-Tuning DynamoRIO: Runtime Parameters</a>. DynamoRIO has many other undocumented options which may be queried through this API, but they are not officially supported. The option value is truncated to <code>len</code> bytes and null-terminated. </p><dl class="section return"><dt>Returns</dt><dd>false if no option named <code>option_name</code> exists, and true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a3980d703cc13379a6b57396a7901b1d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_id_t dr_get_thread_id </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the thread id of the thread with drcontext <code>drcontext</code>. </p>

</div>
</div>
<a class="anchor" id="ae517c4817d67af6ad92b8f1d7694080a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_get_time </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structdr__time__t.html">dr_time_t</a> *&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current time. </p>

</div>
</div>
<a class="anchor" id="a787aff5df1ded3de8a7ce9f3efef0594"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_get_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#a3831354cc7402d68719d8055fb3e9931">dr_insert_read_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="ae5567896b7c8fb25bff984fc6717f566"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_get_token </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buflen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility function that aids in tokenizing a string, such as a client options string from <a class="el" href="dr__tools_8h.html#a10831623706378cfc3082c0e27e31c4c">dr_get_options()</a>. The function scans <code>str</code> until a non-whitespace character is found. It then starts copying into <code>buf</code> until a whitespace character is found denoting the end of the token. If the token begins with a quote, the token continues (including across whitespace) until the matching end quote is found. Characters considered whitespace are ' ', '\t', '\r', and '\n'; characters considered quotes are '\'', '\"', and '`'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>The start of the string containing the next token. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>A buffer to store a null-terminated copy of the next token. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buflen</td><td>The capacity of the buffer, in characters. If the token is too large to fit, it will be truncated and null-terminated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the end of the token in <code>str</code>. Thus, to retrieve the subsequent token, call this routine again with the prior return value as the new value of <code>str</code>. Returns NULL when the end of <code>str</code> is reached. </dd></dl>

</div>
</div>
<a class="anchor" id="a60faa40f7e8c819c34fd25cb367c5473"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_global_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>size</code> bytes of memory from DR's global memory pool. </p>

</div>
</div>
<a class="anchor" id="ace8794210449c50fb4d411ad74a8dec1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_global_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="ac69f21285d41fe00b3f4231fcbaf39b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_read_raw_tls </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tls_offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into ilist prior to "where" instruction(s) to read into the general-purpose full-size register <code>reg</code> from the raw TLS slot with offset <code>tls_offs</code> from the TLS base <code>tls_register</code>. </p>

</div>
</div>
<a class="anchor" id="a481c4c988efd4d81ce0a92fe0cc3f276"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_insert_write_raw_tls </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tls_offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>reg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts into ilist prior to "where" instruction(s) to store the value in the general-purpose full-size register <code>reg</code> into the raw TLS slot with offset <code>tls_offs</code> from the TLS base <code>tls_register</code>. </p>

</div>
</div>
<a class="anchor" id="af91a810b83f1173a5720a955c3d0fd4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_notify_on </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff the -stderr_mask runtime option is non-zero, indicating that the user wants notification messages printed to stderr. </p>

</div>
</div>
<a class="anchor" id="a9f74b6f40f9462fe077f4b2cabc6b933"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_thread_native </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the thread represented by <code>drcontext</code> is currently executing natively (typically due to an earlier <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a> return value). </p>

</div>
</div>
<a class="anchor" id="ac5804006579a63b49827169d3ffbebc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_wow64 </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this process is a 32-bit process operating on a 64-bit Windows kernel, known as Windows-On-Windows-64, or WOW64. Returns false otherwise. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="a94c8a2e52880f44d43402d6b0d686db2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a> dr_load_aux_library </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>lib_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>lib_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the library with the given path as an auxiliary client library. The library is not treated as an application module but as an extension of DR. The library will be included in <a class="el" href="dr__tools_8h.html#a2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client()</a> and any faults in the library will be considered client faults. The bounds of the loaded library are returned in the optional out variables. On failure, returns NULL.</p>
<p>If only a filename and not a full path is given, this routine will search for the library in the standard search locations for DR's private loader. </p>

</div>
</div>
<a class="anchor" id="a332a14861f12823994465e8c9b6a3015"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_log </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to DR's log file for the thread with drcontext <code>drcontext</code> if the current loglevel is &gt;= <code>level</code> and the current <code>logmask</code> &amp; <code>mask</code> != 0. The mask constants are below. Logging is disabled for the release build. If <code>drcontext</code> is NULL, writes to the main log file. </p>

</div>
</div>
<a class="anchor" id="a814a1a50cc288dc902f2a2dcef9812c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#ac429103cb983108880aee9b1377c430c">dr_auxlib_routine_ptr_t</a> dr_lookup_aux_library_routine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a>&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the exported routine with the given name in the given client auxiliary library loaded by <a class="el" href="dr__tools_8h.html#a94c8a2e52880f44d43402d6b0d686db2">dr_load_aux_library()</a>. Returns NULL on failure. </p>

</div>
</div>
<a class="anchor" id="a4892d089da710e952a23055bd7db38af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_lookup_module </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the module containing <code>pc</code>. If a module containing <code>pc</code> is found returns a module_data_t describing that module. Returns NULL if <code>pc</code> is outside all known modules, which is the case for most dynamically generated code. Can be used to obtain a module_handle_t for <a class="el" href="dr__tools_8h.html#ac520aa05555ecbf9e525de582d4baa8c">dr_lookup_module_section()</a> or <a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a> via the <code>handle</code> field inside module_data_t.</p>
<dl class="section note"><dt>Note</dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="addd653edd3322cfb025ef8bdc6ae1060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_lookup_module_by_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks up the module with name <code>name</code> ignoring case. If an exact name match is found returns a module_data_t describing that module else returns NULL. User must call <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a> on the returned module_data_t once finished. Can be used to obtain a module_handle_t for <a class="el" href="dr__tools_8h.html#a8da7923ecc4e020e31442bcc8d9f8d3e">dr_get_proc_address()</a>. </p><dl class="section note"><dt>Note</dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac520aa05555ecbf9e525de582d4baa8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_lookup_module_section </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>lib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IMAGE_SECTION_HEADER *&#160;</td>
          <td class="paramname"><em>section_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether <code>pc</code> is within a section within the module in <code>section_found</code> and information about that section in <code>section_out</code>. </p><dl class="section note"><dt>Note</dt><dd>Not yet available on Linux. </dd></dl>

</div>
</div>
<a class="anchor" id="aa88dc6d5b9bf7a3ce2cd907f87eba902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">byte* dr_map_executable_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ade307e7bb7b7ac46e874097fe62b9fef">dr_map_executable_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *size&#160;</td>
          <td class="paramname"><em>OUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads <code>filename</code> as an executable file for examination, rather than for execution. No entry point, initialization, or constructor code is executed, nor is any thread-local storage or other resources set up. Returns the size (which may include unmappped gaps) in <code>size</code>. The return value of the function is the base address at which the file is mapped.</p>
<dl class="section note"><dt>Note</dt><dd>Not currently supported on Mac OSX. </dd></dl>

</div>
</div>
<a class="anchor" id="af7d3a723c65e3762dd62b115577e0625"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_map_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INOUT size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>offs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Memory-maps <code>size</code> bytes starting at offset <code>offs</code> from the file <code>f</code> at address <code>addr</code> with privileges <code>prot</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">f</td><td>The file to map. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">size</td><td>The requested size to map. Upon successful return, contains the actual mapped size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">offs</td><td>The offset within the file at which to start the map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>The requested start address of the map. Unless <code>fixed</code> is true, this is just a hint and may not be honored. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prot</td><td>The access privileges of the mapping, composed of the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>Optional DR_MAP_* flags.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Mapping image files for execution is not supported.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>the start address of the mapping, or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a28d121869aba7466a553effe8356bf5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mark_safe_to_suspend </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this function to mark a region of code as safe for DR to suspend the client while inside the region. DR will not relocate the client from the region and will resume it at precisely the suspend point.</p>
<p>This function must be used in client code that acquires application locks. Use this feature with care! Do not mark code as safe to suspend that has a code cache return point. I.e., do not call this routine from a clean call.</p>
<p>No DR locks can be held while in a safe region. Consequently, do not call this routine from any DR event callback. It may only be used from natively executing code.</p>
<p>Always invoke this routine in pairs, with the first passing true for <code>enter</code> and the second passing false, thus delimiting the region. </p>

</div>
</div>
<a class="anchor" id="a9e262e93823dbc5914eca34540afbc07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mark_trace_head </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Marks the fragment associated with tag <code>tag</code> as a trace head. The fragment need not exist yet &ndash; once it is created it will be marked as a trace head.</p>
<p>DR associates a counter with a trace head and once it passes the -hot_threshold parameter, DR begins building a trace. Before each fragment is added to the trace, DR calls the client's end_trace callback to determine whether to end the trace. (The callback will be called both for standard DR traces and for client-defined traces.)</p>
<dl class="section note"><dt>Note</dt><dd>Some fragments are unsuitable for trace heads. DR will ignore attempts to mark such fragments as trace heads and will return false. If the client marks a fragment that doesn't exist yet as a trace head and DR later determines that the fragment is unsuitable for a trace head it will unmark the fragment as a trace head without notifying the client.</dd>
<dd>
Some fragments' notion of trace heads is dependent on which previous block targets them. For these fragments, calling this routine will only mark as a trace head for targets from the same memory region.</dd></dl>
<p>Returns true if the target fragment is marked as a trace head. </p>

</div>
</div>
<a class="anchor" id="a813f98fcc06c0a1198262b744e98eced"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_dr_internal </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff pc is memory allocated by DR for its own purposes, and would not exist if the application were run natively. </p>

</div>
</div>
<a class="anchor" id="a2a67b03d64626f3d0a78b64bf096ed25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_in_client </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff pc is located inside a client library, an Extension library used by a client, or an auxiliary client library (see <a class="el" href="dr__tools_8h.html#a94c8a2e52880f44d43402d6b0d686db2">dr_load_aux_library()</a>). </p>

</div>
</div>
<a class="anchor" id="aa1dd6ff985f0b21deada31ea33485737"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_is_readable </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see that all bytes with addresses in the range [<code>pc</code>, <code>pc</code> + <code>size</code> - 1] are readable and that reading from that range won't generate an exception (see also <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> and <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a>). </p><dl class="section note"><dt>Note</dt><dd>Nothing guarantees that the memory will stay readable for any length of time. </dd>
<dd>
On Linux, especially if the app is in the middle of loading a library and has not properly set up the .bss yet, a page that seems readable can still generate SIGBUS if beyond the end of an mmapped file. Use <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a> or <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a> to avoid such problems. </dd></dl>

</div>
</div>
<a class="anchor" id="a2c3a19a0dc146c1e5b6747e89bacfb55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_memory_protect </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>new_prot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modifies the memory protections of the region from <code>start</code> through <code>start</code> + <code>size</code>. Modification of memory allocated by DR or of the DR or client libraries themselves is allowed under the assumption that the client knows what it is doing. Modification of the ntdll.dll library on Windows is not allowed. Returns true if successful. </p>

</div>
</div>
<a class="anchor" id="ad444a204e7ca45f9965cfe973470375a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_messagebox </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Displays a message in a pop-up window. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd>
<dd>
On Windows Vista most Windows services are unable to display message boxes. </dd></dl>

</div>
</div>
<a class="anchor" id="a3cac1e57889ba7d16815d8d3b203f256"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_module_contains_addr </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether <code>addr</code> is contained inside any segment of the module <code>data</code>. We recommend using this routine rather than checking against the <code>start</code> and <code>end</code> fields of <code>data</code>, as modules are not always contiguous. </p>

</div>
</div>
<a class="anchor" id="aa057e58c848b5860617a10014f828f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_module_import_iterator_hasnext </td>
          <td>(</td>
          <td class="paramtype">dr_module_import_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there is another module import in the iterator.</p>
<dl class="section note"><dt>Note</dt><dd>ELF does not import directly from other modules. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9863e3f8ac53d7b1d1c023e00c6ec4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#a20e62023d3be1c972a03ac53f15aff55">dr_module_import_t</a>* dr_module_import_iterator_next </td>
          <td>(</td>
          <td class="paramtype">dr_module_import_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advances the passed-in iterator and returns the current module import in the iterator. The pointer returned is only valid until the next call to <a class="el" href="dr__tools_8h.html#ae9863e3f8ac53d7b1d1c023e00c6ec4a">dr_module_import_iterator_next()</a> or <a class="el" href="dr__tools_8h.html#a3767d9282831c030307c9d89cd8c081b">dr_module_import_iterator_stop()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>ELF does not import directly from other modules. </dd></dl>

</div>
</div>
<a class="anchor" id="ab4208bf4fd46868975824d1c865f370e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dr_module_import_iterator_t* dr_module_import_iterator_start </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a module import iterator. Iterates over the list of modules that a given module imports from.</p>
<dl class="section note"><dt>Note</dt><dd>ELF does not import directly from other modules. </dd></dl>

</div>
</div>
<a class="anchor" id="a3767d9282831c030307c9d89cd8c081b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_module_import_iterator_stop </td>
          <td>(</td>
          <td class="paramtype">dr_module_import_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops import iteration and frees a module import iterator.</p>
<dl class="section note"><dt>Note</dt><dd>ELF does not import directly from other modules. </dd></dl>

</div>
</div>
<a class="anchor" id="a1702cf25e24e722d9441f92c41fac33e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_module_iterator_hasnext </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>mi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there is another loaded module in the iterator. </p>

</div>
</div>
<a class="anchor" id="a9d49edb3a7b59f5d817afaa8fc0f1ef9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct__module__data__t.html">module_data_t</a>* dr_module_iterator_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>mi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the module_data_t for the next loaded module in the iterator. User must call <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a> on the returned module_data_t once finished. </p><dl class="section note"><dt>Note</dt><dd>Returned module_data_t must be freed with <a class="el" href="dr__tools_8h.html#ad72ba1e8b98c8e01f2c28ef2e4d3e16e">dr_free_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3310b1bfc22da285af72b1a4a9d10945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a>* dr_module_iterator_start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize a new module iterator. The returned module iterator contains a snapshot of the modules loaded at the time it was created. Use <a class="el" href="dr__tools_8h.html#a1702cf25e24e722d9441f92c41fac33e">dr_module_iterator_hasnext()</a> and <a class="el" href="dr__tools_8h.html#a9d49edb3a7b59f5d817afaa8fc0f1ef9">dr_module_iterator_next()</a> to walk the loaded modules. Call <a class="el" href="dr__tools_8h.html#a15134844f1dd3e914c0da59c65cb3a8d">dr_module_iterator_stop()</a> when finished to release the iterator. </p><dl class="section note"><dt>Note</dt><dd>The iterator does not prevent modules from being loaded or unloaded while the iterator is being walked. </dd></dl>

</div>
</div>
<a class="anchor" id="a15134844f1dd3e914c0da59c65cb3a8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_module_iterator_stop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#afd116a488df74505f27ff57cd49b9f88">dr_module_iterator_t</a> *&#160;</td>
          <td class="paramname"><em>mi</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User should call this routine to free the module iterator. </p>

</div>
</div>
<a class="anchor" id="a082fe71b00688310237fbc2e027c4388"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* dr_module_preferred_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct__module__data__t.html">module_data_t</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the preferred name for the module described by <code>data</code> from <code>data-&gt;module_names</code>. </p>

</div>
</div>
<a class="anchor" id="a40a02be4399639cc9c62cd38979f650f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_module_set_should_instrument </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_instrument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set whether or not the module referred to by <code>handle</code> should be instrumented. If <code>should_instrument</code> is false, code from the module will not be passed to the basic block event. If traces are enabled, code from the module will still reach the trace event. Must be called from the module load event for the module referred to by <code>handle</code>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Turning off instrumentation for modules breaks clients and extensions, such as drwrap, that expect to see every instruction. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9bfd8b7be4967b8caa349e274cd7ea3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_module_should_instrument </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether code from the module should be instrumented, meaning passed to the basic block event. </p>

</div>
</div>
<a class="anchor" id="a55da3fd48670f25ec69ee5daf5975de5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_mutex_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a mutex.</p>
<p>Warning: there are restrictions on when DR-provided mutexes, and locks in general, can be held by a client: no lock should be held while application code is executing in the code cache. Locks can be used while inside client code reached from clean calls out of the code cache, but they must be released before returning to the cache. Failing to follow these restrictions can lead to deadlocks. </p>

</div>
</div>
<a class="anchor" id="aaab148b68bc8e1479a14c175cbf42fc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes <code>mutex</code>. </p>

</div>
</div>
<a class="anchor" id="a04beaefb3e0be6bd0dac39f76398ec1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks <code>mutex</code>. Waits until the mutex is successfully held. </p>

</div>
</div>
<a class="anchor" id="a9accc32bf0c9c784516a7ce5373a3d2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mutex_mark_as_app </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs DR to treat this lock as an application lock. Primarily this avoids debug-build checks that no DR locks are held in situations where locks are disallowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any one lock should either be a DR lock or an application lock. Use this routine with caution and do not call it on a DR lock that is used in DR contexts, as it disables debug checks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ae453a9c1ded7c8cd31d1a1aa2c8810af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mutex_self_owns </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true iff <code>mutex</code> is owned by the calling thread. This routine is only available in debug builds. In release builds it always returns true. </p>

</div>
</div>
<a class="anchor" id="a6b2ae4a29e2dc18dde2a6f01f26cbe79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries once to lock <code>mutex</code>, returns whether or not successful. </p>

</div>
</div>
<a class="anchor" id="a61a3a4ffffd0058a37211405fbb6ba51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks <code>mutex</code>. Asserts that mutex is currently locked. </p>

</div>
</div>
<a class="anchor" id="ac32b5be072876c25a832d510efeba6e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_nonheap_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>size</code> bytes of memory as a separate allocation from DR's heap, allowing for separate protection. The <code>prot</code> protection should use the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. When creating a region to hold dynamically generated code, use this routine in order to create executable memory. </p>

</div>
</div>
<a class="anchor" id="a401b819525f805d04e0a9560fdcfdf89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_nonheap_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#ac32b5be072876c25a832d510efeba6e4">dr_nonheap_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="ae3ae2190774a204af207602791a32cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">file_t dr_open_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>mode_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Opens the file <code>fname</code>. If no such file exists then one is created. The file access mode is set by the <code>mode_flags</code> argument which is drawn from the DR_FILE_* defines ORed together. Returns INVALID_FILE if unsuccessful.</p>
<p>On Windows, <code>fname</code> is safest as an absolute path (when using Windows system calls directly there is no such thing as a relative path). A relative path passed to this routine will be converted to absolute on a best-effort basis using the current directory that was set at process initialization time. (The most recently set current directory can be retrieved (albeit with no safety guarantees) with <a class="el" href="dr__tools_8h.html#aae2e62195a2732b0f5c1004138b800a6">dr_get_current_directory()</a>.) Drive-implied-absolute paths ("\foo.txt") and other-drive-relative paths ("c:foo.txt") are not supported.</p>
<p>On Linux, the file descriptor will be marked as close-on-exec. The DR_FILE_CLOSE_ON_FORK flag can be used to automatically close a file on a fork.</p>
<dl class="section note"><dt>Note</dt><dd>No more then one write mode flag can be specified.</dd>
<dd>
On Linux, DR hides files opened by clients from the application by using file descriptors that are separate from the application's and preventing the application from closing client-opened files. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ac0d710a2af2ab256bd5940b936ac3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dr_page_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of a page of memory. </p>

</div>
</div>
<a class="anchor" id="aecb77c99028d913a72c6aaeef48db785"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_print_instr </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinstr__t.html">instr_t</a> *&#160;</td>
          <td class="paramname"><em>instr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints <code>msg</code> followed by the instruction <code>instr</code> to file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="a5902fa16202c9c42d96c755e9412d372"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_print_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopnd__t.html">opnd_t</a>&#160;</td>
          <td class="paramname"><em>opnd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prints <code>msg</code> followed by the operand <code>opnd</code> to file <code>f</code>. </p>

</div>
</div>
<a class="anchor" id="abad2eddb3786e3e909ff36da39b7e31e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_printf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stdout printing that won't interfere with the application's own printing. It is not buffered, which means that it should not be used for very frequent, small print amounts: for that the client should either do its own buffering or it should use printf from the C library via DR's private loader. </p><dl class="section note"><dt>Note</dt><dd>On Windows 7 and earlier, this routine is not able to print to the <code>cmd</code> window unless <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations: see <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a>. </dd>
<dd>
This routine supports printing wide characters via the ls or S format specifiers. On Windows, they are assumed to be UTF-16, and are converted to UTF-8. On Linux, they are converted by simply dropping the high-order bytes. </dd>
<dd>
If the data to be printed is large it will be truncated to an internal buffer size. Use <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> and <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a> for large output. </dd>
<dd>
When printing floating-point values, the caller's code should use <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state. </dd></dl>

</div>
</div>
<a class="anchor" id="ad158d2822dd8bb9caa9604d84b666bfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_query_memory </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">byte **&#160;</td>
          <td class="paramname"><em>base_pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint *&#160;</td>
          <td class="paramname"><em>prot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An os neutral method for querying a memory address. Returns true iff a memory region containing <code>pc</code> is found. If found additional information about the memory region is returned in the optional out arguments <code>base_pc</code>, <code>size</code>, and <code>prot</code> where <code>base_pc</code> is the start address of the memory region continaing <code>pc</code>, <code>size</code> is the size of said memory region and <code>prot</code> is an ORed combination of DR_MEMPROT_* flags describing its current protection.</p>
<dl class="section note"><dt>Note</dt><dd>To examine only application memory, skip memory for which <a class="el" href="dr__tools_8h.html#a813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal()</a> or <a class="el" href="dr__tools_8h.html#a2a67b03d64626f3d0a78b64bf096ed25">dr_memory_is_in_client()</a> returns true.</dd>
<dd>
DR may mark writable code pages as read-only but pretend they're writable. When this happens, it will include both <a class="el" href="dr__tools_8h.html#a1dafb99a4933112c603189bc091fa752">DR_MEMPROT_WRITE</a> and <a class="el" href="dr__tools_8h.html#a0dcb0f62864c67d1aa74381035b5bbfe">DR_MEMPROT_PRETEND_WRITE</a> in <code>prot</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5a6e4049f8accbc73ec5dbaf0deb25a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_query_memory_ex </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT <a class="el" href="dr__tools_8h.html#a2834876d9bbe13989ed6ebc2e2f94c6a">dr_mem_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides additional information beyond <a class="el" href="dr__tools_8h.html#ad158d2822dd8bb9caa9604d84b666bfa">dr_query_memory()</a>. Returns true if it was able to obtain information (including about free regions) and sets the fields of <code>info</code>. This routine can be used to iterate over the entire address space. Such an iteration should stop on reaching the top of the address space, or on reaching kernel memory (look for <a class="el" href="dr__tools_8h.html#aff97be516bbb1aecdb6bd043841aaa10a4155a1d348b4dc103ef7d5cd1c6dc257">DR_MEMTYPE_ERROR_WINKERNEL</a>) on Windows.</p>
<p>Returns false on failure and sets info-&gt;type to a DR_MEMTYPE_ERROR* code indicating the reason for failure.</p>
<dl class="section note"><dt>Note</dt><dd>To examine only application memory, skip memory for which <a class="el" href="dr__tools_8h.html#a813f98fcc06c0a1198262b744e98eced">dr_memory_is_dr_internal()</a> returns true.</dd>
<dd>
DR may mark writable code pages as read-only but pretend they're writable. When this happens, it will include both <a class="el" href="dr__tools_8h.html#a1dafb99a4933112c603189bc091fa752">DR_MEMPROT_WRITE</a> and <a class="el" href="dr__tools_8h.html#a0dcb0f62864c67d1aa74381035b5bbfe">DR_MEMPROT_PRETEND_WRITE</a> in <code>info-&gt;prot</code>. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c9e86d9d052e7b4f6d47402185fbb79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_raw_brk </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>new_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the program break to the specified value. Invokes the SYS_brk system call and returns the result. This is the application's program break, so use this system call only when deliberately changing the application's behavior. </p><dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6201fa3676b0afb76f91f15822cf0d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_raw_mem_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>prot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This raw memory allocation interface is in flux and is subject to change in the next release. Consider it experimental in this release.</dd></dl>
<p>Allocates <code>size</code> bytes (page size aligned) of memory as a separate allocation at preferred base <code>addr</code> that must be page size aligned, allowing for separate protection. If <code>addr</code> is NULL, an arbitrary address is picked.</p>
<p>The <code>prot</code> protection should use the DR_MEMPROT_READ, DR_MEMPROT_WRITE, and DR_MEMPROT_EXEC bits. The allocated memory is not considered to be DynamoRIO or tool memory and thus is not kept separate from the application. Use of this memory is at the client's own risk.</p>
<p>Returns the actual address allocated or NULL if memory allocation at preferred base fails. </p>

</div>
</div>
<a class="anchor" id="a17b097679298ae00bab97d77ed4a17c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_raw_mem_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees memory allocated by <a class="el" href="dr__tools_8h.html#ad6201fa3676b0afb76f91f15822cf0d1">dr_raw_mem_alloc()</a>. <code>addr</code> and <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#ad6201fa3676b0afb76f91f15822cf0d1">dr_raw_mem_alloc()</a> on Windows. </p>

</div>
</div>
<a class="anchor" id="a83555066ac1477ba607bee5f34626d35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_raw_mremap </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>old_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>new_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls mremap with the specified parameters and returns the result. The old memory must be non-DR memory, and the new memory is also considered to be non-DR memory (see <a class="el" href="dr__tools_8h.html#abb7e20e83f7b8e1b65428e45c8ab4211aa0d11211c580eb6b368d07cb7546e376">DR_ALLOC_NON_DR</a>). </p><dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a class="anchor" id="aea4bc51b4771fceb56f050d0f20cbc99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_raw_tls_calloc </td>
          <td>(</td>
          <td class="paramtype">OUT <a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a> *&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&#160;</td>
          <td class="paramname"><em>num_slots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>num_slots</code> contiguous thread-local storage (TLS) slots that can be directly accessed via an offset from <code>tls_register</code>. If <code>alignment</code> is non-zero, the slots will be aligned to <code>alignment</code>. These slots will be initialized to 0 for each new thread. The slot offsets are [<code>offset</code> .. <code>offset</code> + (num_slots - 1)]. These slots are disjoint from the <a class="el" href="dr__ir__utils_8h.html#a89a6b714ff24d91d78589877047a29b9">dr_spill_slot_t</a> register spill slots and the client tls field (<a class="el" href="dr__tools_8h.html#a787aff5df1ded3de8a7ce9f3efef0594">dr_get_tls_field()</a>). Returns whether or not the slots were successfully obtained. The linear address of the TLS base pointed at by <code>tls_register</code> can be obtained using <a class="el" href="dr__tools_8h.html#a25889ae165da2ece91e591f3a8a32650">dr_get_dr_segment_base</a>. Raw TLs slots can be read directly using <a class="el" href="dr__tools_8h.html#ac69f21285d41fe00b3f4231fcbaf39b3">dr_insert_read_raw_tls()</a> and written using <a class="el" href="dr__tools_8h.html#a481c4c988efd4d81ce0a92fe0cc3f276">dr_insert_write_raw_tls()</a>.</p>
<p>Supports passing 0 for <code>num_slots</code>, in which case <code>tls_register</code> will be written but no other action taken.</p>
<dl class="section note"><dt>Note</dt><dd>These slots are useful for thread-shared code caches. With thread-private caches, DR's memory pools are guaranteed to be reachable via absolute or rip-relative accesses from the code cache and client libraries.</dd>
<dd>
These slots are a limited resource. On Windows the slots are shared with the application and reserving even one slot can result in failure to initialize for certain applications. On Linux they are more plentiful and transparent but currently DR limits clients to no more than 64 slots. </dd></dl>

</div>
</div>
<a class="anchor" id="afc53219d019078a38c80ffa80d71829e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_raw_tls_cfree </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>num_slots</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees <code>num_slots</code> raw thread-local storage slots starting at offset <code>offset</code> that were allocated with <a class="el" href="dr__tools_8h.html#aea4bc51b4771fceb56f050d0f20cbc99">dr_raw_tls_calloc()</a>. Returns whether or not the slots were successfully freed. </p>

</div>
</div>
<a class="anchor" id="a58eaa896c06cf679d299b804d6669926"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopnd__t.html">opnd_t</a> dr_raw_tls_opnd </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__ir__opnd_8h.html#a0ee0a856086c863d56ad515919e03136">reg_id_t</a>&#160;</td>
          <td class="paramname"><em>tls_register</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>tls_offs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an operand that refers to the raw TLS slot with offset <code>tls_offs</code> from the TLS base <code>tls_register</code>. </p>

</div>
</div>
<a class="anchor" id="a71f6940085912cdce608f317a27fc397"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t dr_read_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads up to <code>count</code> bytes from file <code>f</code> into <code>buf</code>. Returns the actual number read. </p>

</div>
</div>
<a class="anchor" id="a5563eff378a7e2ea61b7dd7fcd777a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_recurlock_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes a recursive lock. A recursive lock allows the same thread to acquire it multiple times. The lock restrictions for mutexes apply (see <a class="el" href="dr__tools_8h.html#a55da3fd48670f25ec69ee5daf5975de5">dr_mutex_create()</a>). </p>

</div>
</div>
<a class="anchor" id="af7a203f4a8ebcc35d50e51ed31a51b1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_recurlock_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes <code>reclock</code>. </p>

</div>
</div>
<a class="anchor" id="abf5a80009a8f667b86acb529fbc75ac4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_recurlock_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires <code>reclock</code>, or increments the ownership count if already owned. </p>

</div>
</div>
<a class="anchor" id="a376d41758da76279edfe5f649382feb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_recurlock_mark_as_app </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs DR to treat this lock as an application lock. Primarily this avoids debug-build checks that no DR locks are held in situations where locks are disallowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any one lock should either be a DR lock or an application lock. Use this routine with caution and do not call it on a DR lock that is used in DR contexts, as it disables debug checks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ac33bd56345cfb4286a05e0c3eab6b3a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_recurlock_self_owns </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the calling thread owns <code>reclock</code>. </p>

</div>
</div>
<a class="anchor" id="a16d473debdc03a782d8aa5032fb3dd97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_recurlock_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries once to acquire <code>reclock</code> and returns whether successful. </p>

</div>
</div>
<a class="anchor" id="a7d36a11978be634e28116da9dd408030"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_recurlock_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>reclock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrements the ownership count of <code>reclock</code> and releases if zero. </p>

</div>
</div>
<a class="anchor" id="ab23dff0c2d6d045cd938fc5f2c77a1ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_rename_file </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renames the file <code>src</code> to <code>dst</code>, replacing an existing file named <code>dst</code> if <code>replace</code> is true. Atomic if <code>src</code> and <code>dst</code> are on the same filesystem. Returns true if successful. </p>

</div>
</div>
<a class="anchor" id="a5421c0abd69da94ed3e7fb898d5bb132"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_replace_fragment </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">instrlist_t *&#160;</td>
          <td class="paramname"><em>ilist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the fragment with tag <code>tag</code> with the instructions in <code>ilist</code>. This routine is only valid with the -thread_private option; it replaces the fragment for the current thread only. After replacement, the existing fragment is allowed to complete if currently executing. For example, a clean call replacing the currently executing fragment will safely return to the existing code. Subsequent executions will use the new instructions.</p>
<dl class="section note"><dt>Note</dt><dd>The routine takes control of <code>ilist</code> and all responsibility for deleting it. The client should not keep, use, or reference, the instrlist or any of the instrs it contains after passing.</dd>
<dd>
This routine supports replacement for the current thread only. <code>drcontext</code> must be from the current thread and must be the drcontext used to create the instruction list. This routine may not be called from the thread exit event.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>false if the fragment does not exist and true otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a902bfca468a7a2cc3dbc45b4bd127444"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_request_synchronized_exit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Replaced by <a class="el" href="dr__events_8h.html#acede43748af42c6334a19fc30e48c5f4">dr_set_process_exit_behavior()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1193842150b09442a1b3c91f4e02d280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_resume_all_other_threads </td>
          <td>(</td>
          <td class="paramtype">IN void **&#160;</td>
          <td class="paramname"><em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IN uint&#160;</td>
          <td class="paramname"><em>num_suspended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>May only be used after invoking <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. This routine resumes the threads that were suspended by <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a> and must be passed the same array and count of suspended threads that were returned by <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. It also frees the <code>drcontexts</code> array and releases the locks acquired by <a class="el" href="dr__tools_8h.html#a01fbe357fcc8352ba63c9a1a23e0c207">dr_suspend_all_other_threads()</a>. The return value indicates whether all resumption attempts were successful. </p>

</div>
</div>
<a class="anchor" id="a36206cb11622f8c9aee12016e916a190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_retakeover_suspended_native_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Causes the thread owning <code>drcontext</code> to begin executing in the code cache again once it is resumed. The thread must currently be suspended (typically by <a class="el" href="dr__tools_8h.html#a8c0a1bdefb011cf62eb2540e933cb331">dr_suspend_all_other_threads_ex()</a> with <a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179a21ba834e13979aa7ad97fd13c69b3ae4">DR_SUSPEND_NATIVE</a>) and must be currently native (typically from <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a>). </p><dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a536222ea450d92cabebd3b24fe08098e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_rwlock_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates and initializes a read-write lock. A read-write lock allows multiple readers or alternatively a single writer. The lock restrictions for mutexes apply (see <a class="el" href="dr__tools_8h.html#a55da3fd48670f25ec69ee5daf5975de5">dr_mutex_create()</a>). </p>

</div>
</div>
<a class="anchor" id="aba97c3f8aea471718852b424e6bce35d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_destroy </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="ac3e6105ff0e2a3593f5ef296074e21e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_rwlock_mark_as_app </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs DR to treat this lock as an application lock. Primarily this avoids debug-build checks that no DR locks are held in situations where locks are disallowed.</p>
<dl class="section warning"><dt>Warning</dt><dd>Any one lock should either be a DR lock or an application lock. Use this routine with caution and do not call it on a DR lock that is used in DR contexts, as it disables debug checks.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a96d7cd454ca96a0c2d1e701ab78cbcd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_read_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires a read lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="a3acf4f252a71dc5034aa0d99a59103a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_read_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a read lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="aeb9b30addf3e5bf910109061159aef01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_rwlock_self_owns_write_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the calling thread owns the write lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="afcb402769c7bc443876c00ad1f9cdbf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_write_lock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Acquires a write lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="ac7e812e134e71ea3b844387a75bfc273"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_rwlock_write_trylock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tries once to acquire a write lock on <code>rwlock</code> and returns whether successful. </p>

</div>
</div>
<a class="anchor" id="adfb241b0d90ee47cc3885d2c24c70d94"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_rwlock_write_unlock </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>rwlock</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a write lock on <code>rwlock</code>. </p>

</div>
</div>
<a class="anchor" id="a6a94558696130c76f34dcdac0ce50c47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_safe_read </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>out_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely reads <code>size</code> bytes from address <code>base</code> into buffer <code>out_buf</code>. Reading is done without the possibility of an exception occurring. Optionally returns the actual number of bytes copied into <code>bytes_read</code>. Returns true if successful. </p><dl class="section note"><dt>Note</dt><dd>See also <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab94f47b693cc7dd9eecba07d8cfd1bc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_safe_write </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>in_buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>bytes_written</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Safely writes <code>size</code> bytes from buffer <code>in_buf</code> to address <code>base</code>. Writing is done without the possibility of an exception occurring. Optionally returns the actual number of bytes copied into <code>bytes_written</code>. Returns true if successful. </p><dl class="section note"><dt>Note</dt><dd>See also <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a401eb84af927fa3bd1358f6b639ec592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_set_client_name </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>report_URL</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets information presented to users in diagnostic messages. Only one name is supported, regardless of how many clients are in use. If this routine is called a second time, the new values supersede the original. The <code>report_URL</code> is meant to be a bug tracker location where users should go to report errors in the client end-user tool. </p>

</div>
</div>
<a class="anchor" id="a865f2d467e2732365a8e8c49e5a26310"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_set_client_version_string </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>version</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the version string presented to users in diagnostic messages. </p>

</div>
</div>
<a class="anchor" id="a9191c67a267070ed51289d7192f986aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_set_itimer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>which</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>millisec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *drcontext, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mcontext)&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Installs an interval timer in the itimer sharing group that contains the calling thread.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">which</td><td>Must be one of ITIMER_REAL, ITIMER_VIRTUAL, or ITIMER_PROF </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">millisec</td><td>The frequency of the timer, in milliseconds. Passing 0 disables the timer. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>The function that will be called each time the timer fires. It will be passed the context of the thread that received the itimer signal and its machine context, which has not been translated and so may contain raw code cache values. The function will be called from a signal handler that may have interrupted a lock holder or other critical code, so it must be careful in its operations: keep it as simple as possible, and avoid lock usage or I/O operations. If a general timer that does not interrupt client code is required, the client should create a separate thread via <a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread()</a> (which is guaranteed to have a private itimer) and set the itimer there, where the callback function can perform more operations safely if that new thread never acquires locks in its normal operation.</td></tr>
  </table>
  </dd>
</dl>
<p>Itimer sharing varies by kernel. Prior to 2.6.12 itimers were thread-private; after 2.6.12 they are shared across a thread group, though there could be multiple thread groups in one address space. The <a class="el" href="dr__tools_8h.html#ab5cd85ea911bd99dedbd8d05796260bc">dr_get_itimer()</a> function can be used to see whether a thread already has an itimer in its group to avoid re-setting an itimer set by an earlier thread. A client thread created by <a class="el" href="dr__tools_8h.html#ac6b80b83502ff13d4674b13e7b30b555">dr_create_client_thread()</a> is guaranteed to not share its itimers with application threads.</p>
<p>The itimer will operate successfully in the presence of an application itimer of the same type.</p>
<p>The return value indicates whether the timer was successfully installed (or uninstalled if 0 was passed for <code>millisec</code>).</p>
<dl class="section note"><dt>Note</dt><dd>Linux-only. </dd></dl>

</div>
</div>
<a class="anchor" id="a53bfa41e85c457ff39452a68eaf2281b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_set_random_seed </td>
          <td>(</td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>seed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the seed used for <a class="el" href="dr__tools_8h.html#aeb3d12bdde33dd279f09bcb2a5bfd901">dr_get_random_value()</a>. Generally this would only be called during client initialization. </p>

</div>
</div>
<a class="anchor" id="a05b499c8a3115e9ceb4c45dbee660738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_set_tls_field </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user-controlled thread-local-storage field. To generate an instruction sequence that reads the drcontext field inline in the code cache, use <a class="el" href="dr__ir__utils_8h.html#a982089284bd51339f448ec4b3928d3b4">dr_insert_write_tls_field()</a>. </p>

</div>
</div>
<a class="anchor" id="af154e498d8b185931ef970676cb65351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_sleep </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>time_ms</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current thread sleeps for <code>time_ms</code> milliseconds. </p>

</div>
</div>
<a class="anchor" id="ab0c5f2529d9c076b5b0b0e92a70834b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_snprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility routine to print a formatted message to a string. Will not print more than max characters. If successful, returns the number of characters printed, not including the terminating null character. If the number of characters to write equals max, then the caller is responsible for supplying a terminating null character. If the number of characters to write exceeds max, then max characters are written and -1 is returned. If an error occurs, a negative value is returned. </p><dl class="section note"><dt>Note</dt><dd>This routine supports printing wide characters via the ls or S format specifiers. On Windows, they are assumed to be UTF-16, and are converted to UTF-8. On Linux, they are converted by simply dropping the high-order bytes. </dd>
<dd>
On Windows, you can use _snprintf() instead (though _snprintf() does not support printing floating point values and does not convert between UTF-16 and UTF-8). </dd>
<dd>
When printing floating-point values, the caller's code should use <a class="el" href="dr__proc_8h.html#a4a11c9d5d127ce126562ad35b4d165dd">proc_save_fpstate()</a> or be inside a clean call that has requested to preserve the floating-point state. </dd></dl>

</div>
</div>
<a class="anchor" id="a67c362b4605972c0d54142c4469e45c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_snwprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wide character version of <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a>. All of the comments for <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> apply, except for the hs or S format specifiers. On Windows, these will assume that the input is UTF-8, and will convert to UTF-16. On Linux, they will widen a single-byte character string into a wchar_t character string with zero as the high-order bytes. </p>

</div>
</div>
<a class="anchor" id="ae227695587313ae94369e43e459ee762"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_sscanf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Utility routine to parse strings that match a pre-defined format string, similar to the sscanf() C routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">str</td><td>String to parse. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fmt</td><td>Format string controlling parsing. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">...</td><td>All remaining parameters interpreted as output parameter pointers. The type of each parameter must match the type implied by the corresponding format specifier in <code>fmt</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of specifiers matched.</dd></dl>
<p>The benefit of using <a class="el" href="dr__tools_8h.html#ae227695587313ae94369e43e459ee762">dr_sscanf()</a> over native sscanf() is that DR's implementation is standalone, signal-safe, and cross-platform. On Linux, sscanf() has been observed to call malloc(). On Windows, sscanf() will call strlen(), which can break when using mapped files.</p>
<p>The behavior of <a class="el" href="dr__tools_8h.html#ae227695587313ae94369e43e459ee762">dr_sscanf()</a> is mostly identical to that of the sscanf() C routine.</p>
<p>Supported format specifiers:</p><ul>
<li>%s: Matches a sequence of non-whitespace characters. The string is copied into the provided output buffer. To avoid buffer overflow, the caller should use a width specifier.</li>
<li>%c: Matches any single character.</li>
<li>%d: Matches a signed decimal integer.</li>
<li>%u: Matches an unsigned decimal integer.</li>
<li>%x: Matches an unsigned hexadecimal integer, with or without a leading 0x.</li>
<li>%p: Matches a pointer-sized hexadecimal integer as x does.</li>
<li>%%: Matches a literal % character. Does not store output.</li>
</ul>
<p>Supported format modifiers:</p><ul>
<li>*: The * modifier causes the scan to match the specifier, but not store any output. No output parameter is consumed for this specifier, and one should not be passed.</li>
<li>0-9: A decimal integer preceding the specifier gives the width to match. For strings, this indicates the maximum number of characters to copy. For integers, this indicates the maximum number of digits to parse.</li>
<li>h: Marks an integer specifier as short.</li>
<li>l: Marks an integer specifier as long.</li>
<li>ll: Marks an integer specifier as long long. Use this for 64-bit integers.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd><a class="el" href="dr__tools_8h.html#ae227695587313ae94369e43e459ee762">dr_sscanf()</a> does <em>not</em> support parsing floating point numbers yet. </dd></dl>

</div>
</div>
<a class="anchor" id="af63184f56cc0508e2840f64e84b1c48d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_standalone_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a DR context that can be used in a standalone program. </p><dl class="section warning"><dt>Warning</dt><dd>This context cannot be used as the drcontext for a thread running under DR control! It is only for standalone programs that wish to use DR as a library of disassembly, etc. routines. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>NULL on failure, such as running on an unsupported operating system version. </dd></dl>

</div>
</div>
<a class="anchor" id="a01fbe357fcc8352ba63c9a1a23e0c207"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_suspend_all_other_threads </td>
          <td>(</td>
          <td class="paramtype">OUT void ***&#160;</td>
          <td class="paramname"><em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_unsuspended</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a8c0a1bdefb011cf62eb2540e933cb331">dr_suspend_all_other_threads_ex()</a> with <code>flags</code> set to 0. </p>

</div>
</div>
<a class="anchor" id="a8c0a1bdefb011cf62eb2540e933cb331"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_suspend_all_other_threads_ex </td>
          <td>(</td>
          <td class="paramtype">OUT void ***&#160;</td>
          <td class="paramname"><em>drcontexts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_suspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OUT uint *&#160;</td>
          <td class="paramname"><em>num_unsuspended</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#a66bef18f8eabc7a8b8b0368e8a96d179">dr_suspend_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Suspends all other threads in the process and returns an array of contexts in <code>drcontexts</code> with one context per successfully suspended thread. The contexts can be passed to routines like <a class="el" href="dr__tools_8h.html#a3980d703cc13379a6b57396a7901b1d1">dr_get_thread_id()</a> or <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a>. However, the contexts may not be modified: <a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext()</a> is not supported. <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> can be called on the caller of this routine, unless in a Windows nudge callback.</p>
<p>The <code>flags</code> argument controls which threads are suspended and may add further options in the future.</p>
<p>The number of successfully suspended threads, which is also the length of the <code>drcontexts</code> array, is returned in <code>num_suspended</code>, which is a required parameter. The number of un-successfully suspended threads, if any, is returned in the optional parameter <code>num_unsuspended</code>. The calling thread is not considered in either count. DR can fail to suspend a thread for privilege reasons (e.g., on Windows in a low-privilege process where another process injected a thread). This function returns true iff all threads were suspended, in which case <code>num_unsuspended</code> will be 0.</p>
<p>The caller must invoke <a class="el" href="dr__tools_8h.html#a1193842150b09442a1b3c91f4e02d280">dr_resume_all_other_threads()</a> in order to resume the suspended threads, free the <code>drcontexts</code> array, and release coarse-grain locks that prevent new threads from being created.</p>
<p>This routine may not be called from any registered event callback other than the nudge event or the pre- or post-system call event. It may be called from clean calls out of the cache. This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout.</p>
<dl class="section note"><dt>Note</dt><dd>A client wishing to invoke this routine from an event callback can queue up a nudge via <a class="el" href="dr__events_8h.html#a9d11fb8fbffdcb0cb6e7b87f804cb459">dr_nudge_client()</a> and invoke this routine from the nudge callback. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2944aa54d591a236f5334a35bfb41bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_switch_to_app_state </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to dr_switch_to_app_state_ex(drcontext, DR_STATE_ALL). </p>

</div>
</div>
<a class="anchor" id="ae937ce8bbb24330c25acd6d1c04cb5a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_switch_to_app_state_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70">dr_state_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swaps to the application version of any system state for the given thread. This is meant to be used prior to examining application memory, when private libraries are in use and there are two versions of system state. Invoking non-DR library routines while the application state is in place can lead to unpredictable results: call <a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a> (or the _ex version) before doing so.</p>
<p>This function does not affect whether the current machine context (registers) contains application state or not.</p>
<p>The <code>flags</code> argument allows selecting a subset of the state to swap. </p>

</div>
</div>
<a class="anchor" id="a97ba972c50a47e7121c98652b461ae8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_switch_to_dr_state </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to dr_switch_to_dr_state_ex(drcontext, DR_STATE_ALL). </p>

</div>
</div>
<a class="anchor" id="a994e632ea892a947612b44027467ea2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_switch_to_dr_state_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ad051d9da5ddb2100eb450587e7551a70">dr_state_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should only be called after calling <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a> (or the _ex version), or in certain cases where a client is running its own code in an application state. Swaps from the application version of system state for the given thread back to the DR and client version.</p>
<p>This function does not affect whether the current machine context (registers) contains application state or not.</p>
<p>A client must call <a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a> in order to safely call private library routines if it is running in an application context where <a class="el" href="dr__tools_8h.html#a7ed94a2b046bb9ee777afe4f3ef1237f">dr_using_app_state()</a> returns true. On Windows, this is the case for any application context, as the system state is always swapped. On Linux, however, execution of application code in the code cache only swaps the machine context and not the system state. Thus, on Linux, while in the code cache, <a class="el" href="dr__tools_8h.html#a7ed94a2b046bb9ee777afe4f3ef1237f">dr_using_app_state()</a> will return false, and it is safe to invoke private library routines without calling <a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a>. Only if client or client-invoked code will examine a segment selector or descriptor does the state need to be swapped. A state swap is much more expensive on Linux (it requires a system call) than on Windows.</p>
<p>The same flags that were passed to <a class="el" href="dr__tools_8h.html#ae937ce8bbb24330c25acd6d1c04cb5a0">dr_switch_to_app_state_ex()</a> should be passed here. </p>

</div>
</div>
<a class="anchor" id="a9913028815c4a9f76a14871b9f1d74d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_symbol_export_iterator_hasnext </td>
          <td>(</td>
          <td class="paramtype">dr_symbol_export_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there is another exported symbol in the iterator. </p>

</div>
</div>
<a class="anchor" id="a84a9316bfb47fb3a854bf371da4e2190"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#a5f313b8ed7cdc35283e82a59a6492077">dr_symbol_export_t</a>* dr_symbol_export_iterator_next </td>
          <td>(</td>
          <td class="paramtype">dr_symbol_export_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next exported symbol. The returned pointer is valid until the next call to <a class="el" href="dr__tools_8h.html#a84a9316bfb47fb3a854bf371da4e2190">dr_symbol_export_iterator_next()</a> or <a class="el" href="dr__tools_8h.html#a3ab1fb16deb7bdec1216e61bbc265cdb">dr_symbol_export_iterator_stop()</a>. </p>

</div>
</div>
<a class="anchor" id="adaa00ccf3ea50bcfa7bb7623565bfb41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dr_symbol_export_iterator_t* dr_symbol_export_iterator_start </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an iterator over symbols exported by a module. The iterator returned is invalid until after the first call to <a class="el" href="dr__tools_8h.html#a84a9316bfb47fb3a854bf371da4e2190">dr_symbol_export_iterator_next()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>To iterate over all symbols in a module and not just those exported, use the <a class="el" href="page_drsyms.html">Symbol Access Library</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a3ab1fb16deb7bdec1216e61bbc265cdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_symbol_export_iterator_stop </td>
          <td>(</td>
          <td class="paramtype">dr_symbol_export_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops symbol export iteration and frees the iterator. </p>

</div>
</div>
<a class="anchor" id="a84b16b985754da06d7c8a864dfed2b44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_symbol_import_iterator_hasnext </td>
          <td>(</td>
          <td class="paramtype">dr_symbol_import_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if there is another imported symbol in the iterator. </p>

</div>
</div>
<a class="anchor" id="af3b3e34e05cf82fb5b5801389eab835d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__tools_8h.html#a97862b54ff9ef6f20494449ff47242e6">dr_symbol_import_t</a>* dr_symbol_import_iterator_next </td>
          <td>(</td>
          <td class="paramtype">dr_symbol_import_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the next imported symbol. The returned pointer is valid until the next call to <a class="el" href="dr__tools_8h.html#af3b3e34e05cf82fb5b5801389eab835d">dr_symbol_import_iterator_next()</a> or <a class="el" href="dr__tools_8h.html#a9b57decf95101db3153968868c126e38">dr_symbol_import_iterator_stop()</a>. </p>

</div>
</div>
<a class="anchor" id="a6e4b0ee00f77ddf42c5094735b1fc615"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">dr_symbol_import_iterator_t* dr_symbol_import_iterator_start </td>
          <td>(</td>
          <td class="paramtype">module_handle_t&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dr_module_import_desc_t *&#160;</td>
          <td class="paramname"><em>from_module</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates an iterator over symbols imported by a module. If <code>from_module</code> is NULL, all imported symbols are yielded, regardless of which module they were imported from.</p>
<p>On Windows, from_module is obtained from a <code>dr_module_import_t</code> and used to iterate over all of the imports from a specific module.</p>
<p>The iterator returned is invalid until after the first call to <a class="el" href="dr__tools_8h.html#af3b3e34e05cf82fb5b5801389eab835d">dr_symbol_import_iterator_next()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>On Windows, symbols imported from delay-loaded DLLs are not included yet. </dd></dl>

</div>
</div>
<a class="anchor" id="a9b57decf95101db3153968868c126e38"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_symbol_import_iterator_stop </td>
          <td>(</td>
          <td class="paramtype">dr_symbol_import_iterator_t *&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stops symbol import iteration and frees the iterator. </p>

</div>
</div>
<a class="anchor" id="a1e01fe123ecc9908ada9c9fccbf3f6ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_syscall_get_param </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event. Returns the value of system call parameter number <code>param_num</code>.</p>
<p>It is up to the caller to ensure that reading this parameter is safe: this routine does not know the number of parameters for each system call, nor does it check whether this might read off the base of the stack.</p>
<dl class="section note"><dt>Note</dt><dd>On some platforms, notably MacOS, a 32-bit application's system call can still take a 64-bit parameter (typically on the stack). In that situation, this routine will consider the 64-bit parameter to be split into high and low parts, each with its own parameter number. </dd></dl>

</div>
</div>
<a class="anchor" id="ad12463724bf63a891e991891c72e6a4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">reg_t dr_syscall_get_result </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. Returns the return value of the system call that will be presented to the application.</p>
<dl class="section note"><dt>Note</dt><dd>On some platforms (such as MacOS), a 32-bit application's system call can return a 64-bit value. Use <a class="el" href="dr__tools_8h.html#a0e4cf94bfc4dca2deb04699c28a56e55">dr_syscall_get_result_ex()</a> to obtain the upper bits in that case.</dd>
<dd>
On some platforms (such as MacOS), whether a system call succeeded or failed cannot be determined from the main result value. Use <a class="el" href="dr__tools_8h.html#a0e4cf94bfc4dca2deb04699c28a56e55">dr_syscall_get_result_ex()</a> to obtain the success result in such cases. </dd></dl>

</div>
</div>
<a class="anchor" id="a0e4cf94bfc4dca2deb04699c28a56e55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_syscall_get_result_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a> *info&#160;</td>
          <td class="paramname"><em>INOUT</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. Returns whether it successfully retrieved the results of the system call into <code>info</code>.</p>
<p>The caller should set the <code>size</code>, <code>use_high</code>, and <code>use_errno</code> fields of <code>info</code> prior to calling this routine. See the fields of <a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a> for details. </p>

</div>
</div>
<a class="anchor" id="ae3747468d00df5cdc597688e1e079a64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_syscall_intercept_natively </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sysnum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>wow64_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Must be invoked from <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a>. Requests that the named ntoskrnl system call be intercepted even when threads are native (e.g., due to <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a>). Only a limited number of system calls being intercepted while native are supported. This routine will fail once that limit is reached.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>The system call name. The name must match an exported system call wrapper in <code>ntdll.dll</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">sysnum</td><td>The system call number (the value placed in the eax register). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_args</td><td>The number of arguments to the system call. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wow64_index</td><td>The value placed in the ecx register when this system call is executed in a WOW64 process. This value should be obtainable by examining the system call wrapper.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="a76797a9310bf67ebeb820d80e11764b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_invoke_another </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. An additional system call will be invoked immediately, using the current values of the parameters, which can be set with <a class="el" href="dr__tools_8h.html#ac21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param()</a>. The system call to be invoked should be specified with <a class="el" href="dr__tools_8h.html#abc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum()</a>.</p>
<p>Use this routine with caution. Especially on Windows, care must be taken if the application is expected to continue afterward. When system call parameters are stored on the stack, modifying them can result in incorrect application behavior, particularly when setting more parameters than were present in the original system call, which will result in corruption of the application stack.</p>
<p>On Windows, when the first system call is interruptible (alertable), the additional system call may be delayed.</p>
<p>DR will set key registers such as r10 for 64-bit or xdx for sysenter or WOW64 system calls. However, DR will not set ecx for WOW64; that is up to the client. </p>

</div>
</div>
<a class="anchor" id="ac21a83f1812443112303ef3ea8b76de2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_param </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>new_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#a76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a>. Sets the value of system call parameter number <code>param_num</code> to <code>new_value</code>.</p>
<p>It is up to the caller to ensure that writing this parameter is safe: this routine does not know the number of parameters for each system call, nor does it check whether this might write beyond the base of the stack.</p>
<dl class="section note"><dt>Note</dt><dd>On some platforms, notably MacOS, a 32-bit application's system call can still take a 64-bit parameter (typically on the stack). In that situation, this routine will consider the 64-bit parameter to be split into high and low parts, each with its own parameter number. </dd></dl>

</div>
</div>
<a class="anchor" id="a601cd2b724ac627aef0756a4c4eee637"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_result </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reg_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) or post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. For pre-syscall, should only be used when skipping the system call. This sets the return value of the system call that the application sees to <code>value</code>.</p>
<dl class="section note"><dt>Note</dt><dd>On MacOS, do not use this function as it fails to set the carry flag and thus fails to properly indicate whether the system call succeeded or failed: use <a class="el" href="dr__tools_8h.html#aaae7ca4aa76652ddaaacb1e8dad9f6af">dr_syscall_set_result_ex()</a> instead. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae7ca4aa76652ddaaacb1e8dad9f6af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_syscall_set_result_ex </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a> *&#160;</td>
          <td class="paramname"><em>info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) or post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event. For pre-syscall, should only be used when skipping the system call.</p>
<p>This sets the returned results of the system call as specified in <code>info</code>. Returns whether it successfully did so. See the fields of <a class="el" href="dr__tools_8h.html#af154bb3f9b057795c65b51687bb2ba50">dr_syscall_result_info_t</a> for details. </p>

</div>
</div>
<a class="anchor" id="abc80dfdf8bff3c3feb486aacd69aba7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_syscall_set_sysnum </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Usable only from a pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) event, or from a post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) event when also using <a class="el" href="dr__tools_8h.html#a76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a>. Sets the system call number of the system call about to be invoked to <code>new_num</code>. </p>

</div>
</div>
<a class="anchor" id="a4274226adda06339e247e4a311abdd9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* dr_thread_alloc </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates <code>size</code> bytes of memory from DR's memory pool specific to the thread associated with <code>drcontext</code>. </p>

</div>
</div>
<a class="anchor" id="a3f1f3862009f52182e9ca1f943fa6f14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_thread_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Frees thread-specific memory allocated by <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>. <code>size</code> must be the same as that passed to <a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>. </p>

</div>
</div>
<a class="anchor" id="ac262422c1e5e487113176bd4193c387f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_thread_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Current thread gives up its time quantum. </p>

</div>
</div>
<a class="anchor" id="a1d4c9a29f1c962457c123322aa3e1931"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_trace_exists_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see that if there is a trace in the code cache at tag <code>tag</code>. </p>

</div>
</div>
<a class="anchor" id="a1e3f7e4e3e4048021966c04a4b00fbc9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_trace_head_at </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if the fragment (or future fragment) with tag <code>tag</code> is marked as a trace head. </p>

</div>
</div>
<a class="anchor" id="aef746f843b3270add2c763ab71457e5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_try_setup </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>try_cxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not call this directly: use the DR_TRY_EXCEPT macro instead. </p>

</div>
</div>
<a class="anchor" id="aa59cdd4f9fa2884b5d236f0fedc5bda3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_try_start </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not call this directly: use the DR_TRY_EXCEPT macro instead. </p>

</div>
</div>
<a class="anchor" id="afde42618a83e7e1abdc58961a084e774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_try_stop </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>try_cxt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do not call this directly: use the DR_TRY_EXCEPT macro instead. </p>

</div>
</div>
<a class="anchor" id="a56909cf76e4a71fca13731053ef48928"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unlink_flush_region </td>
          <td>(</td>
          <td class="paramtype">app_pc&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flush all fragments containing any code from the region [<code>start</code>, <code>start</code> + <code>size</code>). Control will not enter a fragment containing code from the region after this returns, but a thread already in such a fragment will finish out the fragment. This includes the current thread if this is called from a clean call that returns to the cache. This routine may only be called during a clean call from the cache, from a nudge event handler, or from a pre- or post-system call event handler. It may not be called from any other event callback. No locks can be held when calling this routine. Returns true if successful.</p>
<dl class="section note"><dt>Note</dt><dd>This routine may not be called from any registered event callback other than the nudge event, the pre- or post-system call events, the exception event, or the signal event; clean calls out of the cache may call this routine. </dd>
<dd>
This routine may not be called while any locks are held that could block a thread processing a registered event callback or cache callout. </dd>
<dd>
<a class="el" href="dr__tools_8h.html#afa5ea6649e644074ca55f456c89264e8">dr_delay_flush_region()</a> has fewer restrictions on use, but is less synchronous. </dd>
<dd>
Use <code>size</code> == 1 to flush fragments containing the instruction at address <code>start</code>. A flush of <code>size</code> == 0 is not allowed. </dd>
<dd>
This routine is only available with either the -thread_private or -enable_full_api options. It is not available when -opt_memory is specified. </dd></dl>

</div>
</div>
<a class="anchor" id="a552563b1ccb84e3708041b276404d577"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unload_aux_library </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__tools_8h.html#ad4bb25312a86996379357f79a4c7c1c1">dr_auxlib_handle_t</a>&#160;</td>
          <td class="paramname"><em>lib</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unloads the given library, which must have been loaded by <a class="el" href="dr__tools_8h.html#a94c8a2e52880f44d43402d6b0d686db2">dr_load_aux_library()</a>. Returns whether successful. </p>

</div>
</div>
<a class="anchor" id="a85779d0a5147a550f263a4381fff5ab5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unmap_executable_file </td>
          <td>(</td>
          <td class="paramtype">byte *&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmaps a file loaded by <a class="el" href="dr__tools_8h.html#aa88dc6d5b9bf7a3ce2cd907f87eba902">dr_map_executable_file()</a>. </p>

</div>
</div>
<a class="anchor" id="ae7f36900cafd048db5b8d34cf92faa45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unmap_file </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmaps a portion of a file mapping previously created by <a class="el" href="dr__tools_8h.html#af7d3a723c65e3762dd62b115577e0625">dr_map_file()</a>. </p><dl class="section return"><dt>Returns</dt><dd>whether successful.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">map</td><td>The base address to be unmapped. Must be page size aligned. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>The size to be unmapped. All pages overlapping with the range are unmapped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>On Windows, the whole file will be unmapped instead. </dd></dl>

</div>
</div>
<a class="anchor" id="a54934632c814904bd9e0ce9c83980466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_using_all_private_caches </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if all DynamoRIO caches are thread private. </p>

</div>
</div>
<a class="anchor" id="a7ed94a2b046bb9ee777afe4f3ef1237f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_using_app_state </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the given thread indicated by <code>drcontext</code> is currently using the application version of its system state. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="dr__tools_8h.html#a97ba972c50a47e7121c98652b461ae8e">dr_switch_to_dr_state()</a>, <a class="el" href="dr__tools_8h.html#aa2944aa54d591a236f5334a35bfb41bf">dr_switch_to_app_state()</a>.</dd></dl>
<p>This function does not indicate whether the machine context (registers) contains application state or not.</p>
<p>On Linux, DR very rarely switches the system state, while on Windows DR switches the system state to the DR and client version on every event callback or clean call. </p>

</div>
</div>
<a class="anchor" id="a505318c1ece53cdaff85f387dc6bf758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_using_console </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the current standard error handle belongs to a legacy console window (viz., <code>cmd</code> on Windows 7 or earlier). DR's <a class="el" href="dr__tools_8h.html#abad2eddb3786e3e909ff36da39b7e31e">dr_printf()</a> and <a class="el" href="dr__tools_8h.html#a1affb1a9f1c49c1959f1a01967a0a0d9">dr_fprintf()</a> do not work with such console windows unless <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a> is called ahead of time, and even then there are limitations detailed in <a class="el" href="dr__tools_8h.html#a712de67b3f6adb6778ce302925009753">dr_enable_console_printing()</a>. This routine may result in loading a private copy of kernel32.dll. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="a55ca77553e86a0656dc186ae3fc8222f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dr_virtual_query </td>
          <td>(</td>
          <td class="paramtype">const byte *&#160;</td>
          <td class="paramname"><em>pc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MEMORY_BASIC_INFORMATION *&#160;</td>
          <td class="paramname"><em>mbi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mbi_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Equivalent to the win32 API function VirtualQuery(). See that routine for a description of arguments and return values. </p><dl class="section note"><dt>Note</dt><dd>Windows only.</dd>
<dd>
DR may mark writable code pages as read-only but pretend they're writable. When this happens, this routine will indicate that the memory is writable. Call <a class="el" href="dr__tools_8h.html#ad158d2822dd8bb9caa9604d84b666bfa">dr_query_memory()</a> or <a class="el" href="dr__tools_8h.html#a5a6e4049f8accbc73ec5dbaf0deb25a7">dr_query_memory_ex()</a> before attempting to write to application memory to ensure it's not read-only underneath. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6b928d8cbc48fdf7d1d82c4fa95e40e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_vsnprintf </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#ab0c5f2529d9c076b5b0b0e92a70834b7">dr_snprintf()</a> but exposes va_list. </p>

</div>
</div>
<a class="anchor" id="aa89fd0244d2133a1e37b5b6662a41cc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int dr_vsnwprintf </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>ap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Identical to <a class="el" href="dr__tools_8h.html#a67c362b4605972c0d54142c4469e45c6">dr_snwprintf()</a> but exposes va_list. </p>

</div>
</div>
<a class="anchor" id="aeddf708cc2271dc50209b3e78e1d23fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t dr_write_file </td>
          <td>(</td>
          <td class="paramtype">file_t&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes <code>count</code> bytes from <code>buf</code> to file <code>f</code>. Returns the actual number written. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_7e8c68b3a1981dda5ab1ff5587b4f0bc.html">include</a></li><li class="navelem"><a class="el" href="dr__tools_8h.html">dr_tools.h</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 7.0.0 --- Fri Feb 3 2017 00:37:39 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>

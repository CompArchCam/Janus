<!-- HTML header for doxygen 1.8.10-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<link rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<title>DynamoRIO API: dr_events.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DynamoRIO API
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('dr__events_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">dr_events.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Event callback registration routines.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="dr__config_8h.html">dr_config.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__fault__fragment__info__t.html">_dr_fault_fragment_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__restore__state__info__t.html">_dr_restore_state_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__exception__t.html">_dr_exception_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct__dr__siginfo__t.html">_dr_siginfo_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aef4b133cb2bf598ee968170d982c4e62"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__fault__fragment__info__t.html">_dr_fault_fragment_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#aef4b133cb2bf598ee968170d982c4e62">dr_fault_fragment_info_t</a></td></tr>
<tr class="separator:aef4b133cb2bf598ee968170d982c4e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a4bd60d7607be81d77f466fd8d7f49"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__restore__state__info__t.html">_dr_restore_state_info_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a19a4bd60d7607be81d77f466fd8d7f49">dr_restore_state_info_t</a></td></tr>
<tr class="separator:a19a4bd60d7607be81d77f466fd8d7f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adebe39e781c20b42f61c7d03ed560587"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__exception__t.html">_dr_exception_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#adebe39e781c20b42f61c7d03ed560587">dr_exception_t</a></td></tr>
<tr class="separator:adebe39e781c20b42f61c7d03ed560587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49900139eb46d5dde3b2b69c175c072"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct__dr__siginfo__t.html">_dr_siginfo_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ab49900139eb46d5dde3b2b69c175c072">dr_siginfo_t</a></td></tr>
<tr class="separator:ab49900139eb46d5dde3b2b69c175c072"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a689518ac5d1ad136b13e03012702b209"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> { <br />
&#160;&#160;<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> = 0, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a8c6fbffdec0fe74acaf82d530ae03b00">DR_EMIT_PERSISTABLE</a> = 0x02, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a9e7a77890e426d1b88e02f29b8433a12">DR_EMIT_MUST_END_TRACE</a> = 0x04, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89">DR_EMIT_GO_NATIVE</a> = 0x08
<br />
 }<tr class="separator:a689518ac5d1ad136b13e03012702b209"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:a4982c54b45ecb525aec1be6b00a9664a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a> <tr class="separator:a4982c54b45ecb525aec1be6b00a9664a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ae2ea678cffff98daafd5aac5bdb65080"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080">dr_exit_flags_t</a> { <br />
&#160;&#160;<a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080a0bd2d4f65566a9c5a9cb6dcf649e5eb8">DR_EXIT_MULTI_THREAD</a> = 0x01, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080ad0a85f8d8abbc6892c31f0b07d1f93aa">DR_EXIT_SKIP_THREAD_EXIT</a> = 0x02
<br />
 }<tr class="separator:ae2ea678cffff98daafd5aac5bdb65080"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:af86ce68b89c76d46c92d36e58ddb7a33"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a> { <br />
&#160;&#160;<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33a45815215e4567ecfbe504d5bb7ab01bf">DR_SIGNAL_DELIVER</a>, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33aeb1a9eb7969b688a26e6e06fef4c6973">DR_SIGNAL_SUPPRESS</a>, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33a0c437214d4411687fe54ad8bb93399a1">DR_SIGNAL_BYPASS</a>, 
<br />
&#160;&#160;<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33a866dcc1af9f9076edcbed9c8afb17e93">DR_SIGNAL_REDIRECT</a>
<br />
 }<tr class="separator:af86ce68b89c76d46c92d36e58ddb7a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a985537df683007e1392e8a3b095ef363"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a985537df683007e1392e8a3b095ef363">dr_register_exit_event</a> (void(*func)(void))</td></tr>
<tr class="separator:a985537df683007e1392e8a3b095ef363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69823e6d3133bb7da291fbe1b1313f8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a69823e6d3133bb7da291fbe1b1313f8c">dr_unregister_exit_event</a> (void(*func)(void))</td></tr>
<tr class="separator:a69823e6d3133bb7da291fbe1b1313f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13e10779d8f91465a0b7aefdf4d87d16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event</a> (<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *bb,                                                                               bool for_trace, bool translating))</td></tr>
<tr class="separator:a13e10779d8f91465a0b7aefdf4d87d16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa69e56ac00bd4709752a0211cfb620e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#afa69e56ac00bd4709752a0211cfb620e">dr_unregister_bb_event</a> (<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *bb,                                                                                       bool for_trace, bool translating))</td></tr>
<tr class="separator:afa69e56ac00bd4709752a0211cfb620e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa474cbc8fe550606cf45187976e50c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#aaa474cbc8fe550606cf45187976e50c1">dr_register_trace_event</a> (<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *trace,                                                                                           bool translating))</td></tr>
<tr class="separator:aaa474cbc8fe550606cf45187976e50c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49e35b747be897c7f15ecab851e5ac50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a49e35b747be897c7f15ecab851e5ac50">dr_unregister_trace_event</a> (<a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*func)(void *drcontext, void *tag, instrlist_t *trace,                                                                                                   bool translating))</td></tr>
<tr class="separator:a49e35b747be897c7f15ecab851e5ac50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a753fffe98b1f5ec53555bdbe21645782"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a753fffe98b1f5ec53555bdbe21645782">dr_register_end_trace_event</a> (<a class="el" href="dr__events_8h.html#a4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*func)(void *drcontext, void *tag, void *next_tag))</td></tr>
<tr class="separator:a753fffe98b1f5ec53555bdbe21645782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65bd74863fdb3fe4306bfce41085e47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#af65bd74863fdb3fe4306bfce41085e47">dr_unregister_end_trace_event</a> (<a class="el" href="dr__events_8h.html#a4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*func)(void *drcontext, void *tag, void *next_tag))</td></tr>
<tr class="separator:af65bd74863fdb3fe4306bfce41085e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698501b03d64f07e1a32fc82c021b27a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a698501b03d64f07e1a32fc82c021b27a">dr_register_delete_event</a> (void(*func)(void *drcontext, void *tag))</td></tr>
<tr class="separator:a698501b03d64f07e1a32fc82c021b27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ece32fa94f968b82ec94cfb2237f42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ac1ece32fa94f968b82ec94cfb2237f42">dr_unregister_delete_event</a> (void(*func)(void *drcontext, void *tag))</td></tr>
<tr class="separator:ac1ece32fa94f968b82ec94cfb2237f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab259e0b7ab6f90de1c8b199877b819d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ab259e0b7ab6f90de1c8b199877b819d3">dr_register_restore_state_event</a> (void(*func)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mcontext,                                                                                                                           bool restore_memory, bool app_code_consistent))</td></tr>
<tr class="separator:ab259e0b7ab6f90de1c8b199877b819d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77bd22c601584470d98081dbd67d41d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a77bd22c601584470d98081dbd67d41d3">dr_unregister_restore_state_event</a> (void(*func)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mcontext,                                                                                                                                   bool restore_memory, bool app_code_consistent))</td></tr>
<tr class="separator:a77bd22c601584470d98081dbd67d41d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2644b520ddec2ee4cecea0161dd3bee0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a2644b520ddec2ee4cecea0161dd3bee0">dr_register_restore_state_ex_event</a> (bool(*func)(void *drcontext, bool restore_memory,                                                                                                                                                                                           <a class="el" href="dr__events_8h.html#a19a4bd60d7607be81d77f466fd8d7f49">dr_restore_state_info_t</a> *info))</td></tr>
<tr class="separator:a2644b520ddec2ee4cecea0161dd3bee0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c7bb4d34bec089bf8b2ee59d8c31bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a98c7bb4d34bec089bf8b2ee59d8c31bf">dr_unregister_restore_state_ex_event</a> (bool(*func)(void *drcontext, bool restore_memory,                                                                                                                                                                                                   <a class="el" href="dr__events_8h.html#a19a4bd60d7607be81d77f466fd8d7f49">dr_restore_state_info_t</a> *info))</td></tr>
<tr class="separator:a98c7bb4d34bec089bf8b2ee59d8c31bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a878920c40c76e2c18043f9db772a24c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:a878920c40c76e2c18043f9db772a24c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5286475e21b7a5aaca3e084f8ad1ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#aff5286475e21b7a5aaca3e084f8ad1ef">dr_unregister_thread_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:aff5286475e21b7a5aaca3e084f8ad1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b0c102bb9a99d67c3e62ea8b3790ff1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a0b0c102bb9a99d67c3e62ea8b3790ff1">dr_register_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:a0b0c102bb9a99d67c3e62ea8b3790ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85b9e60aee5a1b51f102f99471ef4b3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ac85b9e60aee5a1b51f102f99471ef4b3">dr_unregister_thread_exit_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:ac85b9e60aee5a1b51f102f99471ef4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acede43748af42c6334a19fc30e48c5f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#acede43748af42c6334a19fc30e48c5f4">dr_set_process_exit_behavior</a> (<a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080">dr_exit_flags_t</a> flags)</td></tr>
<tr class="separator:acede43748af42c6334a19fc30e48c5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82afd28406cbf06396e1a17ab100c6ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a82afd28406cbf06396e1a17ab100c6ea">dr_register_fork_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:a82afd28406cbf06396e1a17ab100c6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b02bc04d51b3d58cd741653ef1a26ce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a4b02bc04d51b3d58cd741653ef1a26ce">dr_unregister_fork_init_event</a> (void(*func)(void *drcontext))</td></tr>
<tr class="separator:a4b02bc04d51b3d58cd741653ef1a26ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc710e0c8271c496af10a87608dbe1b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#adc710e0c8271c496af10a87608dbe1b3">dr_register_module_load_event</a> (void(*func)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info,                                                                                                                                                                   bool loaded))</td></tr>
<tr class="separator:adc710e0c8271c496af10a87608dbe1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e56608165ac7a2ea398265a856c98dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a8e56608165ac7a2ea398265a856c98dd">dr_unregister_module_load_event</a> (void(*func)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info,                                                                                                                                                                           bool loaded))</td></tr>
<tr class="separator:a8e56608165ac7a2ea398265a856c98dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd55b34e71e3677b70edffcf21277a3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#abd55b34e71e3677b70edffcf21277a3c">dr_register_module_unload_event</a> (void(*func)(void *drcontext,                                                                                                                                                                           const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info))</td></tr>
<tr class="separator:abd55b34e71e3677b70edffcf21277a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aad519ef20eb2d7c1225ed15f6a2ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a96aad519ef20eb2d7c1225ed15f6a2ea">dr_unregister_module_unload_event</a> (void(*func)(void *drcontext,                                                                                                                                                                                   const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info))</td></tr>
<tr class="separator:a96aad519ef20eb2d7c1225ed15f6a2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69adae9409a1871149da69e97747b84c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a69adae9409a1871149da69e97747b84c">dr_register_exception_event</a> (bool(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#adebe39e781c20b42f61c7d03ed560587">dr_exception_t</a> *excpt))</td></tr>
<tr class="separator:a69adae9409a1871149da69e97747b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f9e43726286983fbc2098705e6511d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a58f9e43726286983fbc2098705e6511d">dr_unregister_exception_event</a> (bool(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#adebe39e781c20b42f61c7d03ed560587">dr_exception_t</a> *excpt))</td></tr>
<tr class="separator:a58f9e43726286983fbc2098705e6511d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec572232450344efcba8923cae71d51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a7ec572232450344efcba8923cae71d51">dr_register_filter_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:a7ec572232450344efcba8923cae71d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7971a22fd3ed5db49daeebb4a828b802"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a7971a22fd3ed5db49daeebb4a828b802">dr_unregister_filter_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:a7971a22fd3ed5db49daeebb4a828b802"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa37d61a7f9dde4663b8dd4c3a44732f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:aa37d61a7f9dde4663b8dd4c3a44732f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35ce4aa4c919b8fb3cbda7df31a8efd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a35ce4aa4c919b8fb3cbda7df31a8efd5">dr_unregister_pre_syscall_event</a> (bool(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:a35ce4aa4c919b8fb3cbda7df31a8efd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a099441f8d147404355c66178e3b19f0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event</a> (void(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:a099441f8d147404355c66178e3b19f0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1068388ccc574a34456940f20b4e832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ab1068388ccc574a34456940f20b4e832">dr_unregister_post_syscall_event</a> (void(*func)(void *drcontext, int sysnum))</td></tr>
<tr class="separator:ab1068388ccc574a34456940f20b4e832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac512c0bd9feea08cb04dd923efb589"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a3ac512c0bd9feea08cb04dd923efb589">dr_register_signal_event</a> (<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#ab49900139eb46d5dde3b2b69c175c072">dr_siginfo_t</a> *siginfo))</td></tr>
<tr class="separator:a3ac512c0bd9feea08cb04dd923efb589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617160964e0d99807f40d06f2e627152"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a617160964e0d99807f40d06f2e627152">dr_unregister_signal_event</a> (<a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*func)(void *drcontext, <a class="el" href="dr__events_8h.html#ab49900139eb46d5dde3b2b69c175c072">dr_siginfo_t</a> *siginfo))</td></tr>
<tr class="separator:a617160964e0d99807f40d06f2e627152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9037603d0bd5bfca4198011adb8d10eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event</a> (void(*func)(void *drcontext, uint64 argument), <a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> id)</td></tr>
<tr class="separator:a9037603d0bd5bfca4198011adb8d10eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb75728570a2dd0f91493c1b857db525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#abb75728570a2dd0f91493c1b857db525">dr_unregister_nudge_event</a> (void(*func)(void *drcontext, uint64 argument), <a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> id)</td></tr>
<tr class="separator:abb75728570a2dd0f91493c1b857db525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d11fb8fbffdcb0cb6e7b87f804cb459"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a9d11fb8fbffdcb0cb6e7b87f804cb459">dr_nudge_client</a> (<a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> id, uint64 argument)</td></tr>
<tr class="separator:a9d11fb8fbffdcb0cb6e7b87f804cb459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa719c9575ca2329c03ab60ef41ba14c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="dr__config_8h.html#a5e24de02bea5743b74adb6e64af19ae7">dr_config_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#aa719c9575ca2329c03ab60ef41ba14c6">dr_nudge_client_ex</a> (process_id_t process_id, <a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a> client_id, uint64 argument, uint timeout_ms)</td></tr>
<tr class="separator:aa719c9575ca2329c03ab60ef41ba14c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef0822d6e77a04938787cf398992592"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a2ef0822d6e77a04938787cf398992592">dr_is_nudge_thread</a> (void *drcontext)</td></tr>
<tr class="separator:a2ef0822d6e77a04938787cf398992592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45b8261d2f42689802b54859cc0325cd"><td class="memItemLeft" align="right" valign="top">app_pc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a45b8261d2f42689802b54859cc0325cd">dr_persist_start</a> (void *perscxt)</td></tr>
<tr class="separator:a45b8261d2f42689802b54859cc0325cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07c53eb778bba7532da23c27270f2b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#af07c53eb778bba7532da23c27270f2b8">dr_persist_size</a> (void *perscxt)</td></tr>
<tr class="separator:af07c53eb778bba7532da23c27270f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f13d88a973780babf7fd223ffe8cb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ac8f13d88a973780babf7fd223ffe8cb6">dr_fragment_persistable</a> (void *drcontext, void *perscxt, void *tag)</td></tr>
<tr class="separator:ac8f13d88a973780babf7fd223ffe8cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0330c73cc6c45640b495261e480d387"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#ad0330c73cc6c45640b495261e480d387">dr_register_persist_ro</a> (size_t(*func_size)(void *drcontext, void *perscxt,                                                                                                                                                                   size_t file_offs, void **user_data OUT), bool(*func_persist)(void *drcontext, void *perscxt,                                                                                                                                                                       file_t fd, void *user_data), bool(*func_resurrect)(void *drcontext, void *perscxt,                                                                                                                                                                               byte **map INOUT))</td></tr>
<tr class="separator:ad0330c73cc6c45640b495261e480d387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a44654b9fe99d0b87b2bb08b55ffe4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a1a44654b9fe99d0b87b2bb08b55ffe4a">dr_unregister_persist_ro</a> (size_t(*func_size)(void *drcontext, void *perscxt,                                                                                                                                                                           size_t file_offs, void **user_data OUT), bool(*func_persist)(void *drcontext, void *perscxt,                                                                                                                                                                               file_t fd, void *user_data), bool(*func_resurrect)(void *drcontext, void *perscxt,                                                                                                                                                                                       byte **map INOUT))</td></tr>
<tr class="separator:a1a44654b9fe99d0b87b2bb08b55ffe4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686de5ec22fe3c88f5573237ceff9262"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a686de5ec22fe3c88f5573237ceff9262">dr_register_persist_rx</a> (size_t(*func_size)(void *drcontext, void *perscxt,                                                                                                                                                                   size_t file_offs, void **user_data OUT), bool(*func_persist)(void *drcontext, void *perscxt,                                                                                                                                                                       file_t fd, void *user_data), bool(*func_resurrect)(void *drcontext, void *perscxt,                                                                                                                                                                               byte **map INOUT))</td></tr>
<tr class="separator:a686de5ec22fe3c88f5573237ceff9262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46c303161be730564c10c22bafb52e61"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a46c303161be730564c10c22bafb52e61">dr_unregister_persist_rx</a> (size_t(*func_size)(void *drcontext, void *perscxt,                                                                                                                                                                           size_t file_offs, void **user_data OUT), bool(*func_persist)(void *drcontext, void *perscxt,                                                                                                                                                                               file_t fd, void *user_data), bool(*func_resurrect)(void *drcontext, void *perscxt,                                                                                                                                                                                       byte **map INOUT))</td></tr>
<tr class="separator:a46c303161be730564c10c22bafb52e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a884d8dd3428885ce1bc36e22e01e417a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a884d8dd3428885ce1bc36e22e01e417a">dr_register_persist_rw</a> (size_t(*func_size)(void *drcontext, void *perscxt,                                                                                                                                                                   size_t file_offs, void **user_data OUT), bool(*func_persist)(void *drcontext, void *perscxt,                                                                                                                                                                       file_t fd, void *user_data), bool(*func_resurrect)(void *drcontext, void *perscxt,                                                                                                                                                                               byte **map INOUT))</td></tr>
<tr class="separator:a884d8dd3428885ce1bc36e22e01e417a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840efb1ffa9b78a17c5ac9fde2be745e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a840efb1ffa9b78a17c5ac9fde2be745e">dr_unregister_persist_rw</a> (size_t(*func_size)(void *drcontext, void *perscxt,                                                                                                                                                                           size_t file_offs, void **user_data OUT), bool(*func_persist)(void *drcontext, void *perscxt,                                                                                                                                                                               file_t fd, void *user_data), bool(*func_resurrect)(void *drcontext, void *perscxt,                                                                                                                                                                                       byte **map INOUT))</td></tr>
<tr class="separator:a840efb1ffa9b78a17c5ac9fde2be745e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc6b86815c425b4378727b470533723b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#acc6b86815c425b4378727b470533723b">dr_register_persist_patch</a> (bool(*func_patch)(void *drcontext, void *perscxt,                                                                                                                                                                           byte *bb_start, size_t bb_size,                                                                                                                                                                           void *user_data))</td></tr>
<tr class="separator:acc6b86815c425b4378727b470533723b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c8abd8ae2c75cb1b7b6d68085b28bab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="dr__events_8h.html#a7c8abd8ae2c75cb1b7b6d68085b28bab">dr_unregister_persist_patch</a> (bool(*func_patch)(void *drcontext, void *perscxt,                                                                                                                                                                                   byte *bb_start, size_t bb_size,                                                                                                                                                                                   void *user_data))</td></tr>
<tr class="separator:a7c8abd8ae2c75cb1b7b6d68085b28bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Event callback registration routines. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="adebe39e781c20b42f61c7d03ed560587"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__exception__t.html">_dr_exception_t</a>  <a class="el" href="dr__events_8h.html#adebe39e781c20b42f61c7d03ed560587">dr_exception_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure passed with an exception event. Contains the machine context and the Win32 exception record. </p>

</div>
</div>
<a class="anchor" id="aef4b133cb2bf598ee968170d982c4e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__fault__fragment__info__t.html">_dr_fault_fragment_info_t</a>  <a class="el" href="dr__events_8h.html#aef4b133cb2bf598ee968170d982c4e62">dr_fault_fragment_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure passed within dr_exception_t, dr_siginfo_t, and dr_restore_state_info_t. Contains information about the code fragment inside the code cache at the exception/signal/translation interruption point. </p>

</div>
</div>
<a class="anchor" id="a19a4bd60d7607be81d77f466fd8d7f49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__restore__state__info__t.html">_dr_restore_state_info_t</a>  <a class="el" href="dr__events_8h.html#a19a4bd60d7607be81d77f466fd8d7f49">dr_restore_state_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure passed to a restore_state_ex event handler (see <a class="el" href="dr__events_8h.html#a2644b520ddec2ee4cecea0161dd3bee0">dr_register_restore_state_ex_event()</a>). Contains the machine context at the translation point and other translation information. </p>

</div>
</div>
<a class="anchor" id="ab49900139eb46d5dde3b2b69c175c072"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct__dr__siginfo__t.html">_dr_siginfo_t</a>  <a class="el" href="dr__events_8h.html#ab49900139eb46d5dde3b2b69c175c072">dr_siginfo_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data structure passed with a signal event. Contains the machine context at the signal interruption point and other signal information. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a4982c54b45ecb525aec1be6b00a9664a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__events_8h.html#a4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>DR will call the end trace event if it is registered prior to adding each basic block to a trace being generated. The return value of the event callback should be from the dr_custom_trace_action_t enum.</p>
<dl class="section note"><dt>Note</dt><dd>DR treats CUSTOM_TRACE_CONTINUE as an advisement only. Certain fragments are not suitable to be included in a trace and if DR runs into one it will end the trace regardless of what the client returns through the event callback. </dd></dl>

</div>
</div>
<a class="anchor" id="a689518ac5d1ad136b13e03012702b209"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling the behavior of basic blocks and traces when emitted into the code cache. These flags are bitmasks that can be combined by or-ing together. For multiple clients, the flags returned by each client are or-ed together. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb"></a>DR_EMIT_DEFAULT&#160;</td><td class="fielddoc">
<p>Emit as normal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced"></a>DR_EMIT_STORE_TRANSLATIONS&#160;</td><td class="fielddoc">
<p>Store translation information at emit time rather than calling the basic block or trace event later to recreate the information. Note that even if a standalone basic block has stored translations, if when it is added to a trace it does not request storage (and the trace callback also does not request storage) then the basic block callback may still be called to translate for the trace.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event()</a> </dd></dl>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a689518ac5d1ad136b13e03012702b209a8c6fbffdec0fe74acaf82d530ae03b00"></a>DR_EMIT_PERSISTABLE&#160;</td><td class="fielddoc">
<p>Only valid when applied to a basic block. Indicates that the block is eligible for persisting to a persistent code cache file on disk. By default, no blocks are eligible, as tools must take care in order to properly support persistence. Note that the block is not guaranteed to be persisted if it contains complex features that prevent DR from easily persisting it. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a689518ac5d1ad136b13e03012702b209a9e7a77890e426d1b88e02f29b8433a12"></a>DR_EMIT_MUST_END_TRACE&#160;</td><td class="fielddoc">
<p>Only valid when applied to a basic block. Indicates that the block must terminate a trace. Normally this should be set when an abnormal exit is used from the block that is incompatible with trace building's attempt to inline the continuation from the block to its successor. Note that invoking <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> from a clean call called from a block aborts trace building and thus this flag need not be set for that scenario. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a689518ac5d1ad136b13e03012702b209a184a564eaa6cee9890f98f8a2d1c9c89"></a>DR_EMIT_GO_NATIVE&#160;</td><td class="fielddoc">
<p>Requests that DR relinquish control of the current thread and let it run natively until the client indicates that DR should take over again. While native, on Windows, currently only the thread init event (<a class="el" href="dr__events_8h.html#a878920c40c76e2c18043f9db772a24c0">dr_register_thread_init_event()</a>) will be raised, and nothing on Linux: no events will occur in the native thread. On Windows, DR tries to monitor any actions a native thread might take that affect correct execution from the code cache, but running natively carries risks. Consider this feature experimental, particularly on Linux. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="ae2ea678cffff98daafd5aac5bdb65080"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080">dr_exit_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flags controlling thread behavior at process exit time in release build. See <a class="el" href="dr__events_8h.html#acede43748af42c6334a19fc30e48c5f4">dr_set_process_exit_behavior()</a> for further details. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="ae2ea678cffff98daafd5aac5bdb65080a0bd2d4f65566a9c5a9cb6dcf649e5eb8"></a>DR_EXIT_MULTI_THREAD&#160;</td><td class="fielddoc">
<p>Do not guarantee that the process exit event is executed single-threaded. This is equivalent to specifying the <code>-multi_thread_exit</code> runtime option. Setting this flag can improve process exit performance, but usually only when the <a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080ad0a85f8d8abbc6892c31f0b07d1f93aa">DR_EXIT_SKIP_THREAD_EXIT</a> flag is also set, or when no thread exit events are registered. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="ae2ea678cffff98daafd5aac5bdb65080ad0a85f8d8abbc6892c31f0b07d1f93aa"></a>DR_EXIT_SKIP_THREAD_EXIT&#160;</td><td class="fielddoc">
<p>Do not invoke thread exit event callbacks at process exit time. Thread exit event callbacks will still be invoked at other times. This is equivalent to setting the <code>-skip_thread_exit_at_exit</code> runtime option. Setting this flag can improve process exit performance, but usually only when the <a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080a0bd2d4f65566a9c5a9cb6dcf649e5eb8">DR_EXIT_MULTI_THREAD</a> flag is also set, or when no process exit event is registered. </p>
</td></tr>
</table>

</div>
</div>
<a class="anchor" id="af86ce68b89c76d46c92d36e58ddb7a33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return value of client signal event callback, determining how DR will proceed with the signal. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="af86ce68b89c76d46c92d36e58ddb7a33a45815215e4567ecfbe504d5bb7ab01bf"></a>DR_SIGNAL_DELIVER&#160;</td><td class="fielddoc">
<p>Deliver signal to the application as normal. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af86ce68b89c76d46c92d36e58ddb7a33aeb1a9eb7969b688a26e6e06fef4c6973"></a>DR_SIGNAL_SUPPRESS&#160;</td><td class="fielddoc">
<p>Suppress signal as though it never happened. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af86ce68b89c76d46c92d36e58ddb7a33a0c437214d4411687fe54ad8bb93399a1"></a>DR_SIGNAL_BYPASS&#160;</td><td class="fielddoc">
<p>Deliver signal according to the default SIG_DFL action, as would happen if the application had no handler. </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="af86ce68b89c76d46c92d36e58ddb7a33a866dcc1af9f9076edcbed9c8afb17e93"></a>DR_SIGNAL_REDIRECT&#160;</td><td class="fielddoc">
<p>Do not deliver the signal. Instead, redirect control to the application state specified in <a class="el" href="struct__dr__siginfo__t.html#a39d67200783b38f36093cde45ebe6940">dr_siginfo_t.mcontext</a>. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac8f13d88a973780babf7fd223ffe8cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_fragment_persistable </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in the <code>perscxt</code> opaque parameter passed to various persistence events and returns whether the fragment identified by <code>tag</code> is being persisted. This routine can be called outside of a persistence event, in which case the <code>perscxt</code> parameter should be NULL. </p>

</div>
</div>
<a class="anchor" id="a2ef0822d6e77a04938787cf398992592"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_is_nudge_thread </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>drcontext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On Windows, nudges are implemented via remotely injected threads. This routine returns whether or not the thread indicated by <code>drcontext</code> is such a nudge thread. </p><dl class="section note"><dt>Note</dt><dd>Windows only. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d11fb8fbffdcb0cb6e7b87f804cb459"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_nudge_client </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>argument</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers an asynchronous nudge event in the current process. The callback function registered with <a class="el" href="dr__events_8h.html#a9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a> will be called with the supplied <code>argument</code> (in a new non-application thread on Windows).</p>
<dl class="section note"><dt>Note</dt><dd>On Linux, the nudge will not be delivered until this thread exits the code cache. Thus, if this routine is called from a clean call, <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> should be used to ensure cache exit. </dd></dl>

</div>
</div>
<a class="anchor" id="aa719c9575ca2329c03ab60ef41ba14c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="dr__config_8h.html#a5e24de02bea5743b74adb6e64af19ae7">dr_config_status_t</a> dr_nudge_client_ex </td>
          <td>(</td>
          <td class="paramtype">process_id_t&#160;</td>
          <td class="paramname"><em>process_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>client_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64&#160;</td>
          <td class="paramname"><em>argument</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint&#160;</td>
          <td class="paramname"><em>timeout_ms</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers an asynchronous nudge event in a target process. The callback function registered with <a class="el" href="dr__events_8h.html#a9037603d0bd5bfca4198011adb8d10eb">dr_register_nudge_event()</a> for the specified client in the specified process will be called with the supplied <code>argument</code> (in a new non-application thread on Windows).</p>
<dl class="section note"><dt>Note</dt><dd>On Linux, if <code>pid</code> is the current process, the nudge will not be delivered until this thread exits the code cache. Thus, if this routine is called from a clean call and <code>pid</code> is the current process, <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> should be used to ensure cache exit.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">process_id</td><td>The system id of the process to nudge (see <a class="el" href="dr__tools_8h.html#a83b3658ca78e6b7adc81c57691f0fe50">dr_get_process_id()</a>)</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">client_id</td><td>The unique client ID provided at client registration.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">argument</td><td>An argument passed to the client's nudge handler.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout_ms</td><td>Windows only. The number of milliseconds to wait for each nudge to complete before continuing. If INFINITE is supplied then the wait is unbounded. If 0 is supplied the no wait is performed. If a non-0 wait times out DR_NUDGE_TIMEOUT will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A dr_config_status_t code indicating the result of the nudge. </dd></dl>

</div>
</div>
<a class="anchor" id="af07c53eb778bba7532da23c27270f2b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t dr_persist_size </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in the <code>perscxt</code> opaque parameter passed to various persistence events and returns the size of the code region being persisted. </p>

</div>
</div>
<a class="anchor" id="a45b8261d2f42689802b54859cc0325cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">app_pc dr_persist_start </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>perscxt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in the <code>perscxt</code> opaque parameter passed to various persistence events and returns the beginning address of the code region being persisted. </p>

</div>
</div>
<a class="anchor" id="a13e10779d8f91465a0b7aefdf4d87d16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_bb_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *bb,                                                                                                                                                                                                                                                                                                                   bool for_trace, bool translating)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the basic block event. DR calls <code>func</code> before inserting a new basic block into the code cache. When adding a basic block to a new trace, DR calls <code>func</code> again with <code>for_trace</code> set to true, giving the client the opportunity to keep its same instrumentation in the trace, or to change it. The original basic block's instrumentation is unchanged by whatever action is taken in the <code>for_trace</code> call.</p>
<p>DR constructs <em>dynamic basic blocks</em>, which are distinct from a compiler's classic basic blocks. DR does not know all entry points ahead of time, and will end up duplicating the tail of a basic block if a later entry point is discovered that targets the middle of a block created earlier, or if a later entry point targets straight-line code that falls through into code already present in a block.</p>
<p>DR may call <code>func</code> again if it needs to translate from code cache addresses back to application addresses, which happens on faulting instructions as well as in certain situations involving suspended threads or forcibly relocated threads. The <code>translating</code> parameter distinguishes the two types of calls and is further explained below.</p>
<ul>
<li><code>drcontext</code> is a pointer to the input program's machine context. Clients should not inspect or modify the context; it is provided as an opaque pointer (i.e., <code>void *</code>) to be passed to API routines that require access to this internal data. drcontext is specific to the current thread, but in normal configurations the basic block being created is thread-shared: thus, when allocating data structures with the same lifetime as the basic block, usually global heap (<a class="el" href="dr__tools_8h.html#a60faa40f7e8c819c34fd25cb367c5473">dr_global_alloc()</a>) is a better choice than heap tied to the thread that happened to first create the basic block (<a class="el" href="dr__tools_8h.html#a4274226adda06339e247e4a311abdd9b">dr_thread_alloc()</a>). Thread-private heap is fine for temporary structures such as <a class="el" href="structinstr__t.html">instr_t</a> and instrlist_t.</li>
<li><code>tag</code> is a unique identifier for the basic block fragment. Use <a class="el" href="dr__tools_8h.html#a724aa7f7e87a604071fffa0a01925bf0">dr_fragment_app_pc()</a> to translate it to an application address.</li>
<li><code>bb</code> is a pointer to the list of instructions that comprise the basic block. Clients can examine, manipulate, or completely replace the instructions in the list.</li>
<li><code>translating</code> indicates whether this callback is for basic block creation (false) or is for address translation (true). This is further explained below.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> flag.</dd></dl>
<p>The user is free to inspect and modify the block before it executes, but must adhere to the following restrictions:</p><ul>
<li>If there is more than one application branch, only the last can be conditional.</li>
<li>An application conditional branch must be the final instruction in the block.</li>
<li>An application direct call must be the final instruction in the block unless it is inserted by DR for elision and the subsequent instructions are the callee.</li>
<li>There can only be one indirect branch (call, jump, or return) in a basic block, and it must be the final instruction in the block.</li>
<li>There can only be one far branch (call, jump, or return) in a basic block, and it must be the final instruction in the block.</li>
<li>The exit control-flow of a block ending in a system call or int instruction cannot be changed, nor can instructions be inserted after the system call or int instruction itself, unless the system call or int instruction is removed entirely.</li>
<li>The number of an interrupt cannot be changed. (Note that the parameter to a system call, normally kept in the eax register, can be freely changed in a basic block: but not in a trace.)</li>
<li>A system call or interrupt instruction can only be added if it satisfies the above constraints: i.e., if it is the final instruction in the block and the only system call or interrupt.</li>
<li>All IT blocks must be legal. For example, application instructions inside an IT block cannot be removed or added to without also updating the OP_it instruction itself. Clients can use the combination of <a class="el" href="dr__ir__utils_8h.html#af0f0c67d5a85c6da782f77f6c360d40d">dr_remove_it_instrs()</a> and <a class="el" href="dr__ir__utils_8h.html#a53f876b55bf0a07d7667557fcf7a8343">dr_insert_it_instrs()</a> to more easily manage IT blocks while maintaining the simplicity of examining individual instructions in isolation.</li>
<li>The block's application source code (as indicated by the translation targets, set by <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a>) must remain within the original bounds of the block (the one exception to this is that a jump can translate to its target). Otherwise, DR's cache consistency algorithms cannot guarantee to properly invalidate the block if the source application code is modified. To send control to other application code regions, truncate the block and use a direct jump to target the desired address, which will then materialize in the subsequent block, rather than embedding the desired instructions in this block.</li>
<li>There is a limit on the size of a basic block in the code cache. DR performs its own modifications, especially on memory writes for cache consistency of self-modifying (or false sharing) code regions. If an assert fires in debug build indicating a limit was reached, either truncate blocks or use the -max_bb_instrs runtime option to ask DR to make them smaller.</li>
</ul>
<p>To support transparent fault handling, DR must translate a fault in the code cache into a fault at the corresponding application address. DR must also be able to translate when a suspended thread is examined by the application or by DR itself for internal synchronization purposes. If the client is only adding observational instrumentation (i.e., meta instructions: see <a class="el" href="dr__ir__instr_8h.html#ad0919782b67d3918ec6feb838e373f15">instr_set_meta()</a>) (which should not fault) and is not modifying, reordering, or removing application instructions, these details can be ignored. In that case the client should return <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> and set up its basic block callback to be deterministic and idempotent. If the client is performing modifications, then in order for DR to properly translate a code cache address the client must use <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a> in the basic block creation callback to set the corresponding application address (the address that should be presented to the application as the faulting address, or the address that should be restarted after a suspend) for each modified instruction and each added application instruction (see <a class="el" href="dr__ir__instr_8h.html#ab7d47ceb0c0c0b5f50b78346c85a7f47">instr_set_app()</a>).</p>
<p>There are two methods for using the translated addresses:</p>
<ol type="1">
<li>Return <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> from the basic block creation callback. DR will then store the translation addresses and use the stored information on a fault. The basic block callback for <code>tag</code> will not be called with <code>translating</code> set to true. Note that unless <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> is also returned for <code>for_trace</code> calls (or <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> is returned in the trace callback), each constituent block comprising the trace will need to be re-created with both <code>for_trace</code> and <code>translating</code> set to true. Storing translations uses additional memory that can be significant: up to 20% in some cases, as it prevents DR from using its simple data structures and forces it to fall back to its complex, corner-case design. This is why DR does not store all translations by default.</li>
<li>Return <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a7d25c4546544d1a8c0b77c69230772eb">DR_EMIT_DEFAULT</a> from the basic block creation callback. DR will then call the callback again during fault translation with <code>translating</code> set to true. All modifications to <code>bb</code> that were performed on the creation callback must be repeated on the translating callback. This option is only possible when basic block modifications are deterministic and idempotent, but it saves memory. Naturally, global state changes triggered by block creation should be wrapped in checks for <code>translating</code> being false. Even in this case, <a class="el" href="dr__ir__instr_8h.html#af1beda2d570ba04d74ca9cbd7c31bb1d">instr_set_translation()</a> should be called for application instructions even when <code>translating</code> is false, as DR may decide to store the translations at creation time for reasons of its own.</li>
</ol>
<p>Furthermore, if the client's modifications change any part of the machine state besides the program counter, the client should use <a class="el" href="dr__events_8h.html#ab259e0b7ab6f90de1c8b199877b819d3">dr_register_restore_state_event()</a> or <a class="el" href="dr__events_8h.html#a2644b520ddec2ee4cecea0161dd3bee0">dr_register_restore_state_ex_event()</a> to restore the registers and application memory to their original application values.</p>
<p>For meta instructions that do not reference application memory (i.e., they should not fault), leave the translation field as NULL. A NULL value instructs DR to use the subsequent application instruction's translation as the application address, and to fail when translating the full state. Since the full state will only be needed when relocating a thread (as stated, there will not be a fault here), failure indicates that this is not a valid relocation point, and DR's thread synchronization scheme will use another spot. If the translation field is set to a non-NULL value, the client should be willing to also restore the rest of the machine state at that point (restore spilled registers, etc.) via <a class="el" href="dr__events_8h.html#ab259e0b7ab6f90de1c8b199877b819d3">dr_register_restore_state_event()</a> or <a class="el" href="dr__events_8h.html#a2644b520ddec2ee4cecea0161dd3bee0">dr_register_restore_state_ex_event()</a>. This is necessary for meta instructions that reference application memory. DR takes care of such potentially-faulting instructions added by its own API routines (<a class="el" href="dr__ir__utils_8h.html#ae7b7bd1e750b8a24ebf401fb6a6d6d5e">dr_insert_clean_call()</a> arguments that reference application data, <a class="el" href="dr__ir__utils_8h.html#a919e2106df67eaaa5bc6c49d736543b5">dr_insert_mbr_instrumentation()</a>'s read of application indirect branch data, etc.)</p>
<dl class="section note"><dt>Note</dt><dd>In order to present a more straightforward code stream to clients, this release of DR disables several internal optimizations. As a result, some applications may see a performance degradation. Applications making heavy use of system calls are the most likely to be affected. Future releases may allow clients some control over performance versus visibility. The <a class="el" href="using.html#op_speed">-opt_speed</a> option can regain some of this performance at the cost of more complex basic blocks that cross control transfers.</dd>
<dd>
If multiple clients are present, the instruction list for a basic block passed to earlier-registered clients will contain the instrumentation and modifications put in place by later-registered clients.</dd>
<dd>
Basic blocks can be deleted due to hitting capacity limits or cache consistency events (when the source application code of a basic block is modified). In that case, the client will see a new basic block callback if the block is then executed again after deletion. The deletion event (<a class="el" href="dr__events_8h.html#a698501b03d64f07e1a32fc82c021b27a">dr_register_delete_event()</a>) will be raised at deletion time.</dd>
<dd>
If the -thread_private runtime option is specified, clients should expect to see duplicate tags for separate threads, albeit with different dcrcontext values. Additionally, DR employs a cache-sizing algorithm for thread private operation that proactively deletes fragments. Even with thread-shared caches enabled, however, certain situations cause DR to emit thread-private basic blocks (e.g., self-modifying code). In this case, clients should be prepared to see duplicate tags without an intermediate deletion.</dd>
<dd>
A client can change the control flow of the application by changing the control transfer instruction at end of the basic block. If a basic block is ended with a non-control transfer instruction, an application jump instruction can be inserted. If a basic block is ended with a conditional branch, <code>instrlist_set_fall_through_target</code> can be used to change the fall-through target. If a basic block is ended with a call instruction, <code>instrlist_set_return_target</code> can be used to change the return target of the call. </dd></dl>

</div>
</div>
<a class="anchor" id="a698501b03d64f07e1a32fc82c021b27a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_delete_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the fragment deletion event. DR calls <code>func</code> whenever it removes a fragment from the code cache. Due to DR's high-performance non-precise flushing, a fragment can be made inaccessible but not actually freed for some time. A new fragment can thus be created before the deletion event for the old fragment is raised. We recommended using a counter to ignore subsequent deletion events when using per-fragment data structures and duplicate fragments are seen.</p>
<dl class="section note"><dt>Note</dt><dd>drcontext may be NULL when thread-shared fragments are being deleted during process exit. For this reason, thread-private heap should not be used for data structures intended to be freed at thread-shared fragment deletion. </dd></dl>

</div>
</div>
<a class="anchor" id="a753fffe98b1f5ec53555bdbe21645782"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_end_trace_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#a4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*)(void *drcontext, void *tag, void *next_tag)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the end-trace event. DR calls <code>func</code> before extending a trace with a new basic block. The <code>func</code> should return one of the <a class="el" href="dr__events_8h.html#a4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a> enum values. </p>

</div>
</div>
<a class="anchor" id="a69adae9409a1871149da69e97747b84c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_exception_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, <a class="el" href="dr__events_8h.html#adebe39e781c20b42f61c7d03ed560587">dr_exception_t</a> *excpt)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the exception event. DR calls <code>func</code> whenever the application throws an exception. If <code>func</code> returns true, the exception is delivered to the application's handler along with any changes made to <code>excpt-&gt;mcontext</code>. If <code>func</code> returns false, the faulting instruction in the code cache is re-executed using <code>excpt-&gt;raw_mcontext</code>, including any changes made to that structure. Clients are expected to use <code>excpt-&gt;raw_mcontext</code> when using faults as a mechanism to push rare cases out of an instrumentation fastpath that need to examine instrumentation instructions rather than the translated application state and should normally not examine it for application instruction faults. Certain registers may not contain proper application values in <code>excpt-&gt;raw_mcontext</code> for exceptions in application instructions. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself when examining <code>excpt-&gt;raw_mcontext</code>.</p>
<p>If multiple callbacks are registered, the first one that returns false will short-circuit event delivery to later callbacks.</p>
<p>DR raises this event for exceptions outside the code cache that could come from code generated by a client. For such exceptions, mcontext is not translated and is identical to raw_mcontext.</p>
<p>To skip the passing of the exception to the application's exception handlers and to send control elsewhere instead, a client can call <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> from <code>func</code>.</p>
<dl class="section note"><dt>Note</dt><dd><code>excpt-&gt;fault_fragment_info</code> data is provided with <code>excpt-&gt;raw_mcontext</code>. It is valid only if <code>excpt-&gt;fault_fragment_info.cache_start_pc</code> is not <code>NULL</code>. It provides clients information about the code fragment being executed at the exception interruption point. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself. </dd>
<dd>
Only valid on Windows. </dd>
<dd>
The function is not called for RaiseException. </dd></dl>

</div>
</div>
<a class="anchor" id="a985537df683007e1392e8a3b095ef363"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the process exit event. DR calls <code>func</code> when the process exits. By default, the process exit event will be executed with only a single live thread. <a class="el" href="dr__events_8h.html#acede43748af42c6334a19fc30e48c5f4">dr_set_process_exit_behavior()</a> can provide superior exit performance for clients that have flexible exit event requirements.</p>
<p>On Linux, SYS_execve does NOT result in an exit event, but it WILL result in the client library being reloaded and its <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a> routine being called. </p>

</div>
</div>
<a class="anchor" id="a7ec572232450344efcba8923cae71d51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_filter_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the syscall filter event. DR calls <code>func</code> to decide whether to invoke the syscall events for each system call site encountered with a statically-determinable system call number. If <code>func</code> returns true, the pre-syscall (<a class="el" href="dr__events_8h.html#aa37d61a7f9dde4663b8dd4c3a44732f4">dr_register_pre_syscall_event()</a>) and post-syscall (<a class="el" href="dr__events_8h.html#a099441f8d147404355c66178e3b19f0f">dr_register_post_syscall_event()</a>) events will be invoked. Otherwise, the events may or may not occur, depending on whether DR itself needs to intercept them and whether the system call number is statically determinable. System call number determination can depend on whether the -opt_speed option is enabled. If a system call number is not determinable, the filter event will not be called, but the pre and post events will be called.</p>
<p>Intercepting every system call can be detrimental to performance for certain types of applications. Filtering provides for greater performance by letting uninteresting system calls execute without interception overhead. </p>

</div>
</div>
<a class="anchor" id="a82afd28406cbf06396e1a17ab100c6ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_fork_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the fork event. DR calls <code>func</code> whenever the application forks a new process. </p><dl class="section note"><dt>Note</dt><dd>Valid on Linux only. </dd></dl>

</div>
</div>
<a class="anchor" id="adc710e0c8271c496af10a87608dbe1b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_module_load_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   bool loaded)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module load event. DR calls <code>func</code> whenever the application loads a module (typically a library but this term includes the executable). The <code>loaded</code> parameter indicates whether the module is fully initialized by the loader or in the process of being loaded. This parameter is present only for backward compatibility: current versions of DR always pass true, and the client can assume that relocating, rebinding, and (on Linux) segment remapping have already occurred.</p>
<dl class="section note"><dt>Note</dt><dd>The module_data_t <code>info</code> passed to the callback routine is valid only for the duration of the callback and should not be freed; a persistent copy can be made with <a class="el" href="dr__tools_8h.html#a8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data()</a>.</dd>
<dd>
Registration cannot be done during the basic block event: it should be done at initialization time. </dd></dl>

</div>
</div>
<a class="anchor" id="abd55b34e71e3677b70edffcf21277a3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_module_unload_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the module unload event. DR calls <code>func</code> whenever the application unloads a module. </p><dl class="section note"><dt>Note</dt><dd>The module_data_t <code>*info</code> passed to the callback routine is valid only for the duration of the callback and should not be freed; a persistent copy can be made with <a class="el" href="dr__tools_8h.html#a8c99a2d79ed312cd852d57e975601adc">dr_copy_module_data()</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a9037603d0bd5bfca4198011adb8d10eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_nudge_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, uint64 argument)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for nudge events. External entities can nudge a process through the <a class="el" href="dr__config_8h.html#a9df3d364222898cebc24264a161e2a5f">dr_nudge_process()</a> or <a class="el" href="dr__config_8h.html#a56dbe16a233afc5d2803222799ecd490">dr_nudge_pid()</a> drconfig API routines on Windows or using the <code>nudgeunix</code> tool on Linux. A client in this process can use <a class="el" href="dr__events_8h.html#a9d11fb8fbffdcb0cb6e7b87f804cb459">dr_nudge_client()</a> to raise a nudge, while a client in another process can use <a class="el" href="dr__events_8h.html#aa719c9575ca2329c03ab60ef41ba14c6">dr_nudge_client_ex()</a>.</p>
<p>DR calls <code>func</code> whenever the current process receives a nudge. On Windows, the nudge event is delivered in a new non-application thread. Callers must specify the target client by passing the client ID that was provided in <a class="el" href="dr__api_8h.html#a2b938c98dd186cc94eef6880f9e3c3e9">dr_client_main()</a>. </p>

</div>
</div>
<a class="anchor" id="acc6b86815c425b4378727b470533723b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_register_persist_patch </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte *bb_start, size_t bb_size,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   void *user_data)&#160;</td>
          <td class="paramname"><em>func_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This patching interface is in flux and is subject to change in the next release. Consider it experimental in this release.</dd></dl>
<p>Registers a callback function for patching code prior to storing it in a persisted cache file. The length of each instruction cannot be changed, but displacements and offsets can be adjusted to make the code position-independent. A patch callback is only called once per persisted file, regardless of whether one or all of read-only, executable, or writable data has been added. Use the <code>user_data</code> parameter to pass the file offset or other data from the other persistence events to this one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_patch</td><td>The function to call to perform any necessary patching of the to-be-persisted basic block code. The function should decode up to <code>bb_size</code> bytes from <code>bb_start</code> and look for call or jump displacements or rip-relative data references that need to be updated to use data in the persisted file. There is no padding between instructions, so a simple decode loop will find every instruction. The <code>perscxt</code> parameter can be passed to the routines <a class="el" href="dr__events_8h.html#a45b8261d2f42689802b54859cc0325cd">dr_persist_start()</a>, <a class="el" href="dr__events_8h.html#af07c53eb778bba7532da23c27270f2b8">dr_persist_size()</a>, and <a class="el" href="dr__events_8h.html#ac8f13d88a973780babf7fd223ffe8cb6">dr_fragment_persistable()</a> to identify the region of code being persisted. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0330c73cc6c45640b495261e480d387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_register_persist_ro </td>
          <td>(</td>
          <td class="paramtype">size_t(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   size_t file_offs, void **user_data OUT)&#160;</td>
          <td class="paramname"><em>func_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   file_t fd, void *user_data)&#160;</td>
          <td class="paramname"><em>func_persist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte **map INOUT)&#160;</td>
          <td class="paramname"><em>func_resurrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers callback functions for storing read-only data in each persisted cache file. When generating a new persisted cache file, DR first calls <code>func_size</code> to obtain the size required for read-only data in each persisted cache file. DR subsequently calls <code>func_persist</code> to write the actual data. DR ensures that no other thread will execute in between the calls to <code>func_size</code> and <code>func_persist</code>.</p>
<p>Upon loading a previously-written persisted cache file, DR calls <code>func_resurrect</code> to validate and read back in data from the persisted file.</p>
<p>For each callback, the <code>perscxt</code> parameter can be passed to the routines <a class="el" href="dr__events_8h.html#a45b8261d2f42689802b54859cc0325cd">dr_persist_start()</a>, <a class="el" href="dr__events_8h.html#af07c53eb778bba7532da23c27270f2b8">dr_persist_size()</a>, and <a class="el" href="dr__events_8h.html#ac8f13d88a973780babf7fd223ffe8cb6">dr_fragment_persistable()</a> to identify the region of code being persisted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_size</td><td>The function to call to determine the size needed for persisted data. The <code>file_offs</code> parameter indicates the offset from the start of the persisted file where this data will reside (which is needed to calculate patch displacements). The callback can store a void* value into the address specified by <code>user_data</code>. This value will be passed to <code>func_persist</code> and if a patch callback is registered (see <a class="el" href="dr__events_8h.html#acc6b86815c425b4378727b470533723b">dr_register_persist_patch()</a>) to <code>func_patch</code>. The same value will be shared with persisted code callbacks (see <a class="el" href="dr__events_8h.html#a686de5ec22fe3c88f5573237ceff9262">dr_register_persist_rx()</a>) and writable data callbacks (see <a class="el" href="dr__events_8h.html#a884d8dd3428885ce1bc36e22e01e417a">dr_register_persist_rw()</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_persist</td><td>The function to call to write the actual data. Data to be persisted should be written to the file <code>fd</code> via <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a>. The data will be read-only when the persisted file is loaded back in for use. The return value of the function indicates success of the write. If the function returns false, the persisted cache file being generated will be abandoned under the assumption of a non-recoverable error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_resurrect</td><td>The function to call to validate previously written data. The <code>map</code> variable points to the mapped-in data that was written at persist time. The return value of the function indicates success of the resurrection. If the function returns false, the persisted cache file being loaded will be abandoned under the assumption of a non-recoverable error. Any validation that the persisted file is suitable for use should be performed by the function prior to any restoration work needed for the data. The <code>map</code> address should be updated to point to the end of the persisted data (i.e., on return it should equal its start value plus the size that was passed to dr_register_persist_ro_size()). DR will perform self-consistency checks, including whether the whole pcache is present and that a checksum of at least part of the file matches, prior to calling this callback. Thus, the client can assume that it is not truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>func_resurrect</code> may be called during persisted file generation if a persisted file already exists, in order to merge with that file. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a884d8dd3428885ce1bc36e22e01e417a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_register_persist_rw </td>
          <td>(</td>
          <td class="paramtype">size_t(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   size_t file_offs, void **user_data OUT)&#160;</td>
          <td class="paramname"><em>func_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   file_t fd, void *user_data)&#160;</td>
          <td class="paramname"><em>func_persist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte **map INOUT)&#160;</td>
          <td class="paramname"><em>func_resurrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers callback functions for storing writable data in each persisted cache file. When generating a new persisted cache file, DR first calls <code>func_size</code> to obtain the size required for writable data in each persisted cache file. DR subsequently calls <code>func_persist</code> to write the actual data. DR ensures that no other thread will execute in between the calls to <code>func_size</code> and <code>func_persist</code>.</p>
<p>Upon loading a previously-written persisted cache file, DR calls <code>func_resurrect</code> to validate and read back in data from the persisted file.</p>
<p>For each callback, the <code>perscxt</code> parameter can be passed to the routines <a class="el" href="dr__events_8h.html#a45b8261d2f42689802b54859cc0325cd">dr_persist_start()</a>, <a class="el" href="dr__events_8h.html#af07c53eb778bba7532da23c27270f2b8">dr_persist_size()</a>, and <a class="el" href="dr__events_8h.html#ac8f13d88a973780babf7fd223ffe8cb6">dr_fragment_persistable()</a> to identify the region of code being persisted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_size</td><td>The function to call to determine the size needed for persisted data. The <code>file_offs</code> parameter indicates the offset from the start of the persisted file where this data will reside (which is needed to calculate patch displacements). The callback can store a void* value into the address specified by <code>user_data</code>. This value will be passed to <code>func_persist</code> and if a patch callback is registered (see <a class="el" href="dr__events_8h.html#acc6b86815c425b4378727b470533723b">dr_register_persist_patch()</a>) to <code>func_patch</code>. The same value will be shared with persisted code callbacks (see <a class="el" href="dr__events_8h.html#a686de5ec22fe3c88f5573237ceff9262">dr_register_persist_rx()</a>) and read-only data callbacks (see <a class="el" href="dr__events_8h.html#ad0330c73cc6c45640b495261e480d387">dr_register_persist_ro()</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_persist</td><td>The function to call to write the actual data. Data to be persisted should be written to the file <code>fd</code> via <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a>. The data will be writable when the persisted file is loaded back in for use. The return value of the function indicates success of the write. If the function returns false, the persisted cache file being generated will be abandoned under the assumption of a non-recoverable error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_resurrect</td><td>The function to call to validate previously written data. The <code>map</code> variable points to the mapped-in data that was written at persist time. The return value of the function indicates success of the resurrection. If the function returns false, the persisted cache file being loaded will be abandoned under the assumption of a non-recoverable error. Any validation that the persisted file is suitable for use should be performed by the function prior to any restoration work needed for the data. The <code>map</code> address should be updated to point to the end of the persisted data (i.e., on return it should equal its start value plus the size that was passed to dr_register_persist_rw_size()). DR will perform self-consistency checks, including whether the whole pcache is present and that a checksum of at least part of the file matches, prior to calling this callback. Thus, the client can assume that it is not truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>func_resurrect</code> may be called during persisted file generation if a persisted file already exists, in order to merge with that file. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a686de5ec22fe3c88f5573237ceff9262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_register_persist_rx </td>
          <td>(</td>
          <td class="paramtype">size_t(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   size_t file_offs, void **user_data OUT)&#160;</td>
          <td class="paramname"><em>func_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   file_t fd, void *user_data)&#160;</td>
          <td class="paramname"><em>func_persist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte **map INOUT)&#160;</td>
          <td class="paramname"><em>func_resurrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers callback functions for storing executable code (outside of normal code blocks) in each persisted cache file. When generating a new persisted cache file, DR first calls <code>func_size</code> to obtain the size required for executable code in each persisted cache file. DR subsequently calls <code>func_persist</code> to write the actual code. DR ensures that no other thread will execute in between the calls to <code>func_size</code> and <code>func_persist</code>.</p>
<p>Upon loading a previously-written persisted cache file, DR calls <code>func_resurrect</code> to validate and read back in code from the persisted file.</p>
<p>For each callback, the <code>perscxt</code> parameter can be passed to the routines <a class="el" href="dr__events_8h.html#a45b8261d2f42689802b54859cc0325cd">dr_persist_start()</a>, <a class="el" href="dr__events_8h.html#af07c53eb778bba7532da23c27270f2b8">dr_persist_size()</a>, and <a class="el" href="dr__events_8h.html#ac8f13d88a973780babf7fd223ffe8cb6">dr_fragment_persistable()</a> to identify the region of code being persisted.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_size</td><td>The function to call to determine the size needed for persisted code. The <code>file_offs</code> parameter indicates the offset from the start of the persisted file where this code will reside (which is needed to calculate patch displacements). The callback can store a void* value into the address specified by <code>user_data</code>. This value will be passed to <code>func_persist</code> and if a patch callback is registered (see <a class="el" href="dr__events_8h.html#acc6b86815c425b4378727b470533723b">dr_register_persist_patch()</a>) to <code>func_patch</code>. The same value will be shared with read-only data callbacks (see <a class="el" href="dr__events_8h.html#ad0330c73cc6c45640b495261e480d387">dr_register_persist_ro()</a>) and writable data callbacks (see <a class="el" href="dr__events_8h.html#a884d8dd3428885ce1bc36e22e01e417a">dr_register_persist_rw()</a>). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_persist</td><td>The function to call to write the actual code. Code to be persisted should be written to the file <code>fd</code> via <a class="el" href="dr__tools_8h.html#aeddf708cc2271dc50209b3e78e1d23fb">dr_write_file()</a>. The code will be read-only when the persisted file is loaded back in for use. The return value of the function indicates success of the write. If the function returns false, the persisted cache file being generated will be abandoned under the assumption of a non-recoverable error. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func_resurrect</td><td>The function to call to validate previously written code. The <code>map</code> variable points to the mapped-in code that was written at persist time. The return value of the function indicates success of the resurrection. If the function returns false, the persisted cache file being loaded will be abandoned under the assumption of a non-recoverable error. Any validation that the persisted file is suitable for use should be performed by the function prior to any restoration work needed for the code. The <code>map</code> address should be updated to point to the end of the persisted data (i.e., on return it should equal its start value plus the size that was passed to dr_register_persist_rx_size()). DR will perform self-consistency checks, including whether the whole pcache is present and that a checksum of at least part of the file matches, prior to calling this callback. Thus, the client can assume that it is not truncated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><code>func_resurrect</code> may be called during persisted file generation if a persisted file already exists, in order to merge with that file. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>whether successful. </dd></dl>

</div>
</div>
<a class="anchor" id="a099441f8d147404355c66178e3b19f0f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_post_syscall_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the post-syscall event. DR calls <code>func</code> whenever the application just finished invoking a system call, if any client asked for that system call number to be intercepted via the filter event (<a class="el" href="dr__events_8h.html#a7ec572232450344efcba8923cae71d51">dr_register_filter_syscall_event()</a>) or if DR itself needs to intercept the system call. The result of the system call can be modified with <a class="el" href="dr__tools_8h.html#a601cd2b724ac627aef0756a4c4eee637">dr_syscall_set_result()</a> or <a class="el" href="dr__tools_8h.html#aaae7ca4aa76652ddaaacb1e8dad9f6af">dr_syscall_set_result_ex()</a>.</p>
<p>System calls that change control flow or terminate the current thread or process typically do not have a post-syscall event. These include SYS_exit, SYS_exit_group, SYS_execve, SYS_sigreturn, and SYS_rt_sigreturn on Linux, and NtTerminateThread, NtTerminateProcess (depending on the parameters), NtCallbackReturn, and NtContinue on Windows.</p>
<p>The application's machine state can be accessed and set with <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> and <a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext()</a>.</p>
<p>On MacOS, whether 32-bit or 64-bit, the system call number passed (<code>sysnum</code>) has been normalized to a positive number with the top 8 bits set to 0x1 for a Mach system call, 0x3 for Machdep, and 0x0 for BSD (allowing the direct use of SYS_ constants). Access the raw eax register to view the unmodified number.</p>
<p>Additional system calls may be invoked by calling <a class="el" href="dr__tools_8h.html#a76797a9310bf67ebeb820d80e11764b8">dr_syscall_invoke_another()</a> prior to returning from the post-syscall event callback. The system call to be invoked should be specified with <a class="el" href="dr__tools_8h.html#abc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum()</a>, and its parameters can be set with <a class="el" href="dr__tools_8h.html#ac21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param()</a>. </p>

</div>
</div>
<a class="anchor" id="aa37d61a7f9dde4663b8dd4c3a44732f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_pre_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the pre-syscall event. DR calls <code>func</code> whenever the application is about to invoke a system call, if any client asked for that system call number to be intercepted via the filter event (<a class="el" href="dr__events_8h.html#a7ec572232450344efcba8923cae71d51">dr_register_filter_syscall_event()</a>).</p>
<p>The application parameters to the system call can be viewed with <a class="el" href="dr__tools_8h.html#a1e01fe123ecc9908ada9c9fccbf3f6ab">dr_syscall_get_param()</a> and set with <a class="el" href="dr__tools_8h.html#ac21a83f1812443112303ef3ea8b76de2">dr_syscall_set_param()</a>. The system call number can also be changed with <a class="el" href="dr__tools_8h.html#abc80dfdf8bff3c3feb486aacd69aba7c">dr_syscall_set_sysnum()</a>.</p>
<p>The application's machine state can be accessed and set with <a class="el" href="dr__ir__utils_8h.html#a91ffde2808c16e07f323c34affa72209">dr_get_mcontext()</a> and <a class="el" href="dr__ir__utils_8h.html#a56568d24667f5d64264d0bad398727b3">dr_set_mcontext()</a>. Changing registers in this way overlaps with system call parameter changes on some platforms. On Linux, for SYS_clone, client changes to the ebp/rbp register will be ignored by the clone child.</p>
<p>On MacOS, whether 32-bit or 64-bit, the system call number passed (<code>sysnum</code>) has been normalized to a positive number with the top 8 bits set to 0x1 for a Mach system call, 0x3 for Machdep, and 0x0 for BSD (allowing the direct use of SYS_ constants). Access the raw eax register to view the unmodified number.</p>
<p>If <code>func</code> returns true, the application's system call is invoked normally; if <code>func</code> returns false, the system call is skipped. If it is skipped, the return value can be set with <a class="el" href="dr__tools_8h.html#a601cd2b724ac627aef0756a4c4eee637">dr_syscall_set_result()</a> or <a class="el" href="dr__tools_8h.html#aaae7ca4aa76652ddaaacb1e8dad9f6af">dr_syscall_set_result_ex()</a>. If the system call is skipped, there will not be a post-syscall event. If multiple callbacks are registered, the first one that returns false will short-circuit event delivery to later callbacks. </p>

</div>
</div>
<a class="anchor" id="ab259e0b7ab6f90de1c8b199877b819d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_restore_state_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mcontext,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   bool restore_memory, bool app_code_consistent)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the machine state restoration event. DR calls <code>func</code> whenever it needs to translate a code cache machine context from the code cache to its corresponding original application context. DR needs to translate when instructions fault in the cache as well as when a suspended thread is examined or relocated for internal purposes.</p>
<p>If a client is only adding instrumentation (meta-code: see <a class="el" href="dr__ir__instr_8h.html#ad03f60b3110fcbd793381245bed502be">instr_is_meta()</a>) that does not reference application memory, and is not reordering or removing application instructions, then it need not register for this event. If, however, a client is modifying application code or is adding code that can fault, the client must be capable of restoring the original context.</p>
<p>When DR needs to translate a code cache context, DR recreates the faulting instruction's containing fragment, storing translation information along the way, by calling the basic block and/or trace event callbacks with the <code>translating</code> parameter set to true. DR uses the recreated code to identify the application instruction (<code>mcontext.pc</code>) corresponding to the faulting code cache instruction. If the client asked to store translation information by returning <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> from the basic block or trace event callback, then this step of re-calling the event callback is skipped and the stored value is used as the application address (<code>mcontext.pc</code>).</p>
<p>DR then calls the fault state restoration event to allow the client to restore the registers and application memory to their proper values as they would have appeared if the original application code had been executed up to the <code>mcontext.pc</code> instruction. Memory should only be restored if the <code>restore_memory</code> parameter is true; if it is false, DR may only be querying for the address (<code>mcontext.pc</code>) or register state and may not relocate this thread.</p>
<p>The <code>app_code_consistent</code> parameter indicates whether the original application code containing the instruction being translated is guaranteed to still be in the same state it was when the code was placed in the code cache. This guarantee varies depending on the type of cache consistency being used by DR.</p>
<p>The client can update <code>mcontext.pc</code> in this callback. The client should not change <code>mcontext.flags:</code> it should remain DR_MC_ALL.</p>
<dl class="section note"><dt>Note</dt><dd>The passed-in <code>drcontext</code> may correspond to a different thread than the thread executing the callback. Do not assume that the executing thread is the target thread. </dd></dl>

</div>
</div>
<a class="anchor" id="a2644b520ddec2ee4cecea0161dd3bee0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_restore_state_ex_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, bool restore_memory,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="dr__events_8h.html#a19a4bd60d7607be81d77f466fd8d7f49">dr_restore_state_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the machine state restoration event with extended information.</p>
<p>This event is identical to that for <a class="el" href="dr__events_8h.html#ab259e0b7ab6f90de1c8b199877b819d3">dr_register_restore_state_event()</a> with the following exceptions:</p>
<ul>
<li>Additional information is provided in the dr_restore_state_info_t structure, including the pre-translation context (containing the address inside the code cache of the translation point) and the starting address of the containing fragment in the code cache. Certain registers may not contain proper application values in <code>info-&gt;raw_mcontext</code>. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself when examining <code>info-&gt;raw_mcontext</code>.</li>
<li>The callback function returns a boolean indicating the success of the translation. When DR is translating not for a fault but for thread relocation, the <code>restore_memory</code> parameter will be false. Such translation can target a meta-instruction that can fault (i.e., it has a non-NULL translation field). For that scenario, a client can choose not to translate. Such instructions do not always require full translation for faults, and allowing translation failure removes the requirement that a client must translate at all such instructions. Note, however, that returning false can cause performance degradation as DR must then resume the thread and attempt to re-suspend it at a safer spot. Clients must return true for translation points in application code in order to avoid catastropic failure to suspend, and should thus identify whether translation points are inside their own instrumentation before returning false. Translation for relocation will never occur in meta instructions, so clients only need to look for meta-may-fault instructions. Clients should never return false when <code>restore_memory</code> is true.</li>
<li>If multiple callbacks are registered, the first one that returns false will short-circuit event delivery to later callbacks. </li>
</ul>

</div>
</div>
<a class="anchor" id="a3ac512c0bd9feea08cb04dd923efb589"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_signal_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="dr__events_8h.html#ab49900139eb46d5dde3b2b69c175c072">dr_siginfo_t</a> *siginfo)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Requests that DR call the provided callback function <code>func</code> whenever a signal is received by any application thread. The return value of <code>func</code> determines whether DR delivers the signal to the application. To redirect execution return DR_SIGNAL_REDIRECT (do not call <a class="el" href="dr__ir__utils_8h.html#a9f612cf9d0ca2025b23d30b6f5bb0231">dr_redirect_execution()</a> from a signal callback). The callback function will be called even if the application has no handler or has registered a SIG_IGN or SIG_DFL handler. If multiple callbacks are registered, the first one that returns other than DR_SIGNAL_DELIVER will short-circuit event delivery to later callbacks.</p>
<p>Modifications to the fields of <code>siginfo-&gt;mcontext</code> will be propagated to the application if it has a handler for the signal, if DR_SIGNAL_DELIVER is returned.</p>
<p>The <code>siginfo-&gt;raw_mcontext</code> data is only provided for non-delayable signals (e.g., SIGSEGV) that must be delivered immediately. Whether it is supplied is specified in <code>siginfo-&gt;raw_mcontext_valid</code>. It is intended for clients using faults as a mechanism to push rare cases out of an instrumentation fastpath that need to examine instrumentation instructions rather than the translated application state. Certain registers may not contain proper application values in <code>excpt-&gt;raw_mcontext</code> for exceptions in application instructions. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself. If DR_SIGNAL_SUPPRESS is returned, <code>siginfo-&gt;mcontext</code> is ignored and <code>siginfo-&gt;raw_mcontext</code> is used as the resumption context. The client's changes to <code>siginfo-&gt;raw_mcontext</code> will take effect.</p>
<p>For a delayable signal, DR raises a signal event only when about to deliver the signal to the application. Thus, if the application has blocked a delayable signal, the corresponding signal event will not occur until the application unblocks the signal, even if such a signal is delivered by the kernel. For non-delayable signals, DR will raise a signal event on initial receipt of the signal, with the <code>siginfo-&gt;blocked</code> field set. Such a blocked signal will have a second event raised when it is delivered to the application (if it is not suppressed by the client, and if there is not already a pending blocked signal, for non-real-time signals).</p>
<p>DR raises this event for faults outside the code cache that could come from code generated by a client. For such cases, mcontext is not translated and is identical to raw_mcontext.</p>
<p>DR will not raise a signal event for a SIGSEGV or SIGBUS raised by a client code fault rather than the application. Use <a class="el" href="dr__tools_8h.html#a6a94558696130c76f34dcdac0ce50c47">dr_safe_read()</a>, <a class="el" href="dr__tools_8h.html#ab94f47b693cc7dd9eecba07d8cfd1bc8">dr_safe_write()</a>, or <a class="el" href="dr__tools_8h.html#adb9ba447c606e5e58400ac7b6ef719d1">DR_TRY_EXCEPT()</a> to prevent such faults.</p>
<dl class="section note"><dt>Note</dt><dd><code>siginfo-&gt;fault_fragment_info</code> data is provided with <code>siginfo-&gt;raw_mcontext</code>. It is valid only if <code>siginfo-&gt;fault_fragment_info.cache_start_pc</code> is not <code>NULL</code>. It provides clients information about the code fragment being executed at the signal interruption point. Clients are cautioned against relying on any details of code cache layout or register usage beyond instrumentation inserted by the client itself.</dd>
<dd>
Only valid on Linux.</dd>
<dd>
DR always requests SA_SIGINFO for all signals.</dd>
<dd>
This version of DR does not intercept the signals SIGCONT, SIGSTOP, SIGTSTP, SIGTTIN, or SIGTTOU. Future versions should add support for these signals.</dd>
<dd>
If the client uses signals for its own communication it should set a flag to distinguish its own uses of signals from the application's use. Races where the two are re-ordered should not be problematic. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b0c102bb9a99d67c3e62ea8b3790ff1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_thread_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread exit event. DR calls <code>func</code> whenever an application thread exits. The passed-in drcontext should be used instead of calling <a class="el" href="dr__tools_8h.html#a13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext()</a>, as the thread exit event may be invoked from other threads, and using <a class="el" href="dr__tools_8h.html#a13217cc252506b06184c7c72adedf26c">dr_get_current_drcontext()</a> can result in failure to clean up the right resources, and at process exit time it may return NULL.</p>
<p>See <a class="el" href="dr__events_8h.html#acede43748af42c6334a19fc30e48c5f4">dr_set_process_exit_behavior()</a> for options controlling performance and whether thread exit events are invoked at process exit time in release build. </p>

</div>
</div>
<a class="anchor" id="a878920c40c76e2c18043f9db772a24c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_thread_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the thread initialization event. DR calls <code>func</code> whenever the application creates a new thread. </p>

</div>
</div>
<a class="anchor" id="aaa474cbc8fe550606cf45187976e50c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_register_trace_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *trace,                                                                                                                                                                                                                                                                                                                                                                   bool translating)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registers a callback function for the trace event. DR calls <code>func</code> before inserting a new trace into the code cache. DR may call <code>func</code> again if it needs to translate from code cache addresses back to application addresses, which happens on faulting instructions as well as in certain situations involving suspended threads or forcibly relocated threads. The <code>translating</code> parameter distinguishes the two types of calls and behaves identically to the same parameter in the basic block callback: see <a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event()</a> for further details.</p>
<p>Traces are not built if the -disable_traces runtime option is specified.</p>
<ul>
<li><code>drcontext</code> is a pointer to the input program's machine context. Clients should not inspect or modify the context; it is provided as an opaque pointer (i.e., <code>void *</code>) to be passed to API routines that require access to this internal data.</li>
<li><code>tag</code> is a unique identifier for the trace fragment.</li>
<li><code>trace</code> is a pointer to the list of instructions that comprise the trace.</li>
<li><code>translating</code> indicates whether this callback is for trace creation (false) or is for fault address recreation (true). This is further explained below.</li>
</ul>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a> flag.</dd></dl>
<p>The user is free to inspect and modify the non-control-flow instructions in the trace before it executes, with certain restrictions that include those for basic blocks (see <a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event()</a>). Additional restrictions unique to traces also apply:</p><ul>
<li>The sequence of blocks composing the trace cannot be changed once the trace is created. Instead, modify the component blocks by changing the block continuation addresses in the basic block callbacks (called with <code>for_trace</code> set to true) as the trace is being built.</li>
<li>The (application) control flow instruction (if any) terminating each component block cannot be changed.</li>
<li>Application control flow instructions cannot be added.</li>
<li>The parameter to a system call, normally kept in the eax register, cannot be changed.</li>
<li>A system call or interrupt instruction cannot be added.</li>
<li>If both a floating-point state save instruction (fnstenv, fnsave, fxsave, xsave, or xsaveopt) and a prior regular floating-point instruction are present, the regular instruction cannot be removed.</li>
</ul>
<p>If hitting a size limit due to extensive instrumentation, reduce the -max_trace_bbs option to start with a smaller trace.</p>
<p>The basic block restrictions on modifying application source code apply to traces as well. If the user wishes to change which basic blocks comprise the trace, either the <a class="el" href="dr__events_8h.html#a753fffe98b1f5ec53555bdbe21645782">dr_register_end_trace_event()</a> should be used or the <code>for_trace</code> basic block callbacks should modify their continuation addresses via direct jumps.</p>
<p>All of the comments for <a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event()</a> regarding transparent fault handling and state translation apply to the trace callback as well. Please read those comments carefully.</p>
<dl class="section note"><dt>Note</dt><dd>As each basic block is added to a new trace, the basic block callback (see <a class="el" href="dr__events_8h.html#a13e10779d8f91465a0b7aefdf4d87d16">dr_register_bb_event()</a>) is called with its <code>for_trace</code> parameter set to true. In order to preserve basic block instrumentation inside of traces, a client need only act identically with respect to the <code>for_trace</code> parameter; it can ignore the trace event if its goal is to place instrumentation on all code.</dd>
<dd>
Certain control flow modifications applied to a basic block can prevent it from becoming part of a trace: e.g., adding additional application control transfers.</dd>
<dd>
If multiple clients are present, the instruction list for a trace passed to earlier-registered clients will contain the instrumentation and modifications put in place by later-registered clients; similarly for each constituent basic block.</dd>
<dd>
Traces can be deleted due to hitting capacity limits or cache consistency events (when the source application code of a trace is modified). In that case, the client will see a new trace callback if a new trace containing that code is created again after deletion. The deletion event (<a class="el" href="dr__events_8h.html#a698501b03d64f07e1a32fc82c021b27a">dr_register_delete_event()</a>) will be raised at deletion time. </dd></dl>

</div>
</div>
<a class="anchor" id="acede43748af42c6334a19fc30e48c5f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void dr_set_process_exit_behavior </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#ae2ea678cffff98daafd5aac5bdb65080">dr_exit_flags_t</a>&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specifies how process exit should be handled with respect to thread exit events and thread synchronization in release build. In debug build, and in release build by default, all threads are always synchronized at exit time, resulting in a single-threaded process exit event, and all thread exit event callbacks are always called. This routine can provide more performant exits in release build by avoiding the synchronization if the client is willing to skip thread exit events at process exit and is willing to execute its process exit event with multiple live threads. </p>

</div>
</div>
<a class="anchor" id="afa69e56ac00bd4709752a0211cfb620e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_bb_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *bb,                                                                                                                                                                                                                                                                                                                                                   bool for_trace, bool translating)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the basic block event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We do not recommend unregistering for the basic block event unless it aways returned <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a> (including when <code>for_trace</code> is true, or if the client has a trace creation callback that returns <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>). Unregistering can prevent proper state translation on a later fault or other translation event for this basic block or for a trace that includes this basic block. Instead of unregistering, turn the event callback into a nop. </dd></dl>

</div>
</div>
<a class="anchor" id="ac1ece32fa94f968b82ec94cfb2237f42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_delete_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the fragment deletion event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="af65bd74863fdb3fe4306bfce41085e47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_end_trace_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#a4982c54b45ecb525aec1be6b00a9664a">dr_custom_trace_action_t</a>(*)(void *drcontext, void *tag, void *next_tag)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the end-trace event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a58f9e43726286983fbc2098705e6511d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_exception_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, <a class="el" href="dr__events_8h.html#adebe39e781c20b42f61c7d03ed560587">dr_exception_t</a> *excpt)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the exception event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a69823e6d3133bb7da291fbe1b1313f8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the process exit event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a7971a22fd3ed5db49daeebb4a828b802"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_filter_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the syscall filter event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a4b02bc04d51b3d58cd741653ef1a26ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_fork_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the fork event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a8e56608165ac7a2ea398265a856c98dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_module_load_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   bool loaded)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback for the module load event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Unregistering for this event is not supported during the basic block event. </dd></dl>

</div>
</div>
<a class="anchor" id="a96aad519ef20eb2d7c1225ed15f6a2ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_module_unload_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   const <a class="el" href="struct__module__data__t.html">module_data_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the module unload event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="abb75728570a2dd0f91493c1b857db525"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_nudge_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, uint64 argument)&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="dr__defines_8h.html#a68540a70b4f8150a4fe6dcec91bf8825">client_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the nudge event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a7c8abd8ae2c75cb1b7b6d68085b28bab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_persist_patch </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte *bb_start, size_t bb_size,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   void *user_data)&#160;</td>
          <td class="paramname"><em>func_patch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for patching persisted code. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., the function was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a1a44654b9fe99d0b87b2bb08b55ffe4a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_persist_ro </td>
          <td>(</td>
          <td class="paramtype">size_t(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   size_t file_offs, void **user_data OUT)&#160;</td>
          <td class="paramname"><em>func_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   file_t fd, void *user_data)&#160;</td>
          <td class="paramname"><em>func_persist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte **map INOUT)&#160;</td>
          <td class="paramname"><em>func_resurrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister callback functions for storing read-only data in a persisted cache file. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., one of the functions was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a840efb1ffa9b78a17c5ac9fde2be745e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_persist_rw </td>
          <td>(</td>
          <td class="paramtype">size_t(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   size_t file_offs, void **user_data OUT)&#160;</td>
          <td class="paramname"><em>func_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   file_t fd, void *user_data)&#160;</td>
          <td class="paramname"><em>func_persist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte **map INOUT)&#160;</td>
          <td class="paramname"><em>func_resurrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister callback functions for storing writable data in a persisted cache file. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., one of the functions was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a46c303161be730564c10c22bafb52e61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_persist_rx </td>
          <td>(</td>
          <td class="paramtype">size_t(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   size_t file_offs, void **user_data OUT)&#160;</td>
          <td class="paramname"><em>func_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   file_t fd, void *user_data)&#160;</td>
          <td class="paramname"><em>func_persist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*)(void *drcontext, void *perscxt,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   byte **map INOUT)&#160;</td>
          <td class="paramname"><em>func_resurrect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister callback functions for storing executable code in a persisted cache file. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., one of the functions was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="ab1068388ccc574a34456940f20b4e832"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_post_syscall_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the post-syscall event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a35ce4aa4c919b8fb3cbda7df31a8efd5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_pre_syscall_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, int sysnum)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the pre-syscall event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a77bd22c601584470d98081dbd67d41d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_restore_state_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext, void *tag, <a class="el" href="dr__defines_8h.html#a5d50a4225e834d67f66438669608e435">dr_mcontext_t</a> *mcontext,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   bool restore_memory, bool app_code_consistent)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the machine state restoration event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a98c7bb4d34bec089bf8b2ee59d8c31bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_restore_state_ex_event </td>
          <td>(</td>
          <td class="paramtype">bool(*)(void *drcontext, bool restore_memory,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   <a class="el" href="dr__events_8h.html#a19a4bd60d7607be81d77f466fd8d7f49">dr_restore_state_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the machine state restoration event with extended ifnormation. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a617160964e0d99807f40d06f2e627152"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_signal_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#af86ce68b89c76d46c92d36e58ddb7a33">dr_signal_action_t</a>(*)(void *drcontext, <a class="el" href="dr__events_8h.html#ab49900139eb46d5dde3b2b69c175c072">dr_siginfo_t</a> *siginfo)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the signal event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="ac85b9e60aee5a1b51f102f99471ef4b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_thread_exit_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the thread exit event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="aff5286475e21b7a5aaca3e084f8ad1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_thread_init_event </td>
          <td>(</td>
          <td class="paramtype">void(*)(void *drcontext)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the thread initialization event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered). </dd></dl>

</div>
</div>
<a class="anchor" id="a49e35b747be897c7f15ecab851e5ac50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool dr_unregister_trace_event </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209">dr_emit_flags_t</a>(*)(void *drcontext, void *tag, instrlist_t *trace,                                                                                                                                                                                                                                                                                                                                                                                                   bool translating)&#160;</td>
          <td class="paramname"><em>func</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister a callback function for the trace event. </p><dl class="section return"><dt>Returns</dt><dd>true if unregistration is successful and false if it is not (e.g., <code>func</code> was not registered).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>We do not recommend unregistering for the trace event unless it always returned <a class="el" href="dr__events_8h.html#a689518ac5d1ad136b13e03012702b209a80b741b6a35dc7424940a873bfee2ced">DR_EMIT_STORE_TRANSLATIONS</a>, as doing so can prevent proper state translation on a later fault or other translation event. Instead of unregistering, turn the event callback into a nop. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.10-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_7e8c68b3a1981dda5ab1ff5587b4f0bc.html">include</a></li><li class="navelem"><a class="el" href="dr__events_8h.html">dr_events.h</a></li>
    <li class="footer" style="float:none;text-align:center"><img border=0 src="favicon.png"> &nbsp;  DynamoRIO API version 7.0.0 --- Fri Feb 3 2017 00:37:39 &nbsp; <img border=0 src="favicon.png">
</small></address>
<!--END !GENERATE_TREEVIEW-->
</body>
</html>
